"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const semver = require("semver");
const callWithTelemetryAndErrorHandling_1 = require("./callWithTelemetryAndErrorHandling");
const getPackageInfo_1 = require("./getPackageInfo");
const localize_1 = require("./localize");
function createApiProvider(azExts) {
    for (const azExt of azExts) {
        if (!semver.valid(azExt.apiVersion)) {
            throw new Error(localize_1.localize('invalidVersion', 'Invalid semver "{0}".', azExt.apiVersion));
        }
    }
    const extensionId = getPackageInfo_1.getPackageInfo().extensionId;
    return {
        getApi: (apiVersionRange) => getApiInternal(azExts, extensionId, apiVersionRange)
    };
}
exports.createApiProvider = createApiProvider;
class ApiVersionError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
function getApiInternal(azExts, extensionId, apiVersionRange) {
    return callWithTelemetryAndErrorHandling_1.callWithTelemetryAndErrorHandlingSync('getApi', function () {
        this.rethrowError = true;
        this.suppressErrorDisplay = true;
        this.properties.isActivationEvent = 'true';
        this.properties.apiVersionRange = apiVersionRange;
        const apiVersions = azExts.map((a) => a.apiVersion);
        this.properties.apiVersions = apiVersions.join(', ');
        const matchedApiVersion = semver.maxSatisfying(apiVersions, apiVersionRange);
        if (matchedApiVersion) {
            return (azExts.find((a) => a.apiVersion === matchedApiVersion));
        }
        else {
            const minApiVersion = semver.minSatisfying(apiVersions, '');
            let message;
            let code;
            if (minApiVersion && semver.gtr(minApiVersion, apiVersionRange)) {
                // This case will hopefully never happen if we maintain backwards compat
                message = localize_1.localize('notSupported', 'API version "{0}" for extension id "{1}" is no longer supported. Minimum version is "{2}".', apiVersionRange, extensionId, minApiVersion);
                code = 'NoLongerSupported';
            }
            else {
                // This case is somewhat likely - so keep the error message simple and just tell user to update their extenion
                message = localize_1.localize('updateExtension', 'Extension dependency with id "{0}" must be updated.', extensionId);
                code = 'NotYetSupported';
            }
            throw new ApiVersionError(message, code);
        }
    });
}
//# sourceMappingURL=createApiProvider.js.map