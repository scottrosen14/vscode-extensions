module.exports=function(e){var t={};function i(s){if(t[s])return t[s].exports;var o=t[s]={i:s,l:!1,exports:{}};return e[s].call(o.exports,o,o.exports,i),o.l=!0,o.exports}return i.m=e,i.c=t,i.d=function(e,t,s){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(i.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)i.d(s,o,function(t){return e[t]}.bind(null,o));return s},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i.oe=function(e){process.nextTick(function(){throw e})},i(i.s=12)}([function(e,t){e.exports=require("vscode")},function(e,t){e.exports=require("path")},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("tslib")},function(e,t){e.exports=require("iconv-lite")},function(e,t){e.exports=require("date-fns")},function(e,t){e.exports=require("crypto")},function(e,t){e.exports=require("date-fns/locale/en")},function(e,t){e.exports=require("child_process")},function(e,t){e.exports=require("lodash.debounce")},function(e,t){e.exports=require("lodash.once")},function(e){e.exports={100:"💯",1234:"🔢",gleeful:"😀",blissful:"😁",grin:"😁",joyful:"😂",haha:"😂",entertained:"🤣",rofl:"🤣",glad:"😃",smile:"😃",happy:"😄",embarassed:"😅",amused:"😆",laugh:"😆",lol:"😆",coy:"😉",wink:"😉",anxious:"😊",blush:"😊",yum:"😋",savour:"😋",confident:"😎",lovestruck:"😍",flirty:"😘",love:"🥰",kiss:"😗",happy_kiss:"😙",loving_kiss:"😚",relaxed:"☺️",pleased:"🙂",hugging:"🤗",starstruck:"🤩",curious:"🤔",thinking:"🤔",contempt:"🤨",indifferent:"😐️",neutral:"😐️",apathetic:"😑",expressionless:"😑",vacant:"😶",no_mouth:"😶",disbelief:"🙄",cocky:"😏",smirk:"😏",persevered:"😣",hopeful:"😥",surprised:"😮",silenced:"🤐",zipper_mouth:"🤐",hushed:"😯",sleepy:"😪",tired:"😫",exhausted:"😴",sleeping:"😴",relieved:"😌",playful:"😛",tongue_out:"😛",mischievous:"😜",facetious:"😝",lmao:"😝",drooling:"🤤",unamused:"😒",shamed:"😓",pensive:"😔",confused:"😕",ecstatic:"🙃",upside_down:"🙃",pretentious:"🤑",money_mouth:"🤑",astonished:"😲",sad:"☹️",frowning:"☹️",cheerless:"🙁",confounded:"😖",disappointed:"😞",worried:"😟",annoyed:"😤",hrmph:"😤",upset:"😢",cry:"😢",distressed:"😭",sob:"😭",bored:"😦",anguished:"😧",wtf:"😧",fearful:"😨",weary:"😩",shocked:"🤯",exploding_head:"🤯",grimaced:"😬",frustrated:"😰",frightened:"😱",scream:"😱",overheating:"🥵",freezing:"🥶",flushed:"😳",crazy:"🤪",dizzy:"😵",enraged:"😡",pout:"😡",angry:"😠",censored:"🤬",ill:"😷",mask:"😷",sick:"🤒",injured:"🤕",nauseated:"🤢",vomiting:"🤮",sneezing:"🤧",innocent:"😇",halo:"😇",cowboy:"🤠",partying:"🥳",celebrating:"🥳",woozy:"🥴",pleading:"🥺",lying:"🤥",shushing:"🤫",gasp:"🤭",monocle:"🧐",nerd:"🤓",imp:"😈",angry_imp:"👿",clown:"🤡",ogre:"👹",goblin:"👺",skull:"💀",crossbones:"☠️",ghost:"👻",alien:"👽️",alien_monster:"👾",space_invader:"👾",robot:"🤖",poop:"💩",smiling_cat:"😺",grinning_cat:"😸",joyful_cat:"😹",lovestruck_cat:"😻",smirking_cat:"😼",kissing_cat:"😽",weary_cat:"🙀",crying_cat:"😿",pouting_cat:"😾",see_no_evil:"🙈",hear_no_evil:"🙉",speak_no_evil:"🙊",baby:"👶",child:"🧒",boy:"👦",girl:"👧",adult:"🧑",man:"👨",woman:"👩",older_adult:"🧓",older_man:"👴",older_woman:"👵",man_health_worker:"👨‍⚕️",woman_health_worker:"👩‍⚕️",man_student:"👨‍🎓",woman_student:"👩‍🎓",man_teacher:"👨‍🏫",woman_teacher:"👩‍🏫",man_judge:"👨‍⚖️",woman_judge:"👩‍⚖️",man_farmer:"👨‍🌾",woman_farmer:"👩‍🌾",man_cook:"👨‍🍳",woman_cook:"👩‍🍳",man_mechanic:"👨‍🔧",woman_mechanic:"👩‍🔧",man_factory_worker:"👨‍🏭",woman_factory_worker:"👩‍🏭",man_office_worker:"👨‍💼",woman_office_worker:"👩‍💼",man_scientist:"👨‍🔬",woman_scientist:"👩‍🔬",man_technologist:"👨‍💻",woman_technologist:"👩‍💻",man_singer:"👨‍🎤",woman_singer:"👩‍🎤",man_artist:"👨‍🎨",woman_artist:"👩‍🎨",man_pilot:"👨‍✈️",woman_pilot:"👩‍✈️",man_astronaut:"👨‍🚀",woman_astronaut:"👩‍🚀",man_firefighter:"👨‍🚒",woman_firefighter:"👩‍🚒",police_officer:"👮",man_police_officer:"👮‍♂️",woman_police_officer:"👮‍♀️",detective:"🕵️",man_detective:"🕵️‍♂️",woman_detective:"🕵️‍♀️",guard:"💂",man_guard:"💂‍♂️",woman_guard:"💂‍♀️",construction_worker:"👷",man_construction_worker:"👷‍♂️",woman_construction_worker:"👷‍♀️",prince:"🤴",princess:"👸",person_turban:"👳",man_turban:"👳‍♂️",woman_turban:"👳‍♀️",man_chinese_cap:"👲",woman_headscarf:"🧕",bearded_person:"🧔",blond_person:"👱",blond_man:"👱‍♂️",blond_woman:"👱‍♀️",red_haired_man:"👨‍🦰",red_haired_woman:"👩‍🦰",curly_haired_man:"👨‍🦱",curly_haired_woman:"👩‍🦱",bald_man:"👨‍🦲",bald_woman:"👩‍🦲",white_haired_man:"👨‍🦳",white_haired_woman:"👩‍🦳",man_tuxedo:"🤵",bride_veil:"👰",pregnant_woman:"🤰",breast_feeding:"🤱",baby_angel:"👼",santa:"🎅",mrs_claus:"🤶",hero:"🦸",superhero:"🦸",woman_hero:"🦸‍♀️",man_hero:"🦸‍♂️",villain:"🦹",supervillain:"🦹",woman_villain:"🦹‍♀️",man_villain:"🦹‍♂️",mage:"🧙",woman_mage:"🧙‍♀️",man_mage:"🧙‍♂️",fairy:"🧚",woman_fairy:"🧚‍♀️",man_fairy:"🧚‍♂️",vampire:"🧛",woman_vampire:"🧛‍♀️",man_vampire:"🧛‍♂️",merperson:"🧜",mermaid:"🧜‍♀️",merman:"🧜‍♂️",elf:"🧝",woman_elf:"🧝‍♀️",man_elf:"🧝‍♂️",genie:"🧞",woman_genie:"🧞‍♀️",man_genie:"🧞‍♂️",zombie:"🧟",woman_zombie:"🧟‍♀️",man_zombie:"🧟‍♂️",person_frowning:"🙍",man_frowning:"🙍‍♂️",woman_frowning:"🙍‍♀️",person_pouting:"🙎",man_pouting:"🙎‍♂️",woman_pouting:"🙎‍♀️",person_gesturing_no:"🙅",man_gesturing_no:"🙅‍♂️",woman_gesturing_no:"🙅‍♀️",person_gesturing_ok:"🙆",man_gesturing_ok:"🙆‍♂️",woman_gesturing_ok:"🙆‍♀️",person_tipping_hand:"💁",man_tipping_hand:"💁‍♂️",woman_tipping_hand:"💁‍♀️",person_raising_hand:"🙋",man_raising_hand:"🙋‍♂️",woman_raising_hand:"🙋‍♀️",person_bowing:"🙇",man_bowing:"🙇‍♂️",woman_bowing:"🙇‍♀️",person_facepalming:"🤦",man_facepalming:"🤦‍♂️",woman_facepalming:"🤦‍♀️",person_shrugging:"🤷",man_shrugging:"🤷‍♂️",woman_shrugging:"🤷‍♀️",person_getting_massage:"💆",man_getting_face_massage:"💆‍♂️",woman_getting_face_massage:"💆‍♀️",person_getting_haircut:"💇",man_getting_haircut:"💇‍♂️",woman_getting_haircut:"💇‍♀️",person_walking:"🚶",man_walking:"🚶‍♂️",woman_walking:"🚶‍♀️",person_running:"🏃",man_running:"🏃‍♂️",woman_running:"🏃‍♀️",dancer:"💃",woman_dancing:"💃",man_dancing:"🕺",people_bunny_ears_partying:"👯",men_bunny_ears_partying:"👯‍♂️",women_bunny_ears_partying:"👯‍♀️",person_steamy_room:"🧖",woman_steamy_room:"🧖‍♀️",man_steamy_room:"🧖‍♂️",person_climbing:"🧗",woman_climbing:"🧗‍♀️",man_climbing:"🧗‍♂️",person_lotus_position:"🧘",woman_lotus_position:"🧘‍♀️",man_lotus_position:"🧘‍♂️",bath:"🛀",in_bed:"🛌",levitate:"🕴️",speaking_head:"🗣️",bust_silhouette:"👤",busts_silhouette:"👥",person_fencing:"🤺",horse_racing:"🏇",skier:"⛷️",snowboarder:"🏂️",person_golfing:"🏌️",man_golfing:"🏌️‍♂️",woman_golfing:"🏌️‍♀️",person_surfing:"🏄️",man_surfing:"🏄‍♂️",woman_surfing:"🏄‍♀️",person_rowing_boat:"🚣",man_rowing_boat:"🚣‍♂️",woman_rowing_boat:"🚣‍♀️",person_swimming:"🏊️",man_swimming:"🏊‍♂️",woman_swimming:"🏊‍♀️",person_bouncing_ball:"⛹️",man_bouncing_ball:"⛹️‍♂️",woman_bouncing_ball:"⛹️‍♀️",person_lifting_weights:"🏋️",man_lifting_weights:"🏋️‍♂️",woman_lifting_weights:"🏋️‍♀️",person_biking:"🚴",man_biking:"🚴‍♂️",woman_biking:"🚴‍♀️",person_mountain_biking:"🚵",man_mountain_biking:"🚵‍♂️",woman_mountain_biking:"🚵‍♀️",race_car:"🏎️",motorcycle:"🏍️",person_cartwheel:"🤸",man_cartwheeling:"🤸‍♂️",woman_cartwheeling:"🤸‍♀️",people_wrestling:"🤼",men_wrestling:"🤼‍♂️",women_wrestling:"🤼‍♀️",person_water_polo:"🤽",man_water_polo:"🤽‍♂️",woman_water_polo:"🤽‍♀️",person_handball:"🤾",man_handball:"🤾‍♂️",woman_handball:"🤾‍♀️",person_juggling:"🤹",man_juggling:"🤹‍♂️",woman_juggling:"🤹‍♀️",holding_hands_mw:"👫",holding_hands_wm:"👫",holding_hands_mm:"👬",holding_hands_ww:"👭",couple:"💏",kiss_mw:"👩‍❤️‍💋‍👨",kiss_wm:"👩‍❤️‍💋‍👨",kiss_mm:"👨‍❤️‍💋‍👨",kiss_ww:"👩‍❤️‍💋‍👩",couple_heart:"💑",couple_mw:"👩‍❤️‍👨",couple_wm:"👩‍❤️‍👨",couple_mm:"👨‍❤️‍👨",couple_ww:"👩‍❤️‍👩",family:"👪️",family_mwb:"👨‍👩‍👦",family_mwg:"👨‍👩‍👧",family_mwgb:"👨‍👩‍👧‍👦",family_mwbb:"👨‍👩‍👦‍👦",family_mwgg:"👨‍👩‍👧‍👧",family_mmb:"👨‍👨‍👦",family_mmg:"👨‍👨‍👧",family_mmgb:"👨‍👨‍👧‍👦",family_mmbb:"👨‍👨‍👦‍👦",family_mmgg:"👨‍👨‍👧‍👧",family_wwb:"👩‍👩‍👦",family_wwg:"👩‍👩‍👧",family_wwgb:"👩‍👩‍👧‍👦",family_wwbb:"👩‍👩‍👦‍👦",family_wwgg:"👩‍👩‍👧‍👧",family_mb:"👨‍👦",family_mbb:"👨‍👦‍👦",family_mg:"👨‍👧",family_mgb:"👨‍👧‍👦",family_mgg:"👨‍👧‍👧",family_wb:"👩‍👦",family_wbb:"👩‍👦‍👦",family_wg:"👩‍👧",family_wgb:"👩‍👧‍👦",family_wgg:"👩‍👧‍👧",selfie:"🤳",muscle:"💪",right_bicep:"💪",leg:"🦵",foot:"🦶",point_left:"👈️",point_right:"👉️",point_up:"☝️",backhand_point_up:"👆️",middle_finger:"🖕",point_down:"👇️",victory:"✌️",fingers_crossed:"🤞",vulcan:"🖖",metal:"🤘",call_me:"🤙",splayed_hand:"🖐️",raised_hand:"✋",ok_hand:"👌",thumbsup:"👍️","+1":"👍️",yes:"👍️",thumbsdown:"👎️","-1":"👎️",no:"👎️",fist:"✊",punch:"👊",left_facing_fist:"🤛",right_facing_fist:"🤜",raised_backhand:"🤚",wave:"👋",love_you_gesture:"🤟",writing_hand:"✍️",clap:"👏",open_hands:"👐",raised_hands:"🙌",palms_up:"🤲",pray:"🙏",handshake:"🤝",nail_care:"💅",ear:"👂️",nose:"👃",footprints:"👣",eyes:"👀",eye:"👁️",eye_bubble:"👁️‍🗨️",brain:"🧠",bone:"🦴",tooth:"🦷",tongue:"👅",lips:"👄",kiss_lips:"💋",cupid:"💘",heart:"❤️",heartbeat:"💓",broken_heart:"💔",two_hearts:"💕",sparkling_heart:"💖",heartpulse:"💗",blue_heart:"💙",green_heart:"💚",yellow_heart:"💛",orange_heart:"🧡",purple_heart:"💜",black_heart:"🖤",heart_ribbon:"💝",revolving_hearts:"💞",heart_decoration:"💟",heart_exclamation:"❣️",love_letter:"💌",zzz:"💤",anger:"💢",bomb:"💣️",boom:"💥",collision:"💥",sweat_drops:"💦",dash:"💨",dizzy_star:"💫",speech:"💬",left_speech:"🗨️",right_anger_speech:"🗯️",thought:"💭",hole:"🕳️",glasses:"👓️",sunglasses:"🕶️",goggles:"🥽",lab_coat:"🥼",necktie:"👔",tie:"👔",shirt:"👕",jeans:"👖",scarf:"🧣",gloves:"🧤",coat:"🧥",socks:"🧦",dress:"👗",kimono:"👘",bikini:"👙",blouse:"👚",womans_clothes:"👚",purse:"👛",handbag:"👜",pouch:"👝",clutch_bag:"👝",shopping_bags:"🛍️",backpack:"🎒",dress_shoe:"👞",mans_shoe:"👞",sneaker:"👟",athletic_shoe:"👟",hiking_boot:"🥾",flat_shoe:"🥿",high_heel:"👠",womans_sandal:"👡",womans_boot:"👢",crown:"👑",womans_hat:"👒",top_hat:"🎩",graduation_cap:"🎓️",billed_cap:"🧢",helmet_cross:"⛑️",prayer_beads:"📿",lipstick:"💄",ring:"💍",gem:"💎",monkey_face:"🐵",monkey:"🐒",gorilla:"🦍",dog_face:"🐶",dog:"🐕️",poodle:"🐩",wolf_face:"🐺",fox_face:"🦊",raccoon:"🦝",cat_face:"🐱",cat:"🐈️",lion_face:"🦁",tiger_face:"🐯",tiger:"🐅",leopard:"🐆",horse_face:"🐴",horse:"🐎",unicorn_face:"🦄",zebra:"🦓",deer:"🦌",cow_face:"🐮",ox:"🐂",water_buffalo:"🐃",cow:"🐄",pig_face:"🐷",pig:"🐖",boar:"🐗",pig_nose:"🐽",ram:"🐏",sheep:"🐑",goat:"🐐",camel:"🐪",two_hump_camel:"🐫",llama:"🦙",giraffe:"🦒",elephant:"🐘",rhino:"🦏",hippo:"🦛",mouse_face:"🐭",mouse:"🐁",rat:"🐀",hamster_face:"🐹",rabbit_face:"🐰",rabbit:"🐇",chipmunk:"🐿️",hedgehog:"🦔",bat:"🦇",bear_face:"🐻",koala_face:"🐨",panda_face:"🐼",kangaroo:"🦘",badger:"🦡",feet:"🐾",turkey:"🦃",chicken:"🐔",rooster:"🐓",hatching_chick:"🐣",baby_chick:"🐤",hatched_chick:"🐥",bird:"🐦️",penguin:"🐧",dove:"🕊️",eagle:"🦅",duck:"🦆",swan:"🦢",owl:"🦉",peacock:"🦚",parrot:"🦜",frog_face:"🐸",crocodile:"🐊",turtle:"🐢",lizard:"🦎",snake:"🐍",dragon_face:"🐲",dragon:"🐉",sauropod:"🦕",trex:"🦖",spouting_whale:"🐳",whale:"🐋",dolphin:"🐬",fish:"🐟️",tropical_fish:"🐠",blowfish:"🐡",shark:"🦈",octopus:"🐙",shell:"🐚",crab:"🦀",lobster:"🦞",shrimp:"🦐",squid:"🦑",snail:"🐌",butterfly:"🦋",bug:"🐛",ant:"🐜",bee:"🐝",beetle:"🐞",cricket:"🦗",spider:"🕷️",spider_web:"🕸️",scorpion:"🦂",mosquito:"🦟",microbe:"🦠",germ:"🦠",bouquet:"💐",cherry_blossom:"🌸",white_flower:"💮",rosette:"🏵️",rose:"🌹",wilted_rose:"🥀",hibiscus:"🌺",sunflower:"🌻",blossom:"🌼",tulip:"🌷",seedling:"🌱",evergreen_tree:"🌲",deciduous_tree:"🌳",palm_tree:"🌴",cactus:"🌵",ear_of_rice:"🌾",herb:"🌿",shamrock:"☘️",four_leaf_clover:"🍀",maple_leaf:"🍁",fallen_leaf:"🍂",leaves:"🍃",grapes:"🍇",melon:"🍈",watermelon:"🍉",tangerine:"🍊",lemon:"🍋",banana:"🍌",pineapple:"🍍",mango:"🥭",apple:"🍎",green_apple:"🍏",pear:"🍐",peach:"🍑",cherries:"🍒",strawberry:"🍓",kiwi:"🥝",tomato:"🍅",coconut:"🥥",avocado:"🥑",eggplant:"🍆",potato:"🥔",carrot:"🥕",corn:"🌽",hot_pepper:"🌶️",cucumber:"🥒",leafy_green:"🥬",broccoli:"🥦",mushroom:"🍄",peanuts:"🥜",chestnut:"🌰",bread:"🍞",croissant:"🥐",french_bread:"🥖",pretzel:"🥨",bagel:"🥯",pancakes:"🥞",cheese:"🧀",meat_on_bone:"🍖",poultry_leg:"🍗",cut_of_meat:"🥩",bacon:"🥓",hamburger:"🍔",fries:"🍟",pizza:"🍕",hotdog:"🌭",sandwich:"🥪",taco:"🌮",burrito:"🌯",stuffed_flatbread:"🥙",egg:"🥚",cooking:"🍳",shallow_pan_of_food:"🥘",stew:"🍲",bowl_spoon:"🥣",salad:"🥗",popcorn:"🍿",salt:"🧂",canned_food:"🥫",bento:"🍱",rice_cracker:"🍘",rice_ball:"🍙",rice:"🍚",curry:"🍛",ramen:"🍜",spaghetti:"🍝",sweet_potato:"🍠",oden:"🍢",sushi:"🍣",fried_shrimp:"🍤",fish_cake:"🍥",moon_cake:"🥮",dango:"🍡",dumpling:"🥟",fortune_cookie:"🥠",takeout_box:"🥡",icecream:"🍦",shaved_ice:"🍧",ice_cream:"🍨",doughnut:"🍩",cookie:"🍪",birthday:"🎂",cake:"🍰",cupcake:"🧁",pie:"🥧",chocolate_bar:"🍫",candy:"🍬",lollipop:"🍭",custard:"🍮",honey_pot:"🍯",baby_bottle:"🍼",milk:"🥛",coffee:"☕️",tea:"🍵",sake:"🍶",champagne:"🍾",wine_glass:"🍷",cocktail:"🍸️",tropical_drink:"🍹",beer:"🍺",beers:"🍻",champagne_glass:"🥂",tumbler_glass:"🥃",cup_straw:"🥤",chopsticks:"🥢",fork_knife_plate:"🍽️",utensils:"🍴",spoon:"🥄",knife:"🔪",amphora:"🏺",earth_africa:"🌍️",earth_americas:"🌎️",earth_asia:"🌏️",globe:"🌐",map:"🗺️",japan:"🗾",compass:"🧭",snowy_mountain:"🏔️",mountain:"⛰️",volcano:"🌋",mount_fuji:"🗻",camping:"🏕️",beach:"🏖️",desert:"🏜️",island:"🏝️",park:"🏞️",stadium:"🏟️",classical_building:"🏛️",construction_site:"🏗️",brick:"🧱",homes:"🏘️",house_abandoned:"🏚️",house:"🏠️",house_garden:"🏡",office:"🏢",ja_post_office:"🏣",post_office:"🏤",hospital:"🏥",bank:"🏦",hotel:"🏨",love_hotel:"🏩",convenience_store:"🏪",school:"🏫",department_store:"🏬",factory:"🏭️",japanese_castle:"🏯",castle:"🏰",european_castle:"🏰",wedding:"💒",tokyo_tower:"🗼",statue_of_liberty:"🗽",church:"⛪️",mosque:"🕌",synagogue:"🕍",shinto_shrine:"⛩️",kaaba:"🕋",fountain:"⛲️",tent:"⛺️",foggy:"🌁",night_stars:"🌃",cityscape:"🏙️",sunrise_over_mountains:"🌄",sunrise:"🌅",dusk:"🌆",sunset:"🌇",bridge_at_night:"🌉",hotsprings:"♨️",milky_way:"🌌",carousel_horse:"🎠",ferris_wheel:"🎡",roller_coaster:"🎢",barber:"💈",circus_tent:"🎪",steam_locomotive:"🚂",railway_car:"🚃",bullettrain_side:"🚄",bullettrain:"🚅",train:"🚆",metro:"🚇️",light_rail:"🚈",station:"🚉",tram:"🚊",monorail:"🚝",mountain_railway:"🚞",tram_car:"🚋",bus:"🚌",oncoming_bus:"🚍️",trolleybus:"🚎",minibus:"🚐",ambulance:"🚑️",fire_engine:"🚒",police_car:"🚓",oncoming_police_car:"🚔️",taxi:"🚕",oncoming_taxi:"🚖",red_car:"🚗",oncoming_automobile:"🚘️",blue_car:"🚙",truck:"🚚",lorry:"🚛",tractor:"🚜",bike:"🚲️",scooter:"🛴",skateboard:"🛹",motor_scooter:"🛵",bus_stop:"🚏",motorway:"🛣️",railway_track:"🛤️",oil_drum:"🛢️",fuel_pump:"⛽️",rotating_light:"🚨",police_light:"🚨",traffic_light:"🚥",vertical_traffic_light:"🚦",stop_sign:"🛑",octagonal_sign:"🛑",construction:"🚧",anchor:"⚓️",sailboat:"⛵️",canoe:"🛶",speedboat:"🚤",cruise_ship:"🛳️",ferry:"⛴️",motorboat:"🛥️",ship:"🚢",airplane:"✈️",small_airplane:"🛩️",airplane_departure:"🛫",airplane_arriving:"🛬",seat:"💺",helicopter:"🚁",suspension_railway:"🚟",mountain_cableway:"🚠",aerial_tramway:"🚡",satellite:"🛰️",rocket:"🚀",flying_saucer:"🛸",bellhop:"🛎️",luggage:"🧳",hourglass:"⌛️",hourglass_flowing:"⏳️",watch:"⌚️",alarm_clock:"⏰",stopwatch:"⏱️",timer:"⏲️",clock:"🕰️",clock12:"🕛️",clock1230:"🕧️",clock1:"🕐️",clock130:"🕜️",clock2:"🕑️",clock230:"🕝️",clock3:"🕒️",clock330:"🕞️",clock4:"🕓️",clock430:"🕟️",clock5:"🕔️",clock530:"🕠️",clock6:"🕕️",clock630:"🕡️",clock7:"🕖️",clock730:"🕢️",clock8:"🕗️",clock830:"🕣️",clock9:"🕘️",clock930:"🕤️",clock10:"🕙️",clock1030:"🕥️",clock11:"🕚️",clock1130:"🕦️",new_moon:"🌑",waxing_crescent_moon:"🌒",first_quarter_moon:"🌓",waxing_gibbous_moon:"🌔",full_moon:"🌕️",waning_gibbous_moon:"🌖",last_quarter_moon:"🌗",waning_crescent_moon:"🌘",crescent_moon:"🌙",new_moon_face:"🌚",first_quarter_moon_face:"🌛",last_quarter_moon_face:"🌜️",thermometer:"🌡️",sun:"☀️",full_moon_face:"🌝",sun_face:"🌞",star:"⭐️",star2:"🌟",glowing_star:"🌟",star3:"🌠",shooting_star:"🌠",cloud:"☁️",partly_sunny:"⛅️",storm:"⛈️",overcast:"🌤️",cloudy:"🌥️",sunshower:"🌦️",rain:"🌧️",snow:"🌨️",lightning:"🌩️",tornado:"🌪️",fog:"🌫️",wind_face:"🌬️",cyclone:"🌀",rainbow:"🌈",closed_umbrella:"🌂",umbrella:"☂️",umbrella_rain:"☔️",beach_umbrella:"⛱️",zap:"⚡️",high_voltage:"⚡️",snowflake:"❄️",snowy_snowman:"☃️",snowman:"⛄️",comet:"☄️",fire:"🔥",droplet:"💧",ocean:"🌊",jack_o_lantern:"🎃",christmas_tree:"🎄",xmas_tree:"🎄",fireworks:"🎆",sparkler:"🎇",firecracker:"🧨",sparkles:"✨",balloon:"🎈",tada:"🎉",party:"🎉",confetti_ball:"🎊",tanabata_tree:"🎋",bamboo:"🎍",pine_decor:"🎍",dolls:"🎎",carp_streamer:"🎏",wind_chime:"🎐",moon_ceremony:"🎑",rice_scene:"🎑",red_envelope:"🧧",ribbon:"🎀",gift:"🎁",reminder_ribbon:"🎗️",tickets:"🎟️",admission:"🎟️",ticket:"🎫",military_medal:"🎖️",trophy:"🏆️",medal:"🏅",first_place:"🥇",second_place:"🥈",third_place:"🥉",soccer:"⚽️",baseball:"⚾️",softball:"🥎",basketball:"🏀",volleyball:"🏐",football:"🏈",rugby:"🏉",tennis:"🎾",flying_disc:"🥏",bowling:"🎳",cricket_game:"🏏",field_hockey:"🏑",hockey:"🏒",lacrosse:"🥍",ping_pong:"🏓",badminton:"🏸",boxing_glove:"🥊",gi:"🥋",martial_arts_uniform:"🥋",goal:"🥅",golf:"⛳️",ice_skate:"⛸️",fishing_pole:"🎣",running_shirt:"🎽",ski:"🎿",sled:"🛷",curling_stone:"🥌",dart:"🎯","8ball":"🎱",crystal_ball:"🔮",nazar_amulet:"🧿",video_game:"🎮️",joystick:"🕹️",slot_machine:"🎰",game_die:"🎲",jigsaw:"🧩",puzzle_piece:"🧩",teddy_bear:"🧸",spades:"♠️",hearts:"♥️",diamonds:"♦️",clubs:"♣️",chess_pawn:"♟️",black_joker:"🃏",mahjong:"🀄️",flower_cards:"🎴",performing_arts:"🎭️",frame_photo:"🖼️",art:"🎨",palette:"🎨",spool:"🧵",yarn:"🧶",mute:"🔇",no_sound:"🔇",speaker:"🔈️",low_sound:"🔈️",sound:"🔉",loud_sound:"🔊",loudspeaker:"📢",megaphone:"📣",postal_horn:"📯",bell:"🔔",no_bell:"🔕",musical_score:"🎼",musical_note:"🎵",musical_notes:"🎶",studio_microphone:"🎙️",level_slider:"🎚️",control_knobs:"🎛️",microphone:"🎤",headphones:"🎧️",radio:"📻️",saxophone:"🎷",guitar:"🎸",musical_keyboard:"🎹",trumpet:"🎺",violin:"🎻",drum:"🥁",mobile:"📱",iphone:"📱",android:"📱",mobile_calling:"📲",telephone:"☎️",telephone_receiver:"📞",pager:"📟️",fax:"📠",battery:"🔋",electric_plug:"🔌",laptop:"💻️",desktop:"🖥️",computer:"🖥️",printer:"🖨️",keyboard:"⌨️",computer_mouse:"🖱️",trackball:"🖲️",minidisc:"💽",floppy_disk:"💾",cd:"💿️",disk:"💿️",dvd:"📀",abacus:"🧮",movie_camera:"🎥",film_frames:"🎞️",projector:"📽️",clapper:"🎬️",tv:"📺️",camera:"📷️",camera_flash:"📸",video_camera:"📹️",vhs:"📼",mag:"🔍️",mag_right:"🔎",candle:"🕯️",bulb:"💡",light_bulb:"💡",flashlight:"🔦",red_lantern:"🏮",decorative_notebook:"📔",closed_book:"📕",book:"📖",green_book:"📗",blue_book:"📘",orange_book:"📙",books:"📚️",notebook:"📓",ledger:"📒",page_curl:"📃",scroll:"📜",page_facing_up:"📄",newspaper:"📰",rolled_newspaper:"🗞️",bookmark_tabs:"📑",bookmark:"🔖",label:"🏷️",moneybag:"💰️",yen:"💴",dollar:"💵",euro:"💶",pound:"💷",money_wings:"💸",credit_card:"💳️",receipt:"🧾",ja_chart:"💹",currency_exchange:"💱",dollar_sign:"💲",envelope:"✉️",email:"📧",incoming_envelope:"📨",envelope_arrow:"📩",outbox_tray:"📤️",inbox_tray:"📥️",package:"📦️",mailbox:"📫️",mailbox_closed:"📪️",mailbox_mail:"📬️",mailbox_no_mail:"📭️",postbox:"📮",ballot_box:"🗳️",pencil:"✏️",black_nib:"✒️",fountain_pen:"🖋️",pen:"🖊️",paintbrush:"🖌️",crayon:"🖍️",memo:"📝",briefcase:"💼",file_folder:"📁",open_file_folder:"📂",dividers:"🗂️",date:"📅",calendar:"📅",torn_calendar:"📆",notepad_spiral:"🗒️",calendar_spiral:"🗓️",card_index:"📇",chart_up:"📈",chart_down:"📉",bar_chart:"📊",clipboard:"📋️",pushpin:"📌",round_pushpin:"📍",paperclip:"📎",paperclips:"🖇️",straight_ruler:"📏",triangular_ruler:"📐",scissors:"✂️",card_box:"🗃️",file_cabinet:"🗄️",trashcan:"🗑️",wastebasket:"🗑️",lock:"🔒️",unlock:"🔓️",locked_pen:"🔏",locked_key:"🔐",key:"🔑",old_key:"🗝️",hammer:"🔨",pick:"⛏️",hammer_pick:"⚒️",tools:"🛠️",hammer_wrench:"🛠️",dagger:"🗡️",crossed_swords:"⚔️",gun:"🔫",pistol:"🔫",bow:"🏹",shield:"🛡️",wrench:"🔧",nut_and_bolt:"🔩",gear:"⚙️",clamp:"🗜️",compression:"🗜️",scales:"⚖️",link:"🔗",chains:"⛓️",toolbox:"🧰",magnet:"🧲",alembic:"⚗️",test_tube:"🧪",petri_dish:"🧫",dna:"🧬",double_helix:"🧬",microscope:"🔬",telescope:"🔭",satellite_antenna:"📡",syringe:"💉",pill:"💊",door:"🚪",bed:"🛏️",couch:"🛋️",toilet:"🚽",shower:"🚿",bathtub:"🛁",lotion:"🧴",safety_pin:"🧷",broom:"🧹",basket:"🧺",toilet_paper:"🧻",soap:"🧼",sponge:"🧽",fire_extinguisher:"🧯",shopping_cart:"🛒",cigarette:"🚬",smoking:"🚬",coffin:"⚰️",urn:"⚱️",moai:"🗿",atm:"🏧",litter_bin:"🚮",potable_water:"🚰",wheelchair:"♿️",mens:"🚹️",womens:"🚺️",restroom:"🚻",bathroom:"🚻",baby_symbol:"🚼️",wc:"🚾",passport_control:"🛂",customs:"🛃",baggage_claim:"🛄",left_luggage:"🛅",warning:"⚠️",children_crossing:"🚸",no_entry:"⛔️",no_entry_sign:"🚫",no_bicycles:"🚳",no_smoking:"🚭️",do_not_litter:"🚯",non_potable_water:"🚱",no_pedestrians:"🚷",no_mobile_phones:"📵",underage:"🔞",radioactive:"☢️",biohazard:"☣️",arrow_up:"⬆️",arrow_upper_right:"↗️",arrow_right:"➡️",arrow_lower_right:"↘️",arrow_down:"⬇️",arrow_lower_left:"↙️",arrow_left:"⬅️",arrow_upper_left:"↖️",arrow_up_down:"↕️",arrow_left_right:"↔️",arrow_left_hook:"↩️",arrow_right_hook:"↪️",arrow_heading_up:"⤴️",arrow_heading_down:"⤵️",clockwise:"🔃",counter_clockwise:"🔄",back:"🔙",end:"🔚",on:"🔛",soon:"🔜",top:"🔝",place_of_worship:"🛐",atom:"⚛️",om_symbol:"🕉️",star_of_david:"✡️",wheel_of_dharma:"☸️",yin_yang:"☯️",cross:"✝️",orthodox_cross:"☦️",star_and_crescent:"☪️",peace:"☮️",menorah:"🕎",six_pointed_star:"🔯",aries:"♈️",taurus:"♉️",gemini:"♊️",cancer:"♋️",leo:"♌️",virgo:"♍️",libra:"♎️",scorpius:"♏️",sagittarius:"♐️",capricorn:"♑️",aquarius:"♒️",pisces:"♓️",ophiuchus:"⛎",shuffle:"🔀",repeat:"🔁",repeat_single:"🔂",play:"▶️",fast_forward:"⏩️",next_track:"⏭️",play_pause:"⏯️",reverse:"◀️",rewind:"⏪️",previous_track:"⏮️",up_button:"🔼",fast_up_button:"⏫",down_button:"🔽",fast_down_button:"⏬",pause:"⏸️",stop:"⏹️",record:"⏺️",eject:"⏏️",cinema:"🎦",dim:"🔅",low_brightness:"🔅",bright:"🔆",high_brightness:"🔆",signal_strength:"📶",antenna_bars:"📶",vibration_mode:"📳",mobile_phone_off:"📴",female:"♀️",female_sign:"♀️",male:"♂️",male_sign:"♂️",medical:"⚕️",infinity:"♾️",recycle:"♻️","fleur-de-lis":"⚜️",trident:"🔱",name_badge:"📛",ja_beginner:"🔰",o:"⭕️",white_check_mark:"✅",checked_ballot:"☑️",check_mark:"✔️",multiplication:"✖️",x:"❌",cross_mark:"❌",cross_mark_button:"❎",plus:"➕",minus:"➖",division:"➗",curly_loop:"➰",double_curly_loop:"➿",part_alternation_mark:"〽️",eight_spoked_asterisk:"✳️",eight_pointed_star:"✴️",sparkle:"❇️",bangbang:"‼️",double_exclamation:"‼️",interrobang:"⁉️",exclamation_question:"⁉️",question:"❓️",white_question:"❔",white_exclamation:"❕",exclamation:"❗️",wavy_dash:"〰️",copyright:"©️",registered:"®️",tm:"™️",hash:"#️⃣",asterisk:"*️⃣",zero:"0️⃣",one:"1️⃣",two:"2️⃣",three:"3️⃣",four:"4️⃣",five:"5️⃣",six:"6️⃣",seven:"7️⃣",eight:"8️⃣",nine:"9️⃣",ten:"🔟",upper_abcd:"🔠",abcd:"🔡",symbols:"🔣",abc:"🔤",a_blood:"🅰️",ab_blood:"🆎",b_blood:"🅱️",cl:"🆑",cool:"🆒",free:"🆓",info:"ℹ️",id:"🆔",m:"Ⓜ️",new:"🆕",ng:"🆖",o_blood:"🅾️",ok:"🆗",p:"🅿️",sos:"🆘",up:"🆙",vs:"🆚",ja_here:"🈁",koko:"🈁",ja_service_charge:"🈂️",ja_monthly_amount:"🈷️",ja_not_free_of_carge:"🈶",ja_reserved:"🈯️",ja_bargain:"🉐",ja_discount:"🈹",ja_free_of_charge:"🈚️",ja_prohibited:"🈲",ja_acceptable:"🉑",ja_application:"🈸",ja_passing_grade:"🈴",ja_vacancy:"🈳",ja_congratulations:"㊗️",ja_secret:"㊙️",ja_open_for_business:"🈺",ja_no_vacancy:"🈵",small_black_square:"▪️",small_white_square:"▫️",medium_white_square:"◻️",medium_black_square:"◼️",medium_small_white_square:"◽️",medium_small_black_square:"◾️",large_black_square:"⬛️",large_white_square:"⬜️",large_orange_diamond:"🔶",large_blue_diamond:"🔷",small_orange_diamond:"🔸",small_blue_diamond:"🔹",up_red_triangle:"🔺",down_red_triangle:"🔻",diamond_dot:"💠",radio_button:"🔘",black_square_button:"🔲",white_square_button:"🔳",white_circle:"⚪️",black_circle:"⚫️",red_circle:"🔴",blue_circle:"🔵",checkered_flag:"🏁",triangle_flag:"🚩",crossed_flags:"🎌",black_flag:"🏴",white_flag:"🏳️",rainbow_flag:"🏳️‍🌈",pirate_flag:"🏴‍☠️",jolly_roger:"🏴‍☠️",flag_ac:"🇦🇨",flag_ad:"🇦🇩",flag_ae:"🇦🇪",flag_af:"🇦🇫",flag_ag:"🇦🇬",flag_ai:"🇦🇮",flag_al:"🇦🇱",flag_am:"🇦🇲",flag_ao:"🇦🇴",flag_aq:"🇦🇶",flag_ar:"🇦🇷",flag_as:"🇦🇸",flag_at:"🇦🇹",flag_au:"🇦🇺",flag_aw:"🇦🇼",flag_ax:"🇦🇽",flag_az:"🇦🇿",flag_ba:"🇧🇦",flag_bb:"🇧🇧",flag_bd:"🇧🇩",flag_be:"🇧🇪",flag_bf:"🇧🇫",flag_bg:"🇧🇬",flag_bh:"🇧🇭",flag_bi:"🇧🇮",flag_bj:"🇧🇯",flag_bl:"🇧🇱",flag_bm:"🇧🇲",flag_bn:"🇧🇳",flag_bo:"🇧🇴",flag_bq:"🇧🇶",flag_br:"🇧🇷",flag_bs:"🇧🇸",flag_bt:"🇧🇹",flag_bv:"🇧🇻",flag_bw:"🇧🇼",flag_by:"🇧🇾",flag_bz:"🇧🇿",flag_ca:"🇨🇦",flag_cc:"🇨🇨",flag_cd:"🇨🇩",flag_cf:"🇨🇫",flag_cg:"🇨🇬",flag_ch:"🇨🇭",flag_ci:"🇨🇮",flag_ck:"🇨🇰",flag_cl:"🇨🇱",flag_cm:"🇨🇲",flag_cn:"🇨🇳",flag_co:"🇨🇴",flag_cp:"🇨🇵",flag_cr:"🇨🇷",flag_cu:"🇨🇺",flag_cv:"🇨🇻",flag_cw:"🇨🇼",flag_cx:"🇨🇽",flag_cy:"🇨🇾",flag_cz:"🇨🇿",flag_de:"🇩🇪",flag_dg:"🇩🇬",flag_dj:"🇩🇯",flag_dk:"🇩🇰",flag_dm:"🇩🇲",flag_do:"🇩🇴",flag_dz:"🇩🇿",flag_ea:"🇪🇦",flag_ec:"🇪🇨",flag_ee:"🇪🇪",flag_eg:"🇪🇬",flag_eh:"🇪🇭",flag_er:"🇪🇷",flag_es:"🇪🇸",flag_et:"🇪🇹",flag_eu:"🇪🇺",flag_fi:"🇫🇮",flag_fj:"🇫🇯",flag_fk:"🇫🇰",flag_fm:"🇫🇲",flag_fo:"🇫🇴",flag_fr:"🇫🇷",flag_ga:"🇬🇦",flag_gb:"🇬🇧",flag_gd:"🇬🇩",flag_ge:"🇬🇪",flag_gf:"🇬🇫",flag_gg:"🇬🇬",flag_gh:"🇬🇭",flag_gi:"🇬🇮",flag_gl:"🇬🇱",flag_gm:"🇬🇲",flag_gn:"🇬🇳",flag_gp:"🇬🇵",flag_gq:"🇬🇶",flag_gr:"🇬🇷",flag_gs:"🇬🇸",flag_gt:"🇬🇹",flag_gu:"🇬🇺",flag_gw:"🇬🇼",flag_gy:"🇬🇾",flag_hk:"🇭🇰",flag_hm:"🇭🇲",flag_hn:"🇭🇳",flag_hr:"🇭🇷",flag_ht:"🇭🇹",flag_hu:"🇭🇺",flag_ic:"🇮🇨",flag_id:"🇮🇩",flag_ie:"🇮🇪",flag_il:"🇮🇱",flag_im:"🇮🇲",flag_in:"🇮🇳",flag_io:"🇮🇴",flag_iq:"🇮🇶",flag_ir:"🇮🇷",flag_is:"🇮🇸",flag_it:"🇮🇹",flag_je:"🇯🇪",flag_jm:"🇯🇲",flag_jo:"🇯🇴",flag_jp:"🇯🇵",flag_ke:"🇰🇪",flag_kg:"🇰🇬",flag_kh:"🇰🇭",flag_ki:"🇰🇮",flag_km:"🇰🇲",flag_kn:"🇰🇳",flag_kp:"🇰🇵",flag_kr:"🇰🇷",flag_kw:"🇰🇼",flag_ky:"🇰🇾",flag_kz:"🇰🇿",flag_la:"🇱🇦",flag_lb:"🇱🇧",flag_lc:"🇱🇨",flag_li:"🇱🇮",flag_lk:"🇱🇰",flag_lr:"🇱🇷",flag_ls:"🇱🇸",flag_lt:"🇱🇹",flag_lu:"🇱🇺",flag_lv:"🇱🇻",flag_ly:"🇱🇾",flag_ma:"🇲🇦",flag_mc:"🇲🇨",flag_md:"🇲🇩",flag_me:"🇲🇪",flag_mf:"🇲🇫",flag_mg:"🇲🇬",flag_mh:"🇲🇭",flag_mk:"🇲🇰",flag_ml:"🇲🇱",flag_mm:"🇲🇲",flag_mn:"🇲🇳",flag_mo:"🇲🇴",flag_mp:"🇲🇵",flag_mq:"🇲🇶",flag_mr:"🇲🇷",flag_ms:"🇲🇸",flag_mt:"🇲🇹",flag_mu:"🇲🇺",flag_mv:"🇲🇻",flag_mw:"🇲🇼",flag_mx:"🇲🇽",flag_my:"🇲🇾",flag_mz:"🇲🇿",flag_na:"🇳🇦",flag_nc:"🇳🇨",flag_ne:"🇳🇪",flag_nf:"🇳🇫",flag_ng:"🇳🇬",flag_ni:"🇳🇮",flag_nl:"🇳🇱",flag_no:"🇳🇴",flag_np:"🇳🇵",flag_nr:"🇳🇷",flag_nu:"🇳🇺",flag_nz:"🇳🇿",flag_om:"🇴🇲",flag_pa:"🇵🇦",flag_pe:"🇵🇪",flag_pf:"🇵🇫",flag_pg:"🇵🇬",flag_ph:"🇵🇭",flag_pk:"🇵🇰",flag_pl:"🇵🇱",flag_pm:"🇵🇲",flag_pn:"🇵🇳",flag_pr:"🇵🇷",flag_ps:"🇵🇸",flag_pt:"🇵🇹",flag_pw:"🇵🇼",flag_py:"🇵🇾",flag_qa:"🇶🇦",flag_re:"🇷🇪",flag_ro:"🇷🇴",flag_rs:"🇷🇸",flag_ru:"🇷🇺",flag_rw:"🇷🇼",flag_sa:"🇸🇦",flag_sb:"🇸🇧",flag_sc:"🇸🇨",flag_sd:"🇸🇩",flag_se:"🇸🇪",flag_sg:"🇸🇬",flag_sh:"🇸🇭",flag_si:"🇸🇮",flag_sj:"🇸🇯",flag_sk:"🇸🇰",flag_sl:"🇸🇱",flag_sm:"🇸🇲",flag_sn:"🇸🇳",flag_so:"🇸🇴",flag_sr:"🇸🇷",flag_ss:"🇸🇸",flag_st:"🇸🇹",flag_sv:"🇸🇻",flag_sx:"🇸🇽",flag_sy:"🇸🇾",flag_sz:"🇸🇿",flag_ta:"🇹🇦",flag_tc:"🇹🇨",flag_td:"🇹🇩",flag_tf:"🇹🇫",flag_tg:"🇹🇬",flag_th:"🇹🇭",flag_tj:"🇹🇯",flag_tk:"🇹🇰",flag_tl:"🇹🇱",flag_tm:"🇹🇲",flag_tn:"🇹🇳",flag_to:"🇹🇴",flag_tr:"🇹🇷",flag_tt:"🇹🇹",flag_tv:"🇹🇻",flag_tw:"🇹🇼",flag_tz:"🇹🇿",flag_ua:"🇺🇦",flag_ug:"🇺🇬",flag_um:"🇺🇲",flag_un:"🇺🇳",flag_us:"🇺🇸",usa:"🇺🇸",flag_uy:"🇺🇾",flag_uz:"🇺🇿",flag_va:"🇻🇦",flag_vc:"🇻🇨",flag_ve:"🇻🇪",flag_vg:"🇻🇬",flag_vi:"🇻🇮",flag_vn:"🇻🇳",flag_vu:"🇻🇺",flag_wf:"🇼🇫",flag_ws:"🇼🇸",flag_xk:"🇽🇰",flag_ye:"🇾🇪",flag_yt:"🇾🇹",flag_za:"🇿🇦",flag_zm:"🇿🇲",flag_zw:"🇿🇼",flag_gbeng:"🏴󠁧󠁢󠁥󠁮󠁧󠁿",england:"🏴󠁧󠁢󠁥󠁮󠁧󠁿",flag_gbsct:"🏴󠁧󠁢󠁳󠁣󠁴󠁿",scotland:"🏴󠁧󠁢󠁳󠁣󠁴󠁿",flag_gbwls:"🏴󠁧󠁢󠁷󠁬󠁳󠁿",wales:"🏴󠁧󠁢󠁷󠁬󠁳󠁿"}},function(e,t,i){"use strict";i.r(t);var s=i(0);class o{}const a=new class extends o{equals(e,t){return e===t}},r=new class extends o{equals(e,t,i={useId:!1,usePosition:!1}){return e===t||void 0!==e&&void 0!==t&&(!i.usePosition||e.viewColumn===t.viewColumn)&&(!i.useId||e.document&&t.document?a.equals(e.document,t.document):e.id===t.id)}},n=new class extends o{equals(e,t){return e===t||void 0!==e&&void 0!==t&&e.scheme===t.scheme&&e.fsPath===t.fsPath}};var l,c,h,d,m,u,g,p,f,v,w,b,_,C,y=i(1);!function(e){e.File="file",e.Window="window"}(l||(l={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleFileBlame="gitlens.toggleFileBlame"}(c||(c={})),function(e){e.Document="document",e.Containers="containers",e.Blocks="blocks"}(h||(h={})),function(e){e.Bitbucket="Bitbucket",e.BitbucketServer="BitbucketServer",e.Custom="Custom",e.GitHub="GitHub",e.GitLab="GitLab"}(d||(d={})),function(e){e.Absolute="absolute",e.Relative="relative"}(m||(m={})),function(e){e.List="list",e.Tree="tree"}(u||(u={})),function(e){e.Auto="auto",e.List="list",e.Tree="tree"}(g||(g={})),function(e){e.Blame="blame",e.Heatmap="heatmap",e.RecentChanges="recentChanges"}(p||(p={})),function(e){e.Auto="auto",e.History="history",e.Repository="repository"}(f||(f={})),function(e){e.Faces="wavatar",e.Geometric="identicon",e.Monster="monsterid",e.MysteryMan="mm",e.Retro="retro",e.Robot="robohash"}(v||(v={})),function(e){e.Gutter="gutter",e.Line="line",e.Overview="overview"}(w||(w={})),function(e){e.Alternate="alternate",e.Chorded="chorded",e.None="none"}(b||(b={})),function(e){e.Silent="silent",e.Errors="errors",e.Verbose="verbose",e.Debug="debug"}(_||(_={})),function(e){e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffWithWorking="gitlens.diffWithWorking",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame"}(C||(C={}));const x="gitlens",$="GitLens",S=`eamodio.${x}`,k="GitLens";var D,F,P,T,R;function E(e,t){return s.commands.executeCommand(D.SetContext,e,t)}function B(e){const t=s.window.activeTextEditor;return null!=t&&t.document===e}function N(e){const t=e.document.uri.scheme;return t!==P.Output&&t!==P.DebugConsole}!function(e){e.CloseActiveEditor="workbench.action.closeActiveEditor",e.CloseAllEditors="workbench.action.closeAllEditors",e.CursorMove="cursorMove",e.Diff="vscode.diff",e.EditorScroll="editorScroll",e.ExecuteDocumentSymbolProvider="vscode.executeDocumentSymbolProvider",e.ExecuteCodeLensProvider="vscode.executeCodeLensProvider",e.Open="vscode.open",e.NextEditor="workbench.action.nextEditor",e.PreviewHtml="vscode.previewHtml",e.RevealLine="revealLine",e.SetContext="setContext",e.ShowReferences="editor.action.showReferences"}(D||(D={})),function(e){e.ActiveFileStatus="gitlens:activeFileStatus",e.AnnotationStatus="gitlens:annotationStatus",e.CanToggleCodeLens="gitlens:canToggleCodeLens",e.Enabled="gitlens:enabled",e.ExplorersCanCompare="gitlens:explorers:canCompare",e.GitExplorer="gitlens:gitExplorer",e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.HasRemotes="gitlens:hasRemotes",e.HistoryExplorer="gitlens:historyExplorer",e.Key="gitlens:key",e.KeyMap="gitlens:keymap",e.ResultsExplorer="gitlens:resultsExplorer",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(F||(F={})),function(e){e.DebugConsole="debug",e.File="file",e.Git="git",e.GitLensGit="gitlens-git",e.Output="output"}(P||(P={})),function(e){e.AngleBracketLeftHeavy="❰",e.AngleBracketRightHeavy="❱",e.ArrowBack="↩",e.ArrowDown="↓",e.ArrowDropRight="⤷",e.ArrowHeadRight="➤",e.ArrowLeft="←",e.ArrowLeftDouble="⇐",e.ArrowLeftRight="↔",e.ArrowLeftRightDouble="⇔",e.ArrowLeftRightDoubleStrike="⇎",e.ArrowLeftRightLong="⟷",e.ArrowRight="→",e.ArrowRightDouble="⇒",e.ArrowRightHollow="⇨",e.ArrowUp="↑",e.ArrowUpRight="↗",e.ArrowsHalfLeftRight="⇋",e.ArrowsHalfRightLeft="⇌",e.ArrowsLeftRight="⇆",e.ArrowsRightLeft="⇄",e.Asterisk="∗",e.Check="✓",e.Dash="—",e.Dot="•",e.Ellipsis="…",e.MiddleEllipsis="⋯",e.MuchGreaterThan="≪",e.MuchLessThan="⋘",e.Pencil="✎",e.Space=" ",e.SpaceThin=" ",e.SquareWithBottomShadow="❏",e.SquareWithTopShadow="❐",e.ZeroWidthSpace="​"}(T||(T={})),function(e){e.GitLensVersion="gitlensVersion"}(R||(R={}));const A=[".png",".gif",".jpg",".jpeg",".webp",".tif",".tiff",".bmp"];var O;!function(e){e.GitExplorerAutoRefresh="gitlens:gitExplorer:autoRefresh",e.GitExplorerView="gitlens:gitExplorer:view",e.ResultsExplorerKeepResults="gitlens:resultsExplorer:keepResults"}(O||(O={}));var L=i(3),U=i(2),I=i(4);const M=`[${$}]`,W=/^--(debug|inspect)\b(-brk\b|(?!-))=?/;class H{static configure(e){e.subscriptions.push(ti.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ti.initializingChangeEvent)}static onConfigurationChanged(e){const t=ti.initializing(e),i=ti.name("outputLevel").value;(t||ti.changed(e,i))&&(this.level=ti.get(i),this.level===_.Silent?void 0!==this.output&&(this.output.dispose(),this.output=void 0):this.output=this.output||s.window.createOutputChannel($))}static log(e,...t){this.level!==_.Verbose&&this.level!==_.Debug||(H.isDebugging&&console.log(this.timestamp,M,e,...t),void 0!==this.output&&this.output.appendLine((H.isDebugging?[this.timestamp,e,...t]:[e,...t]).join(" ")))}static error(e,t,...i){this.level!==_.Silent&&(H.isDebugging&&console.error(this.timestamp,M,t,...i,e),void 0!==this.output&&this.output.appendLine((H.isDebugging?[this.timestamp,t,...i,e]:[t,...i,e]).join(" ")))}static warn(e,...t){this.level!==_.Silent&&(H.isDebugging&&console.warn(this.timestamp,M,e,...t),void 0!==this.output&&this.output.appendLine((H.isDebugging?[this.timestamp,e,...t]:[e,...t]).join(" ")))}static get timestamp(){const e=new Date;return`[${e.toISOString().replace(/T/," ").replace(/\..+/,"")}:${("00"+e.getUTCMilliseconds()).slice(-3)}]`}static logGitCommand(e,t,i){this.level===_.Debug&&(void 0===this.gitOutput&&(this.gitOutput=s.window.createOutputChannel(`${$} (Git)`)),this.gitOutput.appendLine(`${this.timestamp} ${e} (${t})${void 0===i?"":`\n\n${i.toString()}`}`))}static get isDebugging(){if(void 0===this._isDebugging)try{const e=process.execArgv;this._isDebugging=!!e&&e.some(e=>W.test(e))}catch(e){}return this._isDebugging}}var j,G;H.level=_.Silent,function(e){e.entries=function*(e){for(const t in e)yield[t,e[t]]},e.flatten=function(e,t="",i=!1){const s=Object.create(null);return function e(t,i,s,o=!1){if(Object(s)!==s)t[i]=o?null==s?null:"string"==typeof s?s:JSON.stringify(s):s;else if(Array.isArray(s)){const a=s.length;for(let r=0;r<a;r++)e(t,`${i}[${r}]`,s[r],o);0===a&&(t[i]=null)}else{let a=!0;for(const r in s)a=!1,e(t,i?`${i}.${r}`:r,s[r],o);a&&i&&(t[i]=null)}}(s,t,e,i),s},e.paths=function e(t,i){const s=[];for(const o in t){const a=t[o];"object"==typeof a?s.push(...e(a,void 0===i?o:`${i}.${o}`)):s.push(void 0===i?o:`${i}.${o}`)}return s},e.values=function*(e){for(const t in e)yield e[t]}}(j||(j={})),function(e){function t(e,i,s=!0){if(void 0===e.children)return e;const o=[...j.values(e.children)];for(const e of o)t(e,i,!1);if(!s&&1===o.length){const t=o[0];void 0===t.value&&(e.name=i(e.name,t.name),e.relativePath=t.relativePath,e.children=t.children)}return e}e.countUniques=function(e,t){const i=Object.create(null);for(const s of e){const e=t(s);i[e]=(i[e]||0)+1}return i},e.filterMap=function(e,t){return e.reduce((e,i)=>{const s=t(i);return null!=s&&e.push(s),e},[])},e.filterMapAsync=async function(e,t){return e.reduce(async(e,i)=>{const s=await t(i);return null!=s&&e.push(s),e},[])},e.groupBy=function(e,t){return e.reduce((e,i)=>{const s=t(i);return e[s]=e[s]||[],e[s].push(i),e},Object.create(null))},e.groupByMap=function(e,t){return e.reduce((e,i)=>{const s=t(i),o=e.get(s)||[];return e.set(s,o),o.push(i),e},new Map)},e.groupByFilterMap=function(e,t,i){return e.reduce((e,s)=>{const o=i(s);if(null!=o){const i=t(s),a=e.get(i)||[];e.set(i,a),a.push(o)}return e},new Map)},e.makeHierarchical=function(e,i,s,o=!1){const a={name:"",relativePath:"",children:Object.create(null),descendants:[]},r=e.reduce((e,t)=>{let o=e,a="";for(const e of i(t)){a=s(a,e),void 0===o.children&&(o.children=Object.create(null));let i=o.children[e];void 0===i&&(o.children[e]=i={name:e,relativePath:a,children:void 0,descendants:void 0}),void 0===o.descendants&&(o.descendants=[]),o.descendants.push(t),o=i}return o.value=t,e},a);return o?t(r,s,!0):r},e.compactHierarchy=t,e.uniqueBy=function(e,t,i){const s=Object.create(null);return e.filter(e=>{const o=t(e);return!s[o]&&(s[o]=t,!i||i(e))})}}(G||(G={}));var V=i(5);const z=6e4,Q=864e5;const q=i(7);q.distanceInWords=function(){const e={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"a few seconds",other:"less than {{count}} minutes"},xMinutes:{one:"a minute",other:"{{count}} minutes"},aboutXHours:{one:"an hour",other:"{{count}} hours"},xHours:{one:"an hour",other:"{{count}} hours"},xDays:{one:"a day",other:"{{count}} days"},aboutXMonths:{one:"a month",other:"{{count}} months"},xMonths:{one:"a month",other:"{{count}} months"},aboutXYears:{one:"a year",other:"{{count}} years"},xYears:{one:"a year",other:"{{count}} years"},overXYears:{one:"a year",other:"{{count}} years"},almostXYears:{one:"a year",other:"{{count}} years"}};return{localize:function(t,i,s){s=s||{},12===i&&"xMonths"===t&&(t="aboutXYears",i=1);const o=e[t];let a;return a="string"==typeof o?o:1===i?o.one:o.other.replace("{{count}}",i.toString()),s.addSuffix?s.comparison>0?"in "+a:a+" ago":a}}}();const K={addSuffix:!0,locale:q};var Y;!function(e){function t(e){const t=new Date("number"==typeof e?e:e.getTime());return t.setHours(0,0,0,0),t}e.dateDaysFromNow=function(e,i=Date.now()){const s=t(i),o=t(e),a=s.getTime()-s.getTimezoneOffset()*z,r=o.getTime()-o.getTimezoneOffset()*z;return Math.round((a-r)/Q)},e.startOfDay=t,e.toFormatter=function(e){return{fromNow:()=>Object(V.distanceInWordsToNow)(e,K),format:t=>Object(V.format)(e,t)}}}(Y||(Y={}));const X=i(9),Z=i(10);var J,ee;!function(e){async function t(e){await new Promise(t=>setTimeout(t,e))}e.debounce=function(e,t,i){const s=Object.assign({track:!1},i||{}),{track:o}=s,a=L.__rest(s,["track"]);if(!0!==o)return X(e,t,a);let r=!1;const n=X(function(){return r=!1,e.apply(this,arguments)},t,i),l=function(){return r=!0,n.apply(this,arguments)};return l.pending=function(){return r},l.cancel=function(){return n.cancel.apply(n,arguments)},l.flush=function(...e){return n.flush.apply(n,arguments)},l},e.once=function(e){return Z(e)},e.propOf=function(e,t){const i=(e,t)=>{const s=void 0===i.value?t:`${i.value}.${t}`;return i.value=s,Object.assign(s=>i(e[t],s),{value:s})};return i(e,t)},e.seeded=function(e,t){let i=t;return(...t)=>{if(void 0!==i){const e=Promise.resolve(i);return i=void 0,e}return e(...t)}},e.wait=t,e.waitUntil=async function(e,i){const s=Math.round(i/100);let o=0;for(;;){if(e())return!0;if(o>s)return!1;await t(100),o++}}}(J||(J={})),function(e){function t(e,t){for(const i of e)if(t(i))return!0;return!1}e.count=function(e,t){let i,s=0;for(;!(i=e.next()).done;)(void 0===t||t(i.value))&&s++;return s},e.every=function(e,t){for(const i of e)if(!t(i))return!1;return!0},e.filter=function*(e,t){if(void 0===t)for(const t of e)null!=t&&(yield t);else for(const i of e)t(i)&&(yield i)},e.filterMap=function*(e,t){for(const i of e){const e=t(i);null!=e&&(yield e)}},e.forEach=function(e,t){let i=0;for(const s of e)t(s,i),i++},e.find=function(e,t){for(const i of e)if(t(i))return i;return null},e.first=function(e){return e[Symbol.iterator]().next().value},e.flatMap=function*(e,t){for(const i of e)yield*t(i)},e.has=function(e,i){return t(e,e=>e===i)},e.isIterable=function(e){return"function"==typeof e[Symbol.iterator]},e.join=function(e,t){let i="";const s=e[Symbol.iterator]();let o=s.next();if(o.done)return i;for(;;){const e=o.value.toString();if((o=s.next()).done){i+=e;break}i+=`${e}${t}`}return i},e.last=function(e){let t=null;for(t of e);return t},e.map=function*(e,t){for(const i of e)yield t(i)},e.next=function(e){return e.next().value},e.skip=function*(e,t){let i=0;for(const s of e)i>=t&&(yield s),i++},e.some=t,e.take=function*(e,t){if(t>0){let i=0;for(const s of e)if(yield s,++i>=t)break}},e.union=function*(...e){for(const t of e)for(const e of t)yield e}}(ee||(ee={}));class te{constructor(){this._value="",this._pos=0}reset(e){return this._value=e,this._pos=0,this}next(){return this._pos+=1,this}hasNext(){return this._pos<this._value.length-1}cmp(e){return e.charCodeAt(0)-this._value.charCodeAt(this._pos)}value(){return this._value[this._pos]}}class ie{reset(e){return this._value=e.replace(/\\$|\/$/,""),this._from=0,this._to=0,this.next()}hasNext(){return this._to<this._value.length}next(){this._from=this._to;let e=!0;for(;this._to<this._value.length;this._to++){const t=this._value.charCodeAt(this._to);if(47===t||92===t){if(!e)break;this._from++}else e=!1}return this}cmp(e){let t=0;const i=e.length;let s=this._from;for(;t<i&&s<this._to;){const i=e.charCodeAt(t)-this._value.charCodeAt(s);if(0!==i)return i;t+=1,s+=1}return i===this._to-this._from?0:t<i?-1:1}value(){return this._value.substring(this._from,this._to)}}class se{isEmpty(){return!(this.left||this.mid||this.right||this.value)}}class oe{constructor(e){this._iter=e}static forPaths(){return new oe(new ie)}static forStrings(){return new oe(new te)}clear(){this._root=void 0}set(e,t){const i=this._iter.reset(e);let s;for(this._root||(this._root=new se,this._root.segment=i.value()),s=this._root;;){const e=i.cmp(s.segment);if(e>0)s.left||(s.left=new se,s.left.segment=i.value()),s=s.left;else if(e<0)s.right||(s.right=new se,s.right.segment=i.value()),s=s.right;else{if(!i.hasNext())break;i.next(),s.mid||(s.mid=new se,s.mid.segment=i.value()),s=s.mid}}const o=s.value;return s.value=t,s.key=e,o}get(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.segment);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext())break;t.next(),i=i.mid}}return i?i.value:void 0}delete(e){const t=this._iter.reset(e),i=[];let s=this._root;for(;s;){const e=t.cmp(s.segment);if(e>0)i.push([1,s]),s=s.left;else if(e<0)i.push([-1,s]),s=s.right;else{if(!t.hasNext()){for(s.value=void 0;i.length>0&&s.isEmpty();){const[e,t]=i.pop();switch(e){case 1:t.left=void 0;break;case 0:t.mid=void 0;break;case-1:t.right=void 0}s=t}break}t.next(),i.push([0,s]),s=s.mid}}}findSubstr(e){const t=this._iter.reset(e);let i,s=this._root;for(;s;){const e=t.cmp(s.segment);if(e>0)s=s.left;else if(e<0)s=s.right;else{if(!t.hasNext())break;t.next(),i=s.value||i,s=s.mid}}return s&&s.value||i}findSuperstr(e){const t=this._iter.reset(e);let i=this._root;for(;i;){const e=t.cmp(i.segment);if(e>0)i=i.left;else if(e<0)i=i.right;else{if(!t.hasNext()){if(!i.mid)return;const e=new oe(this._iter);return e._root=i.mid,e}t.next(),i=i.mid}}}forEach(e){this._forEach(this._root,e)}_forEach(e,t){void 0!==e&&(this._forEach(e.left,t),e.value&&t(e.value,e.key),this._forEach(e.mid,t),this._forEach(e.right,t))}any(){return void 0!==this._root&&!this._root.isEmpty()}count(e){return void 0===this._root||this._root.isEmpty()?0:ee.count(this.entries(),void 0===e?void 0:([t])=>e(t))}entries(){return this._iterator(this._root)}values(){return ee.map(this.entries(),([e])=>e)}highlander(){if(void 0===this._root||this._root.isEmpty())return;const e=this.entries();let t,i,s=0;for(;!(t=e.next()).done;)if(i=t.value,++s>1)return;return i}some(e){return void 0!==this._root&&!this._root.isEmpty()&&ee.some(this.entries(),([t])=>e(t))}*_iterator(e){void 0!==e&&(yield*this._iterator(e.left),e.value&&(yield[e.value,e.key]),yield*this._iterator(e.mid),yield*this._iterator(e.right))}}var ae,re,ne=i(6);!function(e){const t=/\\/g,i=/\$\{([^|]*?)(?:\|(\d+)(\-|\?)?)?\}/g,s=/\$\{(\w*?)(?:\W|\d)*?\}/g;function o(e,t,i=" ",s){const o=t-(s||h(e));return o<=0?e:i.repeat(o)+e}function a(e,t,i=" ",s){const o=t-(s||h(e));return o<=0?e:e+i.repeat(o)}e.getTokensFromTemplate=function(e){const t=[];let s=i.exec(e);for(;null!=s;){const o=s[2],a=s[3];t.push({key:s[1],options:{truncateTo:null==o?void 0:parseInt(o,10),padDirection:"-"===a?"left":"right",collapseWhitespace:"?"===a}}),s=i.exec(e)}return t},e.interpolate=function(e,t){return e?void 0===t?e.replace(s,""):(e=e.replace(s,"$${this.$1}"),new Function(`return \`${e}\`;`).call(t)):e},e.lines=function*(e){let t=0;for(;t<e.length;){let i=e.indexOf("\n",t);-1===i&&(i=e.length),yield e.substring(t,i),t=i+1}},e.md5=function(e,t="base64"){return Object(ne.createHash)("md5").update(e).digest(t)},e.normalizePath=function(e){return e&&e.replace(t,"/")},e.pad=function(e,t=0,i=0,s=" "){return 0===t&&0===i?e:`${0===t?"":s.repeat(t)}${e}${0===i?"":s.repeat(i)}`},e.padLeft=o,e.padLeftOrTruncate=function(e,t,i,s){return(s=s||h(e))<t?o(e,t,i,s):s>t?n(e,t,void 0,s):e},e.padRight=a,e.padOrTruncate=function(e,t,i,s){const r=t<0;return t=Math.abs(t),(s=s||h(e))<t?r?o(e,t,i,s):a(e,t,i,s):s>t?n(e,t,void 0,s):e},e.padRightOrTruncate=function(e,t,i,s){return(s=s||h(e))<t?a(e,t,i,s):s>t?n(e,t):e},e.pluralize=function(e,t,i){return void 0===i?`${t} ${e}${1===t?"":"s"}`:`${0===t?i.zero||t:i.number||t} ${1===t?e:i.plural||`${e}${i.suffix||"s"}`}`};const r=/[\\/:*?"<>|\x00-\x1f\x80-\x9f]/g;function n(e,t,i="…",s){if(!e)return e;if((s=s||h(e))<=t)return e;if(s===e.length)return`${e.substring(0,t-1)}${i}`;let o=Math.floor(t/(s/e.length)),a=h(e.substring(0,o));for(;a<t;)a+=h(e[o++]);return a>=t&&o--,`${e.substring(0,o)}${i}`}e.sanitizeForFileSystem=function(e,t="_"){return e?e.replace(r,t):e},e.sha1=function(e,t="base64"){return Object(ne.createHash)("sha1").update(e).digest(t)},e.truncate=n;const l=/[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[a-zA-Z\\d]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PRZcf-ntqry=><~]))/g,c=/[^\x20-\x7F\u00a0\u2026]/;function h(e){if(null==e||0===e.length)return 0;if(!c.test(e))return e.length;let t=0,i=0,s=0;const o=[...e=e.replace(l,"")];for(let e=0;e<o.length;e++){const a=o[e].codePointAt(0);if(!(a<=31||a>=127&&a<=159)&&!(a>=768&&a<=879))if(a>=128512&&a<=128591||a>=127744&&a<=128511||a>=128640&&a<=128767||a>=9728&&a<=9983||a>=9984&&a<=10175||a>=65024&&a<=65039||a>=129280&&a<=129535||a>=65024&&a<=65039||a>=8400&&a<=8447){if(a>=127995&&a<=127999)continue;i++,t+=2}else 8205!==a?(a>65535&&e++,t+=d(a)?2:1):(s++,t-=2)}const a=i-s;return a>1&&(t+=a-1),t}function d(e){return e>=4352&&(e<=4447||9001===e||9002===e||11904<=e&&e<=12871&&12351!==e||12880<=e&&e<=19903||19968<=e&&e<=42182||43360<=e&&e<=43388||44032<=e&&e<=55203||63744<=e&&e<=64255||65040<=e&&e<=65049||65072<=e&&e<=65131||65281<=e&&e<=65376||65504<=e&&e<=65510||110592<=e&&e<=110593||127488<=e&&e<=127569||131072<=e&&e<=262141)}e.getWidth=h}(ae||(ae={})),function(e){function t(e,t,i,s){return{major:"string"==typeof e?parseInt(e,10):e,minor:"string"==typeof t?parseInt(t,10):t,patch:"string"==typeof i?parseInt(i,10):i,pre:s}}e.compare=function(e,t){return e.major>t.major?1:e.major<t.major?-1:e.minor>t.minor?1:e.minor<t.minor?-1:e.patch>t.patch?1:e.patch<t.patch?-1:void 0===e.pre&&void 0!==t.pre?1:void 0!==e.pre&&void 0===t.pre?-1:void 0!==e.pre&&void 0!==t.pre?e.pre.localeCompare(t.pre):0},e.from=t,e.fromString=function(e){const[i,s]=e.split("-"),[o,a,r]=i.split(".");return t(o,a,r,s)}}(re||(re={}));var le=i(8);const ce="win32"===process.platform;function he(e){if(e.match(/[\\\/]/))return e;const t=y.join(".",e);try{if(U.statSync(t))return t}catch(e){}const i=process.env.PATH.split(ce?";":":");for(const t of i){const i=y.join(t,e);try{if(U.statSync(i))return i}catch(e){}}return e}function de(e,t,i={}){const s=Object.assign({maxBuffer:104857600},i),{stdin:o,stdinEncoding:a}=s,r=L.__rest(s,["stdin","stdinEncoding"]);return new Promise((i,s)=>{const n=Object(le.execFile)(e,t,r,(o,a,n)=>{if(!o)return n&&H.warn(`Warning(${e} ${t.join(" ")}): ${n}`),void i(a);"stdout maxBuffer exceeded"===o.message&&s(new Error(`Command output exceeded the allocated stdout buffer. Set 'options.maxBuffer' to a larger value than ${r.maxBuffer} bytes`)),s(o)});o&&n.stdin.end(o,a||"utf8")})}async function me(e){const t=await de(e,["--version"]);return e&&"git"!==e||(e=function e(t,i){if(!ce)return{cmd:he(t),args:i};if(!U.existsSync(t)){const s=[".exe",".bat",".cmd",".ps1"];for(const o of s){const s=he(`${t}${o}`);if(U.existsSync(s))return e(s,i)}}if(t.match(/\.ps1$/i))return{cmd:y.join(process.env.SYSTEMROOT,"System32","WindowsPowerShell","v1.0","PowerShell.exe"),args:["-ExecutionPolicy","Unrestricted","-NoLogo","-NonInteractive","-File",t].concat(i)};if(t.match(/\.(bat|cmd)$/i))return{cmd:y.join(process.env.SYSTEMROOT,"System32","cmd.exe"),args:["/C",t,...i]};if(t.match(/\.(js)$/i))return{cmd:process.execPath,args:[t].concat(i)};return{cmd:t,args:i}}(e,["--version"]).cmd),{path:e,version:function(e){return e.replace(/^git version /,"")}(t.trim())}}function ue(e){return e?me(y.join(e,"Git","cmd","git.exe")):Promise.reject(new Error("Unable to find git"))}async function ge(e){try{return await me(e||"git")}catch(e){try{switch(process.platform){case"darwin":return await async function(){try{let e=await de("which",["git"]);if("/usr/bin/git"!==(e=e.replace(/^\s+|\s+$/g,"")))return me(e);try{return await de("xcode-select",["-p"]),me(e)}catch(t){return 2===t.code?Promise.reject(new Error("Unable to find git")):me(e)}}catch(e){return Promise.reject(new Error("Unable to find git"))}}();case"win32":return await ue(process.env.ProgramW6432).then(null,()=>ue(process.env["ProgramFiles(x86)"])).then(null,()=>ue(process.env.ProgramFiles)).then(null,()=>me("git"));default:return Promise.reject("Unable to find git")}}catch(e){return Promise.reject(new Error("Unable to find git"))}}}const pe=/ /g;class fe{constructor(e,t){this.collapsableWhitespace=0,this.reset(e,t)}reset(e,t){this._item=e,void 0===t&&void 0!==this._options||(void 0===t&&(t={}),null==t.dateFormat&&(t.dateFormat="MMMM Do, YYYY h:mma"),null==t.tokenOptions&&(t.tokenOptions={}),this._options=t)}_padOrTruncate(e,t){void 0===t&&(t={truncateTo:void 0,padDirection:"left",collapseWhitespace:!1});let i=t.truncateTo;if(void 0===i){if(0===this.collapsableWhitespace)return e;const i=ae.getWidth(e),s=this.collapsableWhitespace-i;return this.collapsableWhitespace=0,s<=0?e:void 0===t.truncateTo?e:ae.padLeft(e,s,void 0,i)}i+=this.collapsableWhitespace,this.collapsableWhitespace=0;const s=ae.getWidth(e),o=i-s;return o>0?(t.collapseWhitespace&&(this.collapsableWhitespace=o),"left"===t.padDirection?ae.padLeft(e,i,void 0,s):(t.collapseWhitespace&&(i-=o),ae.padRight(e,i,void 0,s))):o<0?ae.truncate(e,i,void 0,s):e}static fromTemplateCore(e,t,i,s){if(t=t.replace(pe," "),e instanceof fe)return ae.interpolate(t,e);let o=void 0;if(null==s||"string"==typeof s){o={dateFormat:s,tokenOptions:ae.getTokensFromTemplate(t).reduce((e,t)=>(e[t.key]=t.options,e),{})}}else o=s;return void 0===this._formatter?this._formatter=new e(i,o):this._formatter.reset(i,o),ae.interpolate(t,this._formatter)}}fe._formatter=void 0;const ve=i(11),we=/:([-+_a-z0-9]+):/g;class be extends fe{get _ago(){return this._item.fromNow()}get _date(){return this._item.formatDate(this._options.dateFormat)}get _agoOrDate(){return(void 0!==this._options.dateStyle?this._options.dateStyle:Ts.config.defaultDateStyle)===m.Absolute?this._date:this._ago}get ago(){return this._padOrTruncate(this._ago,this._options.tokenOptions.ago)}get agoOrDate(){return this._padOrTruncate(this._agoOrDate,this._options.tokenOptions.agoOrDate)}get author(){const e=this._item.author;return this._padOrTruncate(e,this._options.tokenOptions.author)}get authorAgo(){const e=`${this._item.author}, ${this._ago}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get authorAgoOrDate(){const e=`${this._item.author}, ${this._agoOrDate}`;return this._padOrTruncate(e,this._options.tokenOptions.authorAgo)}get date(){return this._padOrTruncate(this._date,this._options.tokenOptions.date)}get id(){return this._item.shortSha}get message(){let e;if(this._item.isStagedUncommitted)e="Staged changes";else if(this._item.isUncommitted)e="Uncommitted changes";else{if(this._options.truncateMessageAtNewLine){const t=this._item.message.indexOf("\n");e=-1===t?this._item.message:`${this._item.message.substring(0,t)}${T.Space}${T.Ellipsis}`}else e=this._item.message;e=e.replace(we,(e,t)=>ve[t]||e)}return this._padOrTruncate(e,this._options.tokenOptions.message)}get sha(){return this.id}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}class _e extends s.Uri{constructor(e,t){if(null==e)return void super();if(e.scheme===P.GitLensGit){const t=JSON.parse(e.query),[i,s]=_e.ensureValidUNCPath(e.authority,y.resolve(t.repoPath,t.fileName));return super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,void(!Zt.isStagedUncommitted(t.sha)&&Zt.isUncommitted(t.sha)||(this.sha=t.sha))}if(void 0===t)return void super(e);if("string"==typeof t)return super(e),void(this.repoPath=t);const[i,s]=_e.ensureValidUNCPath(e.authority,y.resolve(t.repoPath,t.fileName||e.fsPath));super({scheme:e.scheme,authority:i,path:s,query:e.query,fragment:e.fragment}),this.repoPath=t.repoPath,this.versionedPath=t.versionedPath,!Zt.isStagedUncommitted(t.sha)&&Zt.isUncommitted(t.sha)||(this.sha=t.sha)}get shortSha(){return this.sha&&Zt.shortenSha(this.sha)}equals(e){return!!n.equals(this,e)&&this.sha===(e instanceof _e?e.sha:void 0)}fileUri(e={}){return e.useVersionedPath&&void 0!==this.versionedPath?s.Uri.file(this.versionedPath):s.Uri.file(!e.noSha&&this.sha?this.path:this.fsPath)}getDirectory(e){return _e.getDirectory(y.relative(this.repoPath||"",this.fsPath),e)}getFilename(e){return y.basename(y.relative(this.repoPath||"",this.fsPath),e)}getFormattedPath(e=ae.pad(T.Dot,2,2),t){let i=y.dirname(this.fsPath);return this.repoPath&&(i=y.relative(this.repoPath,i)),void 0!==t&&(i=y.relative(t,i)),(i=ae.normalizePath(i))&&"."!==i?`${y.basename(this.fsPath)}${e}${i}`:y.basename(this.fsPath)}getRelativePath(e){let t=y.relative(this.repoPath||"",this.fsPath);return void 0!==e&&(t=y.relative(e,t)),ae.normalizePath(t)}static ensureValidUNCPath(e,t){if("\\"===t[0]&&"\\"===t[1]){const i=t.indexOf("\\",2);-1===i?(e=t.substring(2),t="\\"):(e=t.substring(2,i),t=t.substring(i)||"\\")}return[e,t]}static fromCommit(e,t=!1){return t?new _e(e.previousUri,{repoPath:e.repoPath,sha:e.previousSha}):new _e(e.uri,e)}static fromFileStatus(e,t,i,o=!1){const a=s.Uri.file(y.resolve(t,o&&e.originalFileName||e.fileName));return new _e(a,void 0===i?t:{repoPath:t,sha:i})}static fromRepoPath(e,t){return new _e(s.Uri.file(e),void 0===t?e:{repoPath:e,sha:t})}static fromRevisionUri(e){return new _e(e)}static async fromUri(e){if(e instanceof _e)return e;if(!Ts.git.isTrackable(e))return new _e(e);if(e.scheme===P.GitLensGit)return new _e(e);if(e.scheme===P.Git){const t=JSON.parse(e.query),i=await Ts.git.getRepoPath(t.path);let s;switch(t.ref){case"":case"~":s=Zt.stagedUncommittedSha;break;case null:s=void 0;break;default:s=t.ref}return new _e(e,{fileName:t.path,repoPath:i,sha:s})}const t=await Ts.git.getVersionedUri(e);return void 0!==t?t:new _e(e,await Ts.git.getRepoPath(e))}static getDirectory(e,t){let i=y.dirname(e);return void 0!==t&&(i=y.relative(t,i)),(i=ae.normalizePath(i))&&"."!==i?i:""}static getFormattedPath(e,t=ae.pad(T.Dot,2,2),i){let o;if(e instanceof s.Uri){if(e instanceof _e)return e.getFormattedPath(t,i);o=e.fsPath}else o=e;const a=_e.getDirectory(o,i);return a?`${y.basename(o)}${t}${a}`:y.basename(o)}static getRelativePath(e,t,i){let o;if(e instanceof s.Uri){if(e instanceof _e)return e.getRelativePath(t);o=e.fsPath}else o=e;let a=y.relative(i||"",o);return void 0!==t&&(a=y.relative(t,a)),ae.normalizePath(a)}static toKey(e){return ae.normalizePath(("string"==typeof e?s.Uri.file(e):e).fsPath)}static toRevisionUri(e,t,i){let o,a,r;"string"==typeof e?(o="string"==typeof t?t:y.resolve(i,t.fileName),a=e,r=Zt.shortenSha(a)):(o=e.fsPath,i=e.repoPath,a=e.sha,r=e.shortSha);const n={fileName:ae.normalizePath(y.relative(i,o)),repoPath:i,sha:a},l=y.parse(o);return s.Uri.parse(`${P.GitLensGit}:${y.join(l.dir,l.name)}:${r}${l.ext}?${JSON.stringify(n)}`)}}class Ce{constructor(e,t,i=!1,s,o,a=0,r=0,n=!1){this.repoPath=e,this.current=i,this.sha=s,t.startsWith("remotes/")?(t=t.substring(8),this.remote=!0):this.remote=!1,this.detached=n||!!this.current&&Ce.isDetached(t),this.detached?this.name=Ce.formatDetached(this.sha):this.name=t,this.tracking=""===o||null==o?void 0:o,this.state={ahead:a,behind:r}}get ref(){return this.detached?this.sha:this.name}getBasename(){if(void 0===this._basename){const e=this.getName(),t=e.lastIndexOf("/");this._basename=-1!==t?e.substring(t+1):e}return this._basename}getName(){return void 0===this._name&&(this._name=this.remote?this.name.substring(this.name.indexOf("/")+1):this.name),this._name}getRemote(){return this.remote?Ce.getRemote(this.name):void 0!==this.tracking?Ce.getRemote(this.tracking):void 0}getTrackingStatus(e){return ye.getUpstreamStatus(this.tracking,this.state,e)}static getRemote(e){return e.substring(0,e.indexOf("/"))}static formatDetached(e){return`(${Wt.shortenSha(e)}...)`}static isDetached(e){return null!==e.match(/\s/)||null!==e.match(/\(detached\)/)}}class ye{constructor(e,t,i,s,o,a){this.repoPath=e,this.branch=t,this.sha=i,this.files=s,this.state=o,this.upstream=a,this.detached=Ce.isDetached(t),this.detached&&(this.branch=Ce.formatDetached(this.sha))}get ref(){return this.detached?this.sha:this.branch}getDiffStatus(e={}){if(e=Object.assign({empty:"",prefix:"",separator:" "},e),0===this.files.length)return e.empty;if(void 0===this._diff){this._diff={added:0,deleted:0,changed:0};for(const e of this.files)switch(e.status){case"A":case"?":this._diff.added++;break;case"D":this._diff.deleted++;break;default:this._diff.changed++}}if(e.expand){let t="";return this._diff.added&&(t+=`${ae.pluralize("file",this._diff.added)} added`),this._diff.changed&&(t+=`${""===t?"":e.separator}${this._diff.changed} ${ae.pluralize("file",this._diff.changed)} changed`),this._diff.deleted&&(t+=`${""===t?"":e.separator}${this._diff.deleted} ${ae.pluralize("file",this._diff.deleted)} deleted`),`${e.prefix}${t}`}return`${e.prefix}+${this._diff.added}${e.separator}~${this._diff.changed}${e.separator}-${this._diff.deleted}`}getUpstreamStatus(e){return ye.getUpstreamStatus(this.upstream,this.state,e)}static getUpstreamStatus(e,t,i={}){if(i=Object.assign({empty:"",prefix:"",separator:" "},i),void 0===e||0===t.behind&&0===t.ahead)return i.empty;if(i.expand){let e="";return t.behind&&(e+=`${ae.pluralize("commit",t.behind)} behind`),t.ahead&&(e+=`${""===e?"":i.separator}${ae.pluralize("commit",t.ahead)} ahead`),`${i.prefix}${e}`}return`${i.prefix}${t.behind}${T.ArrowDown}${i.separator}${t.ahead}${T.ArrowUp}`}}class xe{constructor(e,t,i,s,o){this.repoPath=e,this.indexStatus=t,this.workTreeStatus=i,this.fileName=s,this.originalFileName=o}get status(){return this.indexStatus||this.workTreeStatus||"?"}get staged(){return void 0!==this.indexStatus}get uri(){return s.Uri.file(y.resolve(this.repoPath,this.fileName))}getFormattedDirectory(e=!1){return xe.getFormattedDirectory(this,e)}getFormattedPath(e=ae.pad(T.Dot,2,2)){return xe.getFormattedPath(this,e)}getOcticon(){return Se(this.status)}getStatusText(e){return xe.getStatusText(this.status)}with(e){return new xe(this.repoPath,this.getChangedValue(e.indexStatus,this.indexStatus),this.getChangedValue(e.workTreeStatus,this.workTreeStatus),e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName))}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}static getFormattedDirectory(e,t=!1,i){const s=_e.getDirectory(e.fileName,i);return t&&"R"===e.status&&e.originalFileName?`${s} ${ae.pad(T.ArrowLeft,1,1)} ${e.originalFileName}`:s}static getFormattedPath(e,t=ae.pad(T.Dot,2,2),i){return _e.getFormattedPath(e.fileName,t,i)}static getRelativePath(e,t){return _e.getRelativePath(e.fileName,t)}static getStatusText(e){return function(e){return Fe[e]||Fe.X}(e)}}const $e={"!":"$(diff-ignored)","?":"$(diff-added)",A:"$(diff-added)",C:"$(diff-added)",D:"$(diff-removed)",M:"$(diff-modified)",R:"$(diff-renamed)",T:"$(diff-modified)",U:"$(alert)",X:"$(question)",B:"$(question)"};function Se(e,t=T.Space.repeat(4)){return $e[e]||t}const ke={"!":"icon-status-ignored.svg","?":"icon-status-untracked.svg",A:"icon-status-added.svg",C:"icon-status-copied.svg",D:"icon-status-deleted.svg",M:"icon-status-modified.svg",R:"icon-status-renamed.svg",T:"icon-status-modified.svg",U:"icon-status-conflict.svg",X:"icon-status-unknown.svg",B:"icon-status-unknown.svg"};function De(e){return ke[e]||ke.X}const Fe={"!":"ignored","?":"untracked",A:"added",C:"copied",D:"deleted",M:"modified",R:"renamed",T:"modified",U:"conflict",X:"unknown",B:"unknown"};class Pe extends fe{get directory(){const e=xe.getFormattedDirectory(this._item,!1,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.file)}get file(){const e=y.basename(this._item.fileName);return this._padOrTruncate(e,this._options.tokenOptions.file)}get filePath(){const e=xe.getFormattedPath(this._item,void 0,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.filePath)}get path(){const e=xe.getRelativePath(this._item,this._options.relativePath);return this._padOrTruncate(e,this._options.tokenOptions.path)}get status(){const e=xe.getStatusText(this._item.status);return this._padOrTruncate(e,this._options.tokenOptions.status)}get working(){const e=this._item.commit;return void 0!==e&&e.isUncommitted?`${T.Pencil} ${T.Space}`:""}static fromTemplate(e,t,i){return super.fromTemplateCore(this,e,t,i)}}const Te=new Map;var Re;!function(e){e.Blame="blame",e.Branch="branch",e.File="file",e.Stash="stash",e.StashFile="stash-file"}(Re||(Re={}));const Ee={dateFormat:void 0,dateStyle:void 0,reset:()=>{Ee.dateStyle=ti.get(ti.name("defaultDateStyle").value),Ee.dateFormat=ti.get(ti.name("defaultDateFormat").value)}};class Be{constructor(e,t,i,s,o,a,r,n,l,c,h){this.repoPath=t,this.sha=i,this.author=s,this.email=o,this.date=a,this.message=r,this.type=e,this._fileName=n||"",this.originalFileName=l,this._previousSha=c,this.previousFileName=h}get fileName(){return this.isFile?this._fileName:""}get formattedDate(){return Ee.dateStyle===m.Absolute?this.formatDate(Ee.dateFormat):this.fromNow()}get shortSha(){return void 0===this._shortSha&&(this._shortSha=Wt.shortenSha(this.sha)),this._shortSha}get isFile(){return this.type===Re.Blame||this.type===Re.File||this.type===Re.StashFile}get isStash(){return this.type===Re.Stash||this.type===Re.StashFile}get isStagedUncommitted(){return void 0===this._isStagedUncommitted&&(this._isStagedUncommitted=Wt.isStagedUncommitted(this.sha)),this._isStagedUncommitted}get isUncommitted(){return void 0===this._isUncommitted&&(this._isUncommitted=Wt.isUncommitted(this.sha)),this._isUncommitted}get previousFileShortSha(){return Wt.shortenSha(this.previousFileSha)}get previousSha(){return this._previousSha}set previousSha(e){e!==this._previousSha&&(this._previousSha=e,this._resolvedPreviousFileSha=void 0)}get previousShortSha(){return this.previousSha&&Wt.shortenSha(this.previousSha)}get previousUri(){return this.previousFileName?s.Uri.file(y.resolve(this.repoPath,this.previousFileName||this.originalFileName)):this.uri}get uri(){return s.Uri.file(y.resolve(this.repoPath,this.fileName))}get workingUri(){return this.workingFileName?s.Uri.file(y.resolve(this.repoPath,this.workingFileName)):this.uri}formatDate(e){return null==e&&(e="MMMM Do, YYYY h:mma"),void 0===this._dateFormatter&&(this._dateFormatter=Y.toFormatter(this.date)),this._dateFormatter.format(e)}fromNow(){return void 0===this._dateFormatter&&(this._dateFormatter=Y.toFormatter(this.date)),this._dateFormatter.fromNow()}getFormattedPath(e=ae.pad(T.Dot,2,2)){return _e.getFormattedPath(this.fileName,e)}getGravatarUri(e,t=16){const i=this.email?`${this.email.trim().toLowerCase()}:${t}`:"";let o=Te.get(i);if(void 0!==o)return o;const a=(o=s.Uri.parse(`https://www.gravatar.com/avatar/${this.email?ae.md5(this.email,"hex"):"00000000000000000000000000000000"}.jpg?s=${t}&d=${e}`)).toString;return o.toString=function(e){return a.call(o,!0)},Te.set(i,o),o}getShortMessage(){return be.fromTemplate("${message}",this,{truncateMessageAtNewLine:!0})}async resolvePreviousFileSha(){void 0===this._resolvedPreviousFileSha&&(this._resolvedPreviousFileSha=await Ts.git.resolveReference(this.repoPath,this.previousFileSha,this.fileName?this.previousUri:void 0))}toGitUri(e=!1){return _e.fromCommit(this,e)}getChangedValue(e,t){return void 0===e?t:null!==e?e:void 0}}class Ne extends Be{constructor(e,t,i,s,o,a,r,n,l,c,h){super(Re.Blame,e,t,i,s,o,a,r,n,l,c),this.lines=h}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:`${this.sha}^`}with(e){return new Ne(this.repoPath,e.sha||this.sha,this.author,this.email,this.date,this.message,e.fileName||this.fileName,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),this.getChangedValue(e.lines,e.sha||e.fileName?[]:this.lines)||[])}}const Ae=/^(.*?)\t(.*?)(?:\t(.*?))?$/gm,Oe=/^\s*(\d+)\sfiles? changed(?:,\s+(\d+)\s+insertions?\(\+\))?(?:,\s+(\d+)\s+deletions?\(-\))?/,Le=/^@@ -([\d]+),([\d]+) [+]([\d]+),([\d]+) @@([\s\S]*?)(?=^@@)/gm;class Ue{static parse(e,t=!1){if(!e)return;const i=[];let s,o,a,r=null;do{if(null==(r=Le.exec(`${e}\n@@`)))break;s=(" "+r[5]).substr(1),o=parseInt(r[3],10),a=parseInt(r[1],10),i.push(new Ie(s,{start:o,end:o+parseInt(r[4],10)},{start:a,end:a+parseInt(r[2],10)}))}while(null!=r);if(!i.length)return;return{diff:t?e:void 0,chunks:i}}static parseChunk(e){const t=ee.skip(ae.lines(e),1),i=[],s=[];let o=0;for(const e of t)switch(e[0]){case"+":i.push({line:` ${e.substring(1)}`,state:"added"}),o>0?o--:s.push(void 0);break;case"-":o++,s.push({line:` ${e.substring(1)}`,state:"removed"});break;default:for(;o>0;)o--,i.push(void 0);i.push({line:e,state:"unchanged"}),s.push({line:e,state:"unchanged"})}const a=[];let r=void 0,n=void 0;for(let e=0;e<i.length;e++)if(void 0!==(n=i[e]))r={line:n.line,state:n.state,previous:[s[e]]},a.push(r);else{if(void 0===r)continue;if(void 0===r.previous){r.previous=[s[e]];continue}r.previous.push(s[e])}return a}static parseNameStatus(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=Ae.exec(e)))break;i.push(Ft.parseStatusFile(t,(" "+s[1]).substr(1),(" "+s[2]).substr(1),void 0===s[3]?void 0:(" "+s[3]).substr(1)))}while(null!=s);return i.length?i:void 0}static parseShortStat(e){if(!e)return;const t=Oe.exec(e);if(null==t)return;const i=t[1],s=t[2],o=t[3];return{files:null==i?0:parseInt(i,10),insertions:null==s?0:parseInt(s,10),deletions:null==o?0:parseInt(o,10)}}}class Ie{constructor(e,t,i){this.currentPosition=t,this.previousPosition=i,this._chunk=e}get lines(){return void 0===this._lines&&(this._lines=Ue.parseChunk(this._chunk),this._chunk=void 0),this._lines}}class Me extends Be{constructor(e,t,i,s,o,a,r,n,l,c,h,d,m,u){super(e,t,i,s,o,a,r,n,h,d,m),this.fileStatuses=l,this.status=c,this.parentShas=u}get isMerge(){return this.parentShas&&this.parentShas.length>1}get nextShortSha(){return this.nextSha&&Wt.shortenSha(this.nextSha)}get nextUri(){return this.nextFileName?s.Uri.file(y.resolve(this.repoPath,this.nextFileName)):this.uri}get previousFileSha(){return void 0!==this._resolvedPreviousFileSha?this._resolvedPreviousFileSha:this.isFile&&this.previousSha?this.previousSha:`${this.sha}^`}getDiffStatus(){let e=0,t=0,i=0;for(const s of this.fileStatuses)switch(s.status){case"A":case"?":e++;break;case"D":t++;break;default:i++}return`+${e} ~${i} -${t}`}toFileCommit(e){let t,i;if("string"==typeof e){const i=ae.normalizePath(y.relative(this.repoPath,e));if(void 0===(t=this.fileStatuses.find(e=>e.fileName===i)))return}else t=e;this.type===Re.Stash&&"?"===t.status&&(i=`${this.sha}^3`);const s=this.isFile?this.previousSha:`${this.sha}^`;return this.with({type:this.isStash?Re.StashFile:Re.File,sha:i,fileName:t.fileName,originalFileName:t.originalFileName,previousSha:s,previousFileName:t.originalFileName||t.fileName,status:t.status,fileStatuses:[t]})}with(e){return new Me(e.type||this.type,this.repoPath,this.getChangedValue(e.sha,this.sha),e.author||this.author,e.email||this.email,e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName),void 0)}}var We,He;!function(e){e.Fetch="fetch",e.Push="push"}(We||(We={}));class je{constructor(e,t,i,s,o,a,r){this.repoPath=e,this.name=t,this.scheme=i,this.domain=s,this.path=o,this.provider=a,this.types=r}}function Ge(e){switch(e.type){case He.Branch:return"Branch";case He.Branches:return"Branches";case He.Commit:return"Commit";case He.File:return"File";case He.Repo:return"Repository";case He.Revision:return"Revision";default:return""}}!function(e){e.Branch="branch",e.Branches="branches",e.Commit="commit",e.File="file",e.Repo="repo",e.Revision="revision"}(He||(He={}));class Ve{constructor(e,t,i="https",s,o=!1){this.domain=e,this.path=t,this.protocol=i,this.custom=o,this._name=s}get icon(){return"remote"}get baseUrl(){return`${this.protocol}://${this.domain}/${this.path}`}enrichMessage(e){return e}formatName(e){return void 0!==this._name?this._name:`${e}${this.custom?` (${this.domain})`:""}`}splitPath(){const e=this.path.indexOf("/");return[this.path.substring(0,e),this.path.substring(e+1)]}getUrlForRepository(){return this.baseUrl}async openUrl(e){if(void 0!==e)return s.commands.executeCommand(D.Open,s.Uri.parse(e))}async copy(e){const t=this.url(e);if(void 0!==t)try{const e=await Promise.resolve().then(i.t.bind(null,14,7));return void await e.write(t)}catch(e){return e.message.includes("Couldn't find the required `xsel` binary")?void s.window.showErrorMessage("Unable to copy remote url, xsel is not installed. You can install it via `sudo apt install xsel`"):(H.error(e,"CopyRemoteUrlToClipboardCommand"),s.window.showErrorMessage("Unable to copy remote url. See output channel for more details"))}}open(e){return this.openUrl(this.url(e))}url(e){switch(e.type){case He.Branch:return this.getUrlForBranch(e.branch);case He.Branches:return this.getUrlForBranches();case He.Commit:return this.getUrlForCommit(e.sha);case He.File:return this.getUrlForFile(e.fileName,e.branch,void 0,e.range);case He.Repo:return this.getUrlForRepository();case He.Revision:return this.getUrlForFile(e.fileName,e.branch,e.sha,e.range)}}}const ze=/(^|\s)(issue #([0-9]+))\b/gi,Qe=/(^|\s)(pull request #([0-9]+))\b/gi;class qe extends Ve{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket")}enrichMessage(e){return e.replace(ze,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(Qe,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/branch/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${e}-${s.start.line}`:`#${e}-${s.start.line}:${s.end.line}`),i?`${this.baseUrl}/src/${i}/${e}${o}`:t?`${this.baseUrl}/src/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const Ke=/(^|\s)(issue #([0-9]+))\b/gi,Ye=/(^|\s)(pull request #([0-9]+))\b/gi;class Xe extends Ve{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get baseUrl(){const[e,t]=this.splitPath();return`https://${this.domain}/projects/${e}/repos/${t}`}get icon(){return"bitbucket"}get name(){return this.formatName("Bitbucket Server")}enrichMessage(e){return e.replace(Ke,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(Ye,`$1[$2](${this.baseUrl}/pull-requests/$3 "Open PR $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits?until=${e}`}getUrlForCommit(e){return`${this.baseUrl}/commits/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#${s.start.line}`:`#${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/browse/${e}?at=${i}${o}`:t?`${this.baseUrl}/browse/${e}?at=${t}${o}`:`${this.baseUrl}/browse/${e}${o}`}}class Ze extends Ve{constructor(e,t,i,s,o){super(e,t,s,o,!0),this.urls=i}get name(){return this.formatName("Custom")}getUrlForRepository(){return ae.interpolate(this.urls.repository,this.getContext())}getUrlForBranches(){return ae.interpolate(this.urls.branches,this.getContext())}getUrlForBranch(e){return ae.interpolate(this.urls.branch,this.getContext({branch:e}))}getUrlForCommit(e){return ae.interpolate(this.urls.commit,this.getContext({id:e}))}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?ae.interpolate(this.urls.fileLine,{line:s.start.line}):ae.interpolate(this.urls.fileRange,{start:s.start.line,end:s.end.line})),i?ae.interpolate(this.urls.fileInCommit,this.getContext({id:i,file:e,line:o})):t?ae.interpolate(this.urls.fileInBranch,this.getContext({branch:t,file:e,line:o})):ae.interpolate(this.urls.file,this.getContext({file:e,line:o}))}getContext(e){const[t,i]=this.splitPath();return Object.assign({repo:this.path,repoBase:t,repoPath:i},e||{})}}const Je=/(^|\s)((?:#|gh-)([0-9]+))\b/gi,et=/\b((\w+-?\w+(?!-)\/\w+-?\w+(?!-))#([0-9]+))\b/g;class tt extends Ve{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"github"}get name(){return this.formatName("GitHub")}enrichMessage(e){return e.replace(Je,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`).replace(et,`[$1](${this.protocol}://${this.domain}/$2/issues/$3 "Open Issue #$3 from $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-L${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const it=/(^|\s)(#([0-9]+))\b/gi;class st extends Ve{constructor(e,t,i,s,o=!1){super(e,t,i,s,o)}get icon(){return"gitlab"}get name(){return this.formatName("GitLab")}enrichMessage(e){return e.replace(it,`$1[$2](${this.baseUrl}/issues/$3 "Open Issue $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/commits/${e}`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`#L${s.start.line}`:`#L${s.start.line}-${s.end.line}`),i?`${this.baseUrl}/blob/${i}/${e}${o}`:t?`${this.baseUrl}/blob/${t}/${e}${o}`:`${this.baseUrl}?path=${e}${o}`}}const ot=/(^|\s)(#([0-9]+))\b/gi,at=/\/_git\/?/i;const rt=new Map([["bitbucket.org",(e,t)=>new qe(e,t)],["github.com",(e,t)=>new tt(e,t)],["gitlab.com",(e,t)=>new st(e,t)],["visualstudio.com",(e,t)=>new class extends Ve{constructor(e,t,i,s){super(e,t,i,s)}get icon(){return"vsts"}get name(){return"Visual Studio Team Services"}enrichMessage(e){const t=this.baseUrl.replace(at,"/");return e.replace(ot,`$1[$2](${t}/_workitems/edit/$3 "Open Work Item $2")`)}getUrlForBranches(){return`${this.baseUrl}/branches`}getUrlForBranch(e){return`${this.baseUrl}/?version=GB${e}&_a=history`}getUrlForCommit(e){return`${this.baseUrl}/commit/${e}`}getUrlForFile(e,t,i,s){let o="";return s&&(o=s.start.line===s.end.line?`&line=${s.start.line}`:`&line=${s.start.line}&lineEnd=${s.end.line}`),i?`${this.baseUrl}/commit/${i}/?_a=contents&path=%2F${e}${o}`:t?`${this.baseUrl}/?path=%2F${e}&version=GB${t}&_a=contents${o}`:`${this.baseUrl}?path=%2F${e}${o}`}}(e,t)]]);class nt{static factory(e){return(t,i)=>this.create(e,t,i)}static create(e,t,i){try{let s=t.toLowerCase();s.endsWith("visualstudio.com")&&(s="visualstudio.com");const o=e.get(s);if(void 0===o)return;return o(t,i)}catch(e){return void H.error(e,"RemoteProviderFactory")}}static createMap(e){const t=new Map(rt);if(null!=e&&e.length>0)for(const i of e){const e=this.getCustomProvider(i);void 0!==e&&t.set(i.domain.toLowerCase(),e)}return t}static getCustomProvider(e){switch(e.type){case d.Bitbucket:return(t,i)=>new qe(t,i,e.protocol,e.name,!0);case d.BitbucketServer:return(t,i)=>new Xe(t,i,e.protocol,e.name,!0);case d.Custom:return(t,i)=>new Ze(t,i,e.urls,e.protocol,e.name);case d.GitHub:return(t,i)=>new tt(t,i,e.protocol,e.name,!0);case d.GitLab:return(t,i)=>new st(t,i,e.protocol,e.name,!0)}}}var lt,ct;!function(e){e.Config="config",e.Closed="closed",e.Remotes="remotes",e.Repository="repository",e.Stashes="stashes",e.Tags="tags"}(lt||(lt={}));class ht{constructor(e){this.repository=e,this.changes=[]}changed(e,t=!1){return t?1===this.changes.length&&this.changes[0]===e:this.changes.includes(e)}}!function(e){e.StatusNode="statusNode"}(ct||(ct={}));class dt{constructor(e,t,i,o,a,r=!1){if(this.folder=e,this.path=t,this.root=i,this.onAnyRepositoryChanged=o,this._onDidChange=new s.EventEmitter,this._onDidChangeFileSystem=new s.EventEmitter,this._fireChangeDebounced=void 0,this._fireFileSystemChangeDebounced=void 0,this._fsWatchCounter=0,this._pendingChanges={},this._closed=!1,i)this.formattedName=e.name;else{const i=y.relative(e.uri.fsPath,t);this.formattedName=i?`${e.name} (${i})`:e.name}this.index=e.index,this.name=e.name,this.normalizedPath=(this.path.endsWith("/")?this.path:`${this.path}/`).toLowerCase(),this._suspended=a,this._closed=r;const n=s.workspace.createFileSystemWatcher(new s.RelativePattern(e,"{**/.git/config,**/.git/index,**/.git/HEAD,**/.git/refs/stash,**/.git/refs/heads/**,**/.git/refs/remotes/**,**/.git/refs/tags/**,**/.gitignore}"));this._disposable=s.Disposable.from(n,n.onDidChange(this.onRepositoryChanged,this),n.onDidCreate(this.onRepositoryChanged,this),n.onDidDelete(this.onRepositoryChanged,this),ti.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ti.initializingChangeEvent)}get onDidChange(){return this._onDidChange.event}get onDidChangeFileSystem(){return this._onDidChangeFileSystem.event}dispose(){this.stopWatchingFileSystem(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ti.initializing(e),i=ti.name("remotes").value;(t||ti.changed(e,i,this.folder.uri))&&(this._providerMap=nt.createMap(ti.get(i,this.folder.uri)),t||(this._remotes=void 0,this.fireChange(lt.Remotes)))}onFileSystemChanged(e){/\.git(?:\/|\\|$)/.test(e.fsPath)||this.fireFileSystemChange(e)}onRepositoryChanged(e){if(void 0!==e&&e.path.endsWith("refs/stash"))this.fireChange(lt.Stashes);else{if(this._branch=void 0,void 0!==e&&e.path.endsWith("refs/remotes"))return this._remotes=void 0,void this.fireChange(lt.Remotes);if(void 0!==e&&e.path.endsWith("refs/tags"))this.fireChange(lt.Tags);else{if(void 0!==e&&e.path.endsWith("config"))return this._remotes=void 0,void this.fireChange(lt.Config,lt.Remotes);this.onAnyRepositoryChanged(this,lt.Repository),this.fireChange(lt.Repository)}}}get closed(){return this._closed}set closed(e){const t=this._closed!==e;this._closed=e,t&&(this.onAnyRepositoryChanged(this,lt.Closed),this.fireChange(lt.Closed))}containsUri(e){return e instanceof _e&&(e=void 0!==e.repoPath?s.Uri.file(e.repoPath):e.fileUri()),this.folder===s.workspace.getWorkspaceFolder(e)}getBranch(){return void 0===this._branch&&(this._branch=Ts.git.getBranch(this.path)),this._branch}getBranches(){return Ts.git.getBranches(this.path)}getChangedFilesCount(e){return Ts.git.getChangedFilesCount(this.path,e)}getRemotes(){if(void 0===this._remotes){if(void 0===this._providerMap){const e=ti.get(ti.name("remotes").value,this.folder.uri);this._providerMap=nt.createMap(e)}this._remotes=Ts.git.getRemotesCore(this.path,this._providerMap)}return this._remotes}getStashList(){return Ts.git.getStashList(this.path)}getStatus(){return Ts.git.getStatusForRepo(this.path)}getTags(){return Ts.git.getTags(this.path)}async hasRemotes(){const e=await this.getRemotes();return void 0!==e&&e.length>0}async hasTrackingBranch(){const e=await this.getBranch();return void 0!==e&&void 0!==e.tracking}resume(){this._suspended&&(this._suspended=!1,void 0!==this._pendingChanges.repo&&this._fireChangeDebounced(this._pendingChanges.repo),void 0!==this._pendingChanges.fs&&this._fireFileSystemChangeDebounced(this._pendingChanges.fs))}startWatchingFileSystem(){if(this._fsWatchCounter++,void 0!==this._fsWatcherDisposable)return;const e=s.workspace.createFileSystemWatcher(new s.RelativePattern(this.folder,"**"));this._fsWatcherDisposable=s.Disposable.from(e,e.onDidChange(this.onFileSystemChanged,this),e.onDidCreate(this.onFileSystemChanged,this),e.onDidDelete(this.onFileSystemChanged,this))}stopWatchingFileSystem(){void 0!==this._fsWatcherDisposable&&(--this._fsWatchCounter>0||(this._fsWatcherDisposable.dispose(),this._fsWatcherDisposable=void 0))}suspend(){this._suspended=!0}fireChange(...e){void 0===this._fireChangeDebounced&&(this._fireChangeDebounced=J.debounce(this.fireChangeCore,250)),void 0===this._pendingChanges.repo&&(this._pendingChanges.repo=new ht(this));const t=this._pendingChanges.repo;for(const i of e)t.changes.includes(i)||t.changes.push(i);this._suspended||this._fireChangeDebounced(t)}fireChangeCore(e){this._pendingChanges.repo=void 0,this._onDidChange.fire(e)}fireFileSystemChange(e){void 0===this._fireFileSystemChangeDebounced&&(this._fireFileSystemChangeDebounced=J.debounce(this.fireFileSystemChangeCore,2500)),void 0===this._pendingChanges.fs&&(this._pendingChanges.fs={repository:this,uris:[]});const t=this._pendingChanges.fs;t.uris.push(e),this._suspended||this._fireFileSystemChangeDebounced(t)}fireFileSystemChangeCore(e){this._pendingChanges.fs=void 0,this._onDidChangeFileSystem.fire(e)}}class mt extends Me{constructor(e,t,i,s,o,a,r,n,l,c,h,d){super(e,i,s,"You",void 0,o,a,r,n,l,c,void 0===h?`${s}^`:h,d),this.stashName=t}get shortSha(){return this.stashName}with(e){return new mt(e.type||this.type,this.stashName,this.repoPath,this.getChangedValue(e.sha,this.sha),e.date||this.date,e.message||this.message,e.fileName||this.fileName,this.getChangedValue(e.fileStatuses,this.fileStatuses)||[],e.status||this.status,this.getChangedValue(e.originalFileName,this.originalFileName),this.getChangedValue(e.previousSha,this.previousSha),this.getChangedValue(e.previousFileName,this.previousFileName))}}class ut{constructor(e,t,i){this.repoPath=e,this.name=t,this.annotation=i}get ref(){return this.name}getBasename(){if(void 0===this._basename){const e=this.name.lastIndexOf("/");this._basename=-1!==e?this.name.substring(e+1):this.name}return this._basename}}class gt{static parse(e,t,i,s){if(!e)return;const o=new Map,a=new Map,r=[];let n,l,c=t&&i,h=void 0,d=!0;for(n of ae.lines(e))if(!((l=n.split(" ")).length<2))if(void 0!==h)switch(l[0]){case"author":Wt.isUncommitted(h.sha)?h.author="You":h.author=l.slice(1).join(" ").trim();break;case"author-mail":h.authorEmail=l.slice(1).join(" ").trim();const e=h.authorEmail.indexOf("<");if(e>=0){const t=h.authorEmail.indexOf(">",e);h.authorEmail=t>e?h.authorEmail.substring(e+1,t):h.authorEmail.substring(e+1)}break;case"author-time":h.authorDate=l[1];break;case"author-tz":h.authorTimeZone=l[1];break;case"summary":h.summary=l.slice(1).join(" ").trim();break;case"previous":h.previousSha=l[1],h.previousFileName=l.slice(2).join(" ");break;case"filename":h.fileName=l.slice(1).join(" "),d&&void 0===t&&(t=ae.normalizePath(i.replace(i.startsWith("/")?`/${h.fileName}`:h.fileName,"")),c=ae.normalizePath(y.relative(t,i))),d=!1,gt.parseEntry(h,t,c,a,o,r,s),h=void 0}else h={sha:l[0],originalLine:parseInt(l[1],10)-1,line:parseInt(l[2],10)-1,lineCount:parseInt(l[3],10)};return a.forEach(e=>{if(void 0===e.author)return;const t=o.get(e.author);void 0!==t&&(t.lineCount+=e.lines.length)}),{repoPath:t,authors:new Map([...o.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:a,lines:r}}static parseEntry(e,t,i,s,o,a,r){let n=s.get(e.sha);if(void 0===n){if(void 0!==e.author){void 0===r||void 0===r.name&&void 0===r.email||void 0!==r.name&&r.name!==e.author||void 0!==r.email&&r.email!==e.authorEmail||(e.author="You");let t=o.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},o.set(e.author,t))}n=new Ne(t,e.sha,e.author,e.authorEmail,new Date(1e3*e.authorDate),e.summary,i,i!==e.fileName?e.fileName:void 0,e.previousSha,e.previousSha&&e.previousFileName,[]),s.set(e.sha,n)}for(let t=0,i=e.lineCount;t<i;t++){const i={sha:e.sha,line:e.line+t,originalLine:e.originalLine+t};n.previousSha&&(i.previousSha=n.previousSha),n.lines.push(i),a[i.line]=i}}}const pt=/^(\*?)\s+(.+?)\s+([0-9,a-f]+)\s+(?:\[(.*?\/.*?)(?:\:\s(.*)\]|\]))?/gm,ft=/^(?:ahead\s([0-9]+))?[,\s]*(?:behind\s([0-9]+))?/;class vt{static parse(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=pt.exec(e)))break;const[o,a]=this.parseState(s[5]);i.push(new Ce(t,(" "+s[2]).substr(1),"*"===s[1],void 0===s[3]?void 0:(" "+s[3]).substr(1),void 0===s[4]?void 0:(" "+s[4]).substr(1),o,a))}while(null!=s);return i.length?i:void 0}static parseState(e){if(null==e)return[0,0];const t=ft.exec(e);if(null==t)return[0,0];const i=parseInt(t[1],10),s=parseInt(t[2],10);return[isNaN(i)?0:i,isNaN(s)?0:s]}}const wt=/diff --git a\/(.*) b\/(.*)/,bt={};class _t{static parse(e,t,i,s,o,a,r,n,l){if(!e)return;let c,h,d=void 0,m=bt,u=void 0,g=0,p=!0;const f=ae.lines(e+"</f>");let v=f.next();if(v.done)return;void 0!==i&&(i=ae.normalizePath(i));const w=new Map,b=new Map;for(;!((v=f.next()).done||(u=v.value,n&&r&&g>=r));)switch(h=u.charCodeAt(1)){case 114:m={ref:u.substring(4)};break;case 97:Wt.isUncommitted(m.ref)?m.author="You":m.author=u.substring(4);break;case 101:m.email=u.substring(4);break;case 100:m.date=u.substring(4);break;case 112:m.parentShas=u.substring(4).split(" ");break;case 115:for(;!(v=f.next()).done&&"</s>"!==(u=v.value);)void 0===m.summary?m.summary=u:m.summary+=`\n${u}`;void 0!==m.summary&&(m.summary=m.summary.slice(0,-1));break;case 102:if((v=f.next()).done||"</f>"===v.value)break;for(;!(v=f.next()).done&&"</f>"!==(u=v.value);)if(!u.startsWith("warning:"))if(t===Re.Branch){const e={status:u[0],fileName:u.substring(1),originalFileName:void 0};this.parseFileName(e),e.fileName&&(void 0===m.fileStatuses&&(m.fileStatuses=[]),m.fileStatuses.push(e))}else{if(u.startsWith("diff")){const e=wt.exec(u);if(null!=e){m.fileName=e[1];const t=e[2];m.fileName!==t&&(m.originalFileName=t),m.status=m.fileName!==m.originalFileName?"R":"M"}for(;!(v=f.next()).done&&"</f>"!==v.value;);break}m.status=u[0],m.fileName=u.substring(1),this.parseFileName(m)}void 0!==m.fileStatuses&&(m.fileName=G.filterMap(m.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", ")),p&&void 0===i&&t===Re.File&&void 0!==s?(i=ae.normalizePath(s.replace(s.startsWith("/")?`/${m.fileName}`:m.fileName,"")),c=ae.normalizePath(y.relative(i,s))):c=m.fileName,p=!1;const e=b.get(m.ref);void 0===e&&g++,d=_t.parseEntry(m,e,t,i,c,b,w,d,a)}return{repoPath:i,authors:w,commits:b,sha:o,count:g,maxCount:r,range:l,truncated:!!(r&&g>=r&&1!==r)}}static parseEntry(e,t,i,s,o,a,r,n,l){if(void 0===t){if(void 0!==e.author){void 0===l||void 0===l.name&&void 0===l.email||void 0!==l.name&&l.name!==e.author||void 0!==l.email&&l.email!==e.email||(e.author="You");let t=r.get(e.author);void 0===t&&(t={name:e.author,lineCount:0},r.set(e.author,t))}const n=o!==e.fileName?e.fileName:void 0;i===Re.File&&(e.fileStatuses=[{status:e.status,fileName:o,originalFileName:n}]),t=new Me(i,s,e.ref,e.author,e.email,new Date(1e3*e.date),void 0===e.summary?"":e.summary,o,e.fileStatuses||[],e.status,n,void 0,void 0,e.parentShas),a.set(e.ref,t)}return void 0!==n&&(n.previousSha=t.sha,t.nextSha=t.sha!==n.sha?n.sha:n.nextSha,i===Re.File&&(n.previousFileName=t.originalFileName||t.fileName,t.nextFileName=n.originalFileName||n.fileName)),t}static parseFileName(e){if(void 0===e.fileName)return;const t=e.fileName.indexOf("\t")+1;if(t>0){const i=e.fileName.indexOf("\t",t)+1;i>0?(e.originalFileName=e.fileName.substring(t,i-1),e.fileName=e.fileName.substring(i)):e.fileName=e.fileName.substring(t)}}}const Ct=/^(.*)\t(.*)\s\((.*)\)$/gm,yt=/^(?:(git:\/\/)(.*?)\/|(https?:\/\/)(?:.*?@)?(.*?)\/|git@(.*):|(ssh:\/\/)(?:.*@)?(.*?)(?::.*?)?\/|(?:.*?@)(.*?):)(.*)$/;class xt{static parse(e,t,i){if(!e)return[];const s=[],o=Object.create(null);let a=null;do{if(null==(a=Ct.exec(e)))break;const r=(" "+a[2]).substr(1),[n,l,c]=this.parseGitUrl(r),h=`${l}/${c}`;let d=o[h];void 0===d?(d=new je(t,(" "+a[1]).substr(1),n,l,c,i(l,c),[{url:r,type:(" "+a[3]).substr(1)}]),s.push(d),o[h]=d):d.types.push({url:r,type:(" "+a[3]).substr(1)})}while(null!=a);return s.length?s:[]}static parseGitUrl(e){const t=yt.exec(e);return null==t?["","",""]:[t[1]||t[3]||t[6],t[2]||t[4]||t[5]||t[7]||t[8],t[9].replace(/\.git\/?$/,"")]}}const $t={};class St{static parse(e,t){if(!e)return;const i=ae.lines(e+"</f>");let s=i.next();if(s.done)return;void 0!==t&&(t=ae.normalizePath(t));const o=new Map;let a,r=$t,n=void 0;for(;!(s=i.next()).done;)switch(a=(n=s.value).charCodeAt(1)){case 114:r={ref:n.substring(4)};break;case 100:r.date=n.substring(4);break;case 108:r.stashName=n.substring(4);break;case 115:for(;!(s=i.next()).done&&"</s>"!==(n=s.value);)void 0===r.summary?r.summary=n:r.summary+=`\n${n}`;void 0!==r.summary&&(r.summary=r.summary.slice(0,-1));break;case 102:if(!(s=i.next()).done&&"</f>"!==s.value){for(;!(s=i.next()).done&&"</f>"!==(n=s.value);){if(n.startsWith("warning:"))continue;const e={status:n[0],fileName:n.substring(1),originalFileName:void 0};_t.parseFileName(e),e.fileName&&(void 0===r.fileStatuses&&(r.fileStatuses=[]),r.fileStatuses.push(e))}void 0!==r.fileStatuses&&(r.fileNames=G.filterMap(r.fileStatuses,e=>e.fileName?e.fileName:void 0).join(", "))}let e=o.get(r.ref);e=St.parseEntry(r,e,t,o)}return{repoPath:t,commits:o}}static parseEntry(e,t,i,s){return void 0===t&&(t=new mt(Re.Stash,e.stashName,i,e.ref,new Date(1e3*e.date),void 0===e.summary?"":e.summary,e.fileNames,e.fileStatuses||[])),s.set(e.ref,t),t}}const kt=/(?:ahead ([0-9]+))/,Dt=/(?:behind ([0-9]+))/;class Ft{static parse(e,t,i){if(!e)return;const s=e.split("\n").filter(e=>!!e);return 0!==s.length?i<2?this.parseV1(s,t):this.parseV2(s,t):void 0}static parseV1(e,t){let i;const s=[],o={ahead:0,behind:0};let a,r=-1;for(;++r<e.length;){const n=e[r];if(n.startsWith("##")){const e=n.split(" ");if([i,a]=e[1].split("..."),e.length>2){const t=e.slice(2).join(" "),i=kt.exec(t);o.ahead=null==i?0:+i[1]||0;const s=Dt.exec(t);o.behind=null==s?0:+s[1]||0}}else{const e=n.substring(0,2),i=n.substring(3);if("R"===e[0]){const[o,a]=i.replace(/\"/g,"").split("->");s.push(this.parseStatusFile(t,e,a.trim(),o.trim()))}else s.push(this.parseStatusFile(t,e,i))}}return new ye(ae.normalizePath(t),i||"","",s,o,a)}static parseV2(e,t){let i;const s=[];let o;const a={ahead:0,behind:0};let r,n=-1;for(;++n<e.length;){const l=e[n];if(l.startsWith("#")){const e=l.split(" ");switch(e[1]){case"branch.oid":o=e[2];break;case"branch.head":i=e[2];break;case"branch.upstream":r=e[2];break;case"branch.ab":a.ahead=+e[2].substring(1),a.behind=+e[3].substring(1)}}else{const e=l.split(" ");switch(e[0][0]){case"1":s.push(this.parseStatusFile(t,e[1],e.slice(8).join(" ")));break;case"2":const i=e.slice(9).join(" ").split("\t");s.push(this.parseStatusFile(t,e[1],i[0],i[1]));break;case"u":s.push(this.parseStatusFile(t,e[1],e.slice(10).join(" ")));break;case"?":s.push(this.parseStatusFile(t," ?",e.slice(1).join(" ")))}}}return new ye(ae.normalizePath(t),i||"",o||"",s,a,r)}static parseStatusFile(e,t,i,s){let o="."!==t[0]?t[0].trim():void 0;""!==o&&null!==o||(o=void 0);let a=void 0;return t.length>1&&(""!==(a="."!==t[1]?t[1].trim():void 0)&&null!==a||(a=void 0)),new xe(e,o,a,i,s)}}const Pt=/^(.+?)(?:$|(?:\s+)(.*)$)/gm;class Tt{static parse(e,t){if(!e)return;const i=[];let s=null;do{if(null==(s=Pt.exec(e)))break;i.push(new ut(t,(" "+s[1]).substr(1),void 0===s[2]?void 0:(" "+s[2]).substr(1)))}while(null!=s);return i.length?i:void 0}}let Rt;const Et=["blame","--root","--incremental"],Bt=["log","--name-status",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3ca%x3e %an","%x3ce%x3e %ae","%x3cd%x3e %at","%x3cp%x3e %P","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],Nt=["stash","list","--name-status","-M",`--format=${["%x3c%x2ff%x3e","%x3cr%x3e %H","%x3cd%x3e %at","%x3cl%x3e %gd","%x3cs%x3e","%B","%x3c%x2fs%x3e","%x3cf%x3e"].join("%n")}`],At={badRevision:/bad revision \'.*?\'/i},Ot={notARepository:/Not a git repository/i,outsideRepository:/is outside repository/i,noPath:/no such path/i,noCommits:/does not have any commits/i,notFound:/Path \'.*?\' does not exist in/i,foundButNotInRevision:/Path \'.*?\' exists on disk, but not in/i,headNotABranch:/HEAD does not point to a branch/i,noUpstream:/no upstream configured for branch \'(.*?)\'/i,unknownRevision:/ambiguous argument \'.*?\': unknown revision or path not in the working tree|not stored as a remote-tracking branch/i};async function Lt(e,...t){try{return await It(e,...t)}catch(i){return Mt(i,e,...t)}}const Ut=new Map;async function It(e,...t){const i=process.hrtime(),{correlationKey:s}=e,o=L.__rest(e,["correlationKey"]),a=e.encoding||"utf8",r=Object.assign({},o,{encoding:"utf8"===a?"utf8":"binary",env:Object.assign({},e.env||process.env,{GCM_INTERACTIVE:"NEVER",GCM_PRESERVE_CREDS:"TRUE",LC_ALL:"C"})}),n=`git ${t.join(" ")}`,l=`(${r.cwd}${void 0!==s?s:""}): ${n}`;let c,h,d=Ut.get(l);void 0===d?(H.log(`Running${l}`),t.splice(0,0,"-c","core.quotepath=false","-c","color.ui=false"),d=de(Rt.path,t,r),Ut.set(l,d)):H.log(`Awaiting${l}`);try{c=await d}catch(e){throw h=e,e}finally{Ut.delete(l);const e=process.hrtime(i),t=`${void 0===h?"Completed":"FAILED"} in ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`;H.log(`${void 0===h?"Completed":"FAILED"}${l} ${t}`),H.logGitCommand(`${n} ${t}`,r.cwd,h)}return"utf8"===a||"binary"===a?c:I.decode(Buffer.from(c,"binary"),a)}function Mt(e,t,...i){const s=e&&e.toString();if(s)for(const e of j.values(Ot))if(e.test(s))return H.warn("git",...i,`  cwd='${t.cwd}'\n\n  `,s.replace(/\r?\n|\r/g," ")),"";throw H.error(e,"git",...i,`  cwd='${t.cwd}'\n\n  `),e}class Wt{static gitInfo(){return Rt}static getEncoding(e){return void 0!==e&&I.encodingExists(e)?e:"utf8"}static async getGitInfo(e){const t=process.hrtime();Rt=await ge(e);const i=process.hrtime(t);return H.log(`Git found: ${Rt.version} @ ${"git"===Rt.path?"PATH":Rt.path} in ${1e3*i[0]+Math.floor(i[1]/1e6)} ms`),Rt}static async getVersionedFile(e,t,s){const o=await Wt.show(e,t,s,{encoding:"binary"});if(void 0===o)return;Wt.isStagedUncommitted(s)&&(s="");const a=ae.truncate(ae.sanitizeForFileSystem(Wt.isSha(s)?Wt.shortenSha(s):s),50,""),r=y.extname(t),n=await Promise.resolve().then(i.t.bind(null,13,7));return new Promise((i,l)=>{n.file({prefix:`${y.basename(t,r)}-${a}__`,postfix:r},(a,r,n,c)=>{a?l(a):(H.log(`getVersionedFile[${r}]('${e}', '${t}', ${s})`),U.appendFile(r,o,{encoding:"binary"},e=>{if(e)return void l(e);U.chmod(r,33060,e=>{i(r)})}))})})}static isResolveRequired(e){return Wt.isSha(e)&&!Wt.shaStrictRegex.test(e)}static isSha(e){return Wt.shaRegex.test(e)}static isStagedUncommitted(e){return void 0!==e&&Wt.stagedUncommittedRegex.test(e)}static isUncommitted(e){return void 0!==e&&Wt.uncommittedRegex.test(e)}static shortenSha(e,t={}){if(t=Object.assign({stagedUncommitted:"index",uncommitted:"working",working:""},t),""===e)return t.working;if(Wt.isStagedUncommitted(e))return t.stagedUncommitted;if(Wt.isUncommitted(e))return t.uncommitted;const i=e.indexOf("^");if(i>6){const t=e.substring(i).substring(0,5);return`${e.substring(0,8-t.length)}${t}`}return e.substring(0,8)}static splitPath(e,t,i=!0){if(t){e=ae.normalizePath(e);const i=((t=ae.normalizePath(t)).endsWith("/")?t:`${t}/`).toLowerCase();e.toLowerCase().startsWith(i)&&(e=e.substring(i.length))}else t=ae.normalizePath(i?y.dirname(e):t),e=ae.normalizePath(i?y.basename(e):e);return[e,t]}static validateVersion(e,t){const[i,s]=Rt.version.split(".");return parseInt(i,10)>=e&&parseInt(s,10)>=t}static async blame(e,t,i,s={}){const[o,a]=Wt.splitPath(t,e),r=[...Et];let n;return s.ignoreWhitespace&&r.push("-w"),null!=s.startLine&&null!=s.endLine&&r.push(`-L ${s.startLine},${s.endLine}`),null!=s.args&&r.push(...s.args),i&&(Wt.isStagedUncommitted(i)?(r.push("--contents","-"),n=await Wt.show(e,t,":")):r.push(i)),Lt({cwd:a,stdin:n},...r,"--",o)}static async blame_contents(e,t,i,s={}){const[o,a]=Wt.splitPath(t,e),r=[...Et];return s.ignoreWhitespace&&r.push("-w"),null!=s.startLine&&null!=s.endLine&&r.push(`-L ${s.startLine},${s.endLine}`),null!=s.args&&r.push(...s.args),r.push("--contents","-"),Lt({cwd:a,stdin:i,correlationKey:s.correlationKey},...r,"--",o)}static branch(e,t={all:!1}){const i=["-c","color.branch=false","branch","-vv"];return t.all&&i.push("-a"),Lt({cwd:e},...i)}static branch_contains(e,t,i={remote:!1}){const s=["-c","color.branch=false","branch","--contains"];return i.remote&&s.push("-r"),Lt({cwd:e},...s,t)}static checkout(e,t,i){const[s,o]=Wt.splitPath(t,e);return Lt({cwd:o},"checkout",i,"--",s)}static async config_get(e,t){try{return(await It({cwd:t||""},"config","--get",e)).trim()}catch(e){return}}static async config_getRegex(e,t){try{return(await It({cwd:t||""},"config","--get-regex",e)).trim()}catch(e){return}}static diff(e,t,i,s,o={}){const a=["-c","color.diff=false","diff","--diff-filter=M","-M","--no-ext-diff","--minimal"];return i&&a.push(Wt.isStagedUncommitted(i)?"--staged":i),s&&a.push(Wt.isStagedUncommitted(s)?"--staged":s),Lt({cwd:e,encoding:"utf8"===o.encoding?"utf8":"binary"},...a,"--",t)}static diff_nameStatus(e,t,i,s={}){const o=["-c","color.diff=false","diff","--name-status","-M","--no-ext-diff"];return s&&s.filter&&o.push(`--diff-filter=${s.filter}`),t&&o.push(t),i&&o.push(i),Lt({cwd:e},...o)}static diff_shortstat(e,t){const i=["-c","color.diff=false","diff","--shortstat","--no-ext-diff"];return t&&i.push(t),Lt({cwd:e},...i)}static difftool_dirDiff(e,t,i,s){const o=["difftool","--dir-diff",`--tool=${t}`,i];return s&&o.push(s),Lt({cwd:e},...o)}static difftool_fileDiff(e,t,i,s){const o=["difftool","--no-prompt",`--tool=${i}`];return s&&o.push("--staged"),o.push("--",t),Lt({cwd:e},...o)}static log(e,t){const i=["-c","diff.renameLimit=0",...Bt,"--full-history","-M","-m"];return t.maxCount&&!t.reverse&&i.push(`-n${t.maxCount}`),t.ref&&!Wt.isStagedUncommitted(t.ref)&&(t.reverse?i.push("--reverse","--ancestry-path",`${t.ref}..HEAD`):i.push(t.ref)),Lt({cwd:e},...i,"--")}static log_file(e,t,i={renames:!0,reverse:!1}){const[s,o]=Wt.splitPath(t,e),a=[...Bt];return i.maxCount&&!i.reverse&&a.push(`-n${i.maxCount}`),i.renames&&a.push("--follow"),i.ref&&!Wt.isStagedUncommitted(i.ref)&&(i.reverse?a.push("--reverse","--ancestry-path",`${i.ref}..HEAD`):a.push(i.ref)),null!=i.startLine&&null!=i.endLine&&a.push(`-L ${i.startLine},${i.endLine}:${s}`),Lt({cwd:o},...a,"--",s)}static async log_recent(e,t){try{return(await It({cwd:e},"log","-M","-n1","--format=%H","--",t)).trim()}catch(e){return}}static async log_resolve(e,t,i){try{return(await It({cwd:e},"log","-M","-n1","--format=%H",i,"--",t)).trim()}catch(e){return}}static log_search(e,t=[],i={}){const s=[...Bt];return i.maxCount&&s.push(`-n${i.maxCount}`),Lt({cwd:e},...s,...t)}static log_shortstat(e,t){const i=["log","--shortstat","--oneline"];return t.ref&&!Wt.isStagedUncommitted(t.ref)&&i.push(t.ref),Lt({cwd:e},...i,"--")}static async ls_files(e,t,i={}){const s=["ls-files"];i.ref&&!Wt.isStagedUncommitted(i.ref)&&s.push(`--with-tree=${i.ref}`);try{return(await It({cwd:e},...s,t)).trim()}catch(e){return""}}static merge_base(e,t,i,s={}){const o=["merge-base"];return s.forkPoint&&o.push("--fork-point"),Lt({cwd:e},...o,t,i)}static remote(e){return Lt({cwd:e},"remote","-v")}static remote_url(e,t){return Lt({cwd:e},"remote","get-url",t)}static async revparse(e,t){try{return(await It({cwd:e},"rev-parse",t)).trim()}catch(e){return}}static async revparse_currentBranch(e){const t=["rev-parse","--abbrev-ref","--symbolic-full-name","@","@{u}"],i={cwd:e};try{return[await It(i,...t),void 0]}catch(e){const s=e&&e.toString();if(Ot.headNotABranch.test(s))try{const e=["log","-n1","--format=%H","--"],t=await It(i,...e);if(void 0===t)return;const s=t.trim();return[`(HEAD detached at ${this.shortenSha(s)})`,s]}catch(e){return}const o=Ot.noUpstream.exec(s);if(null!==o)return[o[1],void 0];if(Ot.unknownRevision.test(s))try{const e=["symbolic-ref","-q","--short","HEAD"];return[await It(i,...e),void 0]}catch(e){return}return void Mt(e,i,...t)}}static async revparse_toplevel(e){try{return(await It({cwd:e},"rev-parse","--show-toplevel")).trim()}catch(e){return}}static async show(e,t,i,s={}){const[o,a]=Wt.splitPath(t,e);if(Wt.isStagedUncommitted(i)&&(i=":"),Wt.isUncommitted(i))throw new Error(`sha=${i} is uncommitted`);const r={cwd:a,encoding:s.encoding||"utf8"},n=i.endsWith(":")?`${i}./${o}`:`${i}:./${o}`;try{return await It(r,"show",n,"--")}catch(o){const a=o&&o.toString();if(":"===i&&At.badRevision.test(a))return Wt.show(e,t,"HEAD:",s);if(At.badRevision.test(a)||Ot.notFound.test(a)||Ot.foundButNotInRevision.test(a))return;return Mt(o,r,n)}}static stash_apply(e,t,i){if(t)return Lt({cwd:e},"stash",i?"pop":"apply",t)}static stash_delete(e,t){if(t)return Lt({cwd:e},"stash","drop",t)}static stash_list(e){return Lt({cwd:e},...Nt)}static stash_push(e,t,i){const s=["stash","push","-u"];return i&&s.push("-m",i),s.splice(s.length,0,"--",...t),Lt({cwd:e},...s)}static stash_save(e,t){const i=["stash","save","-u"];return t&&i.push(t),Lt({cwd:e},...i)}static status(e,t=1){const i=t>=2?`--porcelain=v${t}`:"--porcelain";return Lt({cwd:e,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"-c","color.status=false","status",i,"--branch","-u")}static status_file(e,t,i=1){const[s,o]=Wt.splitPath(t,e),a=i>=2?`--porcelain=v${i}`:"--porcelain";return Lt({cwd:o,env:Object.assign({},process.env,{GIT_OPTIONAL_LOCKS:"0"})},"-c","color.status=false","status",a,"--",s)}static tag(e){return Lt({cwd:e},...["tag","-l","-n1"])}}Wt.shaRegex=/^[0-9a-f]{40}(\^[0-9]*?)??( -)?$/,Wt.shaStrictRegex=/^[0-9a-f]{40}$/,Wt.stagedUncommittedRegex=/^[0]{40}(\^[0-9]*?)??:$/,Wt.stagedUncommittedSha="0000000000000000000000000000000000000000:",Wt.uncommittedRegex=/^[0]{40}(\^[0-9]*?)??:??$/,Wt.uncommittedSha="0000000000000000000000000000000000000000";class Ht{constructor(e,t,i,o){this._document=e,this.key=t,this.dirty=i,this._eventDelegates=o,this._onDidBlameStateChange=new s.EventEmitter,this._disposed=!1,this._forceDirtyStateChangeOnNextDocumentChange=!1,this._hasRemotes=!1,this._isDirtyIdle=!1,this._isTracked=!1,this._blameFailed=!1,this._repo=this.initialize(e.uri)}get onDidBlameStateChange(){return this._onDidBlameStateChange.event}dispose(){this._disposed=!0,this.reset("dispose"),this._disposable&&this._disposable.dispose()}async initialize(e){if(void 0===Ts.git&&!await J.waitUntil(()=>void 0!==Ts.git,2e3))throw H.log(`TrackedDocument.initialize(${e.toString()})`,"Timed out waiting for the GitService to start"),new Error("TrackedDocument timed out waiting for the GitService to start");if(this._uri=await _e.fromUri(e),this._disposed)return;const t=await Ts.git.getRepository(this._uri);return this._disposed?void 0:(void 0!==t&&(this._disposable=t.onDidChange(this.onRepositoryChanged,this)),await this.update({initializing:!0,repo:t}),t)}onRepositoryChanged(e){e.changed(lt.Repository)&&(this.reset("repository"),this.update())}get forceDirtyStateChangeOnNextDocumentChange(){return this._forceDirtyStateChangeOnNextDocumentChange}get hasRemotes(){return this._hasRemotes}get isBlameable(){return!this._blameFailed&&this._isTracked}get isDirtyIdle(){return this._isDirtyIdle}set isDirtyIdle(e){this._isDirtyIdle=e}get isRevision(){return void 0!==this._uri&&!!this._uri.sha}get isTracked(){return this._isTracked}get lineCount(){return this._document.lineCount}get uri(){return this._uri}activate(){E(F.ActiveFileStatus,this.getStatus())}async ensureInitialized(){await this._repo}is(e){return e===this._document}reset(e){this._blameFailed=!1,this._isDirtyIdle=!1,void 0!==this.state&&(this.state=void 0,H.log(`Reset state for '${this.key}', reason=${e}`))}setBlameFailure(){const e=this.isBlameable;this._blameFailed=!0,e&&B(this._document)&&this.update({forceBlameChange:!0})}resetForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!1}setForceDirtyStateChangeOnNextDocumentChange(){this._forceDirtyStateChangeOnNextDocumentChange=!0}async update(e={}){if(this._disposed||void 0===this._uri)return this._hasRemotes=!1,void(this._isTracked=!1);this._isDirtyIdle=!1;const t=function(e){const t=s.window.activeTextEditor;return null!=t&&t.document===e?t:void 0}(this._document),i=e.forceBlameChange?void 0:this.isBlameable;this._isTracked=await Ts.git.isTracked(this._uri);let o=void 0;if(this._isTracked&&void 0===(o=e.repo)&&(o=await this._repo),this._hasRemotes=void 0!==o&&await o.hasRemotes(),void 0!==t){const s=this.isBlameable;if(E(F.ActiveFileStatus,this.getStatus()),!e.initializing&&i!==s){const e={editor:t,document:this,blameable:s};this._onDidBlameStateChange.fire(e),this._eventDelegates.onDidBlameStateChange(e)}}}getStatus(){let e="";return this.isTracked&&(e+="tracked|"),this.isBlameable&&(e+="blameable|"),this.isRevision&&(e+="revision|"),this.hasRemotes&&(e+="remotes|"),e||void 0}}class jt{constructor(){this._onDidChangeBlameState=new s.EventEmitter,this._onDidChangeDirtyState=new s.EventEmitter,this._onDidTriggerDirtyIdle=new s.EventEmitter,this._documentMap=new Map,this._disposable=s.Disposable.from(ti.onDidChange(this.onConfigurationChanged,this),s.window.onDidChangeActiveTextEditor(this.onActiveTextEditorChanged,this),s.workspace.onDidChangeTextDocument(J.debounce(this.onTextDocumentChanged,50),this),s.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),s.workspace.onDidSaveTextDocument(this.onTextDocumentSaved,this)),this.onConfigurationChanged(ti.initializingChangeEvent)}get onDidChangeBlameState(){return this._onDidChangeBlameState.event}get onDidChangeDirtyState(){return this._onDidChangeDirtyState.event}get onDidTriggerDirtyIdle(){return this._onDidTriggerDirtyIdle.event}dispose(){this._disposable&&this._disposable.dispose(),this.clear()}initialize(){this.onActiveTextEditorChanged(s.window.activeTextEditor)}onConfigurationChanged(e){const t=ti.initializing(e);if(!t&&(ti.changed(e,ti.name("blame")("ignoreWhitespace").value,null)||ti.changed(e,ti.name("advanced")("caching")("enabled").value)))for(const e of this._documentMap.values())e.reset("config");const i=ti.name("advanced")("blame")("delayAfterEdit").value;(t||ti.changed(e,i))&&(this._dirtyIdleTriggerDelay=ti.get(i),this._dirtyIdleTriggeredDebounced=void 0)}onActiveTextEditorChanged(e){if(void 0!==e&&!N(e))return;if(void 0!==this._timer&&(clearTimeout(this._timer),this._timer=void 0),void 0===e)return void(this._timer=setTimeout(()=>{this._timer=void 0,E(F.ActiveFileStatus,void 0)},250));const t=this._documentMap.get(e.document);void 0===t?this.addCore(e.document):t.activate()}onTextDocumentChanged(e){if(e.document.uri.scheme!==P.File)return;let t=this._documentMap.get(e.document);void 0===t&&(t=this.addCore(e.document)),t.reset("document");const i=e.document.isDirty,o=s.window.activeTextEditor;void 0!==this._dirtyIdleTriggeredDebounced&&(i?this._dirtyIdleTriggeredDebounced({editor:o,document:t}):this._dirtyIdleTriggeredDebounced.cancel()),(t.forceDirtyStateChangeOnNextDocumentChange||t.dirty!==i)&&(t.resetForceDirtyStateChangeOnNextDocumentChange(),t.dirty=i,void 0!==o&&o.document===e.document&&this.fireDocumentDirtyStateChanged({editor:o,document:t,dirty:t.dirty}))}onTextDocumentClosed(e){const t=this._documentMap.get(e);void 0!==t&&(t.dispose(),this._documentMap.delete(e),this._documentMap.delete(t.key))}onTextDocumentSaved(e){let t=this._documentMap.get(e);void 0===t?B(e)&&(t=this.addCore(e)):t.update({forceBlameChange:!0})}add(e){return this._add(e)}clear(){for(const e of this._documentMap.values())e.dispose();this._documentMap.clear()}get(e){return this._get(e)}async getOrAdd(e){let t=await this._get(e);return void 0===t&&(t=await this._add(e)),t}has(e){return("string"==typeof e||e instanceof s.Uri)&&(e=_e.toKey(e)),this._documentMap.has(e)}async _add(e){if(e instanceof _e)try{e=await s.workspace.openTextDocument(e.fileUri({useVersionedPath:!0}))}catch(t){const i=t.toString();if(i.includes("File seems to be binary and cannot be opened as text"))e=new Vt(e);else{if(!i.includes("File not found"))throw t;e=new zt(e)}}else e instanceof s.Uri&&(e=await s.workspace.openTextDocument(e));const t=await this.addCore(e);return await t.ensureInitialized(),t}async _get(e){e instanceof _e?e=_e.toKey(e.fileUri({useVersionedPath:!0})):("string"==typeof e||e instanceof s.Uri)&&(e=_e.toKey(e));const t=this._documentMap.get(e);if(void 0!==t)return await t.ensureInitialized(),t}addCore(e){const t=_e.toKey(e.uri),i=new Ht(e,t,!1,{onDidBlameStateChange:e=>this._onDidChangeBlameState.fire(e)});return this._documentMap.set(e,i),this._documentMap.set(t,i),i}fireDocumentDirtyStateChanged(e){if(e.dirty)return setImmediate(async()=>{void 0!==this._dirtyStateChangedDebounced&&this._dirtyStateChangedDebounced.cancel(),s.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))}),void(this._dirtyIdleTriggerDelay>0&&(void 0===this._dirtyIdleTriggeredDebounced&&(this._dirtyIdleTriggeredDebounced=J.debounce(async e=>{void 0!==this._dirtyIdleTriggeredDebounced&&this._dirtyIdleTriggeredDebounced.pending()||(await e.document.ensureInitialized(),e.document.isDirtyIdle=!0,this._onDidTriggerDirtyIdle.fire(e))},this._dirtyIdleTriggerDelay,{track:!0})),this._dirtyIdleTriggeredDebounced({editor:e.editor,document:e.document})));void 0===this._dirtyStateChangedDebounced&&(this._dirtyStateChangedDebounced=J.debounce(async e=>{s.window.activeTextEditor===e.editor&&(await e.document.ensureInitialized(),this._onDidChangeDirtyState.fire(e))},250)),this._dirtyStateChangedDebounced(e)}}class Gt{constructor(e){this.gitUri=e,this.uri=e.fileUri({useVersionedPath:!0}),this.eol=s.EndOfLine.LF,this.fileName=this.uri.fsPath,this.isClosed=!1,this.isDirty=!1,this.isUntitled=!1,this.languageId="",this.lineCount=0,this.version=0}getText(e){throw new Error("Method not supported.")}getWordRangeAtPosition(e,t){throw new Error("Method not supported.")}lineAt(e){throw new Error("Method not supported.")}offsetAt(e){throw new Error("Method not supported.")}positionAt(e){throw new Error("Method not supported.")}save(){throw new Error("Method not supported.")}validatePosition(e){throw new Error("Method not supported.")}validateRange(e){throw new Error("Method not supported.")}}class Vt extends Gt{}class zt extends Gt{}class Qt{constructor(e){this.key=e,this.cache=new Map}get(e){return this.cache.get(e)}set(e,t){this.cache.set(e,t)}}class qt extends jt{}const Kt={doesNotExist:/no such file or directory/i},Yt=/^user\.(name|email) (.*)$/gm;var Xt;!function(e){e.Author="author",e.ChangedLines="changed-lines",e.Changes="changes",e.Files="files",e.Message="message",e.Sha="sha"}(Xt||(Xt={}));class Zt{constructor(){this._onDidChangeRepositories=new s.EventEmitter,this._suspended=!1,this._userMapCache=new Map,this._repositoryTree=oe.forPaths(),this._trackedCache=new Map,this._versionedUriCache=new Map,this._disposable=s.Disposable.from(s.window.onDidChangeWindowState(this.onWindowStateChanged,this),s.workspace.onDidChangeWorkspaceFolders(this.onWorkspaceFoldersChanged,this),ti.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ti.initializingChangeEvent),this._repositoriesLoadingPromise=this.onWorkspaceFoldersChanged()}get onDidChangeRepositories(){return this._onDidChangeRepositories.event}dispose(){this._repositoryTree.forEach(e=>e.dispose()),this._trackedCache.clear(),this._versionedUriCache.clear(),this._disposable&&this._disposable.dispose()}get UseCaching(){return Ts.config.advanced.caching.enabled}onAnyRepositoryChanged(e,t){this._trackedCache.clear(),t===lt.Config&&this._userMapCache.delete(e.path),t===lt.Closed&&setImmediate(async()=>{await this.updateContext(this._repositoryTree),this.fireRepositoriesChanged()})}onConfigurationChanged(e){(ti.initializing(e)||ti.changed(e,ti.name("defaultDateStyle").value)||ti.changed(e,ti.name("defaultDateFormat").value))&&Ee.reset()}onWindowStateChanged(e){e.focused?this._repositoryTree.forEach(e=>e.resume()):this._repositoryTree.forEach(e=>e.suspend()),this._suspended=!e.focused}async onWorkspaceFoldersChanged(e){let t=!1;void 0===e&&(t=!0,e={added:s.workspace.workspaceFolders||[],removed:[]},H.log(`Starting repository search in ${e.added.length} folders`));for(const t of e.added){if(t.uri.scheme!==P.File)continue;const e=await this.repositorySearch(t);for(const t of e)this._repositoryTree.set(t.path,t)}for(const t of e.removed){if(t.uri.scheme!==P.File)continue;const e=t.uri.fsPath,i=this._repositoryTree.findSuperstr(e),s=void 0!==i?[...ee.map(i.entries(),([t,i])=>[t,y.join(e,i)])]:[],o=this._repositoryTree.get(e);void 0!==o&&s.push([o,e]);for(const[e,t]of s)this._repositoryTree.delete(t),e.dispose()}await this.updateContext(this._repositoryTree),t||setImmediate(()=>this.fireRepositoriesChanged())}async repositorySearch(e){const t=e.uri,i=ti.get(ti.name("advanced")("repositorySearchDepth").value,t);H.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' ...`);const o=process.hrtime(),a=[],r=this.onAnyRepositoryChanged.bind(this),n=await this.getRepoPathCore(t.fsPath,!0);if(void 0!==n&&(H.log(`Repository found in '${n}'`),a.push(new dt(e,n,!0,r,this._suspended))),i<=0){const e=process.hrtime(o);return H.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*e[0]+Math.floor(e[1]/1e6)} ms`),a}let l=Object.assign({},s.workspace.getConfiguration("files",t).get("exclude",{}),s.workspace.getConfiguration("search",t).get("exclude",{}));let c;l=[...ee.filterMap(j.entries(l),([e,t])=>{if(t)return e.startsWith("**/")?e.substring(3):e})].reduce((e,t)=>(e[t]=!0,e),Object.create(null));try{c=await this.repositorySearchCore(t.fsPath,i,l)}catch(e){return Kt.doesNotExist.test(e.message||"")?H.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' FAILED${e.message?` (${e.message})`:""}`):H.error(e,`Searching for repositories (depth=${i}) in '${t.fsPath}' FAILED`),a}for(let t of c){if(t=y.dirname(t),ae.normalizePath(t)===n)continue;const i=await this.getRepoPathCore(t,!0);void 0!==i&&(H.log(`Repository found in '${i}'`),a.push(new dt(e,i,!1,r,this._suspended)))}const h=process.hrtime(o);return H.log(`Searching for repositories (depth=${i}) in '${t.fsPath}' took ${1e3*h[0]+Math.floor(h[1]/1e6)} ms`),a}async repositorySearchCore(e,t,i,s=[]){return new Promise((o,a)=>{U.readdir(e,async(r,n)=>{if(null!=r)return void a(r);if(0===n.length)return void o(s);const l=[],c=n.map(t=>{const o=y.resolve(e,t);return new Promise((e,a)=>{U.stat(o,(a,r)=>{".git"===t?s.push(o):null==a&&!0!==i[t]&&null!=r&&r.isDirectory()&&l.push(o),e()})})});if(await Promise.all(c),t-- >0)for(const e of l)await this.repositorySearchCore(e,t,i,s);o(s)})})}async updateContext(e){const t=e.any();await E(F.Enabled,t);let i=!1;if(t)for(const t of e.values())if(i=await t.hasRemotes())break;if(await E(F.HasRemotes,i),!t){const e=s.workspace.createFileSystemWatcher("**/.git",!1,!0,!0),t=s.Disposable.from(e,e.onDidCreate(async e=>{const i=s.workspace.getWorkspaceFolder(e);if(void 0===i)return;const o=await this.repositorySearch(i);if(0!==o.length){t.dispose();for(const e of o)this._repositoryTree.set(e.path,e);await this.updateContext(this._repositoryTree),setImmediate(()=>this.fireRepositoriesChanged())}},this))}}fireRepositoriesChanged(){this._onDidChangeRepositories.fire()}checkoutFile(e,t){return t=t||e.sha,H.log(`checkoutFile('${e.repoPath}', '${e.fsPath}', '${t}')`),Wt.checkout(e.repoPath,e.fsPath,t)}async fileExists(e,t,i={ensureCase:!1}){const s=y.resolve(e,t),o=await new Promise((e,t)=>U.exists(s,e));if(!i.ensureCase||!o)return o;const a=y.normalize(e);return this.fileExistsWithCase(s,a,a.length)}async fileExistsWithCase(e,t,i){const s=y.dirname(e);return!(s.length<i)&&(s===t||-1!==(await new Promise((e,t)=>U.readdir(s,(i,s)=>{i?t(i):e(s)}))).indexOf(y.basename(e))&&this.fileExistsWithCase(s,t,i))}async findNextCommit(e,t,i){let s=await this.getLogForFile(e,t,{maxCount:1,ref:i,renames:!0,reverse:!0}),o=s&&ee.first(s.commits.values());if(o)return o;const a=await this.findNextFileName(e,t,i);return a&&(o=(s=await this.getLogForFile(e,a,{maxCount:1,ref:i,renames:!0,reverse:!0}))&&ee.first(s.commits.values())),o}async findNextFileName(e,t,i){return[t,e]=Wt.splitPath(t,e),await this.fileExists(e,t,{ensureCase:!0})?t:await this.findNextFileNameCore(e,t,i)}async findNextFileNameCore(e,t,i){if(void 0===i&&void 0===(i=await this.getRecentShaForFile(e,t)))return;const s=await this.getLog(e,{maxCount:1,ref:i});if(void 0===s)return;const o=ee.first(s.commits.values()).fileStatuses.find(e=>e.originalFileName===t);return void 0!==o?o.fileName:void 0}async findWorkingFileName(e,t,i){let s;if("string"==typeof e)s=e,void 0===t?(t=await this.getRepoPath(s,{ref:i}),[s,t]=Wt.splitPath(s,t)):s=ae.normalizePath(y.relative(t,s));else{const i=e;if(t=i.repoPath,i.workingFileName&&await this.fileExists(t,i.workingFileName,{ensureCase:!0}))return[i.workingFileName,t];s=i.fileName}for(;;){if(await this.fileExists(t,s,{ensureCase:!0}))return[s,t];if(void 0===(s=await this.findNextFileNameCore(t,s)))return[void 0,void 0]}}async getActiveRepoPath(e){let t;if(null!=(e=e||s.window.activeTextEditor)){const i=await Ts.tracker.getOrAdd(e.document.uri);void 0!==i&&(t=i.uri.repoPath)}return null!=t?t:this.getHighlanderRepoPath()}getHighlanderRepoPath(){const e=this._repositoryTree.highlander();if(void 0===e)return;const[t]=e;return t.path}async getBlameForFile(e){let t="blame";void 0!==e.sha&&(t+=`:${e.sha}`);const i=await Ts.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==i.state){const s=i.state.get(t);if(void 0!==s)return H.log(`getBlameForFile[Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),s.item}H.log(`getBlameForFile[Not Cached(${t})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===i.state&&(i.state=new Qt(i.key))}else H.log(`getBlameForFile('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const s=this.getBlameForFileCore(e,i,t);return void 0!==i.state&&(H.log(`Add blame cache for '${i.state.key}:${t}'`),i.state.set(t,{item:s})),s}async getBlameForFileCore(e,t,i){if(!await this.isTracked(e))return H.log(`Skipping blame; '${e.fsPath}' is not tracked`),Zt.emptyPromise;const[s,o]=Wt.splitPath(e.fsPath,e.repoPath,!1);try{const a=await Wt.blame(o,s,e.sha,{args:Ts.config.advanced.blame.customArguments,ignoreWhitespace:Ts.config.blame.ignoreWhitespace});return gt.parse(a,o,s,await this.getCurrentUser(o))}catch(e){if(void 0!==t.state){const s=e&&e.toString();return H.log(`Replace blame cache with empty promise for '${t.state.key}:${i}'`),t.state.set(i,{item:Zt.emptyPromise,errorMessage:s}),t.setBlameFailure(),Zt.emptyPromise}return}}async getBlameForFileContents(e,t){const i=`blame:${ae.sha1(t)}`,s=await Ts.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==s.state){const t=s.state.get(i);if(void 0!==t)return H.log(`getBlameForFileContents[Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),t.item}H.log(`getBlameForFileContents[Not Cached(${i})]('${e.repoPath}', '${e.fsPath}', '${e.sha}')`),void 0===s.state&&(s.state=new Qt(s.key))}else H.log(`getBlameForFileContents('${e.repoPath}', '${e.fsPath}', '${e.sha}')`);const o=this.getBlameForFileContentsCore(e,t,s,i);return void 0!==s.state&&(H.log(`Add blame cache for '${s.state.key}:${i}'`),s.state.set(i,{item:o})),o}async getBlameForFileContentsCore(e,t,i,s){if(!await this.isTracked(e))return H.log(`Skipping blame; '${e.fsPath}' is not tracked`),Zt.emptyPromise;const[o,a]=Wt.splitPath(e.fsPath,e.repoPath,!1);try{const e=await Wt.blame_contents(a,o,t,{args:Ts.config.advanced.blame.customArguments,correlationKey:`:${s}`,ignoreWhitespace:Ts.config.blame.ignoreWhitespace});return gt.parse(e,a,o,await this.getCurrentUser(a))}catch(e){if(void 0!==i.state){const t=e&&e.toString();return H.log(`Replace blame cache with empty promise for '${i.state.key}:${s}'`),i.state.set(s,{item:Zt.emptyPromise,errorMessage:t}),i.setBlameFailure(),Zt.emptyPromise}return}}async getBlameForLine(e,t,i={}){if(H.log(`getBlameForLine('${e.repoPath}', '${e.fsPath}', '${e.sha}', ${t})`),!i.skipCache&&this.UseCaching){const i=await this.getBlameForFile(e);if(void 0===i)return;let s=i.lines[t];if(void 0===s){if(i.lines.length!==t)return;s=i.lines[t-1]}const o=i.commits.get(s.sha);if(void 0===o)return;return{author:Object.assign({},i.authors.get(o.author),{lineCount:o.lines.length}),commit:o,line:s}}const s=t+1,o=e.fsPath;try{const i=await Wt.blame(e.repoPath,o,e.sha,{args:Ts.config.advanced.blame.customArguments,ignoreWhitespace:Ts.config.blame.ignoreWhitespace,startLine:s,endLine:s}),a=gt.parse(i,e.repoPath,o,await this.getCurrentUser(e.repoPath));if(void 0===a)return;return{author:ee.first(a.authors.values()),commit:ee.first(a.commits.values()),line:a.lines[t]}}catch(e){return}}async getBlameForLineContents(e,t,i,s={}){if(H.log(`getBlameForLineContents('${e.repoPath}', '${e.fsPath}', ${t})`),!s.skipCache&&this.UseCaching){const s=await this.getBlameForFileContents(e,i);if(void 0===s)return;let o=s.lines[t];if(void 0===o){if(s.lines.length!==t)return;o=s.lines[t-1]}const a=s.commits.get(o.sha);if(void 0===a)return;return{author:Object.assign({},s.authors.get(a.author),{lineCount:a.lines.length}),commit:a,line:o}}const o=t+1,a=e.fsPath;try{const s=await Wt.blame_contents(e.repoPath,a,i,{args:Ts.config.advanced.blame.customArguments,ignoreWhitespace:Ts.config.blame.ignoreWhitespace,startLine:o,endLine:o}),r=await this.getCurrentUser(e.repoPath),n=gt.parse(s,e.repoPath,a,r);if(void 0===n)return;return{author:ee.first(n.authors.values()),commit:ee.first(n.commits.values()),line:n.lines[t]}}catch(e){return}}async getBlameForRange(e,t){H.log(`getBlameForRange('${e.repoPath}', '${e.fsPath}', '${e.sha}', [${t.start.line}, ${t.end.line}])`);const i=await this.getBlameForFile(e);if(void 0!==i)return this.getBlameForRangeSync(i,e,t)}getBlameForRangeSync(e,t,i){if(H.log(`getBlameForRangeSync('${t.repoPath}', '${t.fsPath}', '${t.sha}', [${i.start.line}, ${i.end.line}])`),0===e.lines.length)return Object.assign({allLines:e.lines},e);if(0===i.start.line&&i.end.line===e.lines.length-1)return Object.assign({allLines:e.lines},e);const s=e.lines.slice(i.start.line,i.end.line+1),o=new Set(s.map(e=>e.sha)),a=new Map,r=new Map;for(const t of e.commits.values()){if(!o.has(t.sha))continue;const e=t.with({lines:t.lines.filter(e=>e.line>=i.start.line&&e.line<=i.end.line)});r.set(t.sha,e);let s=a.get(e.author);void 0===s&&(s={name:e.author,lineCount:0},a.set(s.name,s)),s.lineCount+=e.lines.length}return{authors:new Map([...a.entries()].sort((e,t)=>t[1].lineCount-e[1].lineCount)),commits:r,lines:s,allLines:e.lines}}async getBranch(e){if(void 0===e)return;H.log(`getBranch('${e}')`);const t=await Wt.revparse_currentBranch(e);if(void 0===t)return;const i=t[0].split("\n");return new Ce(e,i[0],!0,t[1],i[1])}async getBranches(e){if(void 0===e)return[];H.log(`getBranches('${e}')`);const t=await Wt.branch(e,{all:!0});if(""===t){const t=await this.getBranch(e);return void 0!==t?[t]:[]}return vt.parse(t,e)||[]}async getChangedFilesCount(e,t){H.log(`getChangedFilesCount('${e}', '${t}')`);const i=await Wt.diff_shortstat(e,t);return Ue.parseShortStat(i)}async getConfig(e,t){return H.log(`getConfig('${e}', '${t}')`),await Wt.config_get(e,t)}async getCurrentUser(e){let t=this._userMapCache.get(e);if(null!=t)return t;if(null===t)return;const i=await Wt.config_getRegex("user.(name|email)",e);if(!i)return void this._userMapCache.set(e,null);t={name:void 0,email:void 0};let s=null;do{if(null==(s=Yt.exec(i)))break;t[s[1]]=(" "+s[2]).substr(1)}while(null!=s);return this._userMapCache.set(e,t),t}async getDiffForFile(e,t,i){void 0!==t&&void 0===i&&void 0!==e.sha&&(i=e.sha);let s="diff";void 0!==t&&(s+=`:${t}`),void 0!==i&&(s+=`:${i}`);const o=await Ts.tracker.getOrAdd(e);if(this.UseCaching){if(void 0!==o.state){const a=o.state.get(s);if(void 0!==a)return H.log(`getDiffForFile[Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),a.item}H.log(`getDiffForFile[Not Cached(${s})]('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`),void 0===o.state&&(o.state=new Qt(o.key))}else H.log(`getDiffForFile('${e.repoPath}', '${e.fsPath}', '${t}', '${i}')`);const a=this.getDiffForFileCore(e.repoPath,e.fsPath,t,i,{encoding:Zt.getEncoding(e)},o,s);return void 0!==o.state&&(H.log(`Add log cache for '${o.state.key}:${s}'`),o.state.set(s,{item:a})),a}async getDiffForFileCore(e,t,i,s,o,a,r){const[n,l]=Wt.splitPath(t,e,!1);try{const e=await Wt.diff(l,n,i,s,o);return Ue.parse(e)}catch(e){if(void 0!==a.state){const t=e&&e.toString();return H.log(`Replace diff cache with empty promise for '${a.state.key}:${r}'`),a.state.set(r,{item:Zt.emptyPromise,errorMessage:t}),Zt.emptyPromise}return}}async getDiffForLine(e,t,i,s){H.log(`getDiffForLine('${e.repoPath}', '${e.fsPath}', ${t}, '${i}', '${s}')`);try{const o=await this.getDiffForFile(e,i,s);if(void 0===o)return;const a=o.chunks.find(e=>e.currentPosition.start<=t&&e.currentPosition.end>=t);if(void 0===a)return;return a.lines[t-a.currentPosition.start+1]}catch(e){return}}async getDiffStatus(e,t,i,s={}){H.log(`getDiffStatus('${e}', '${t}', '${i}', ${s.filter})`);try{const o=await Wt.diff_nameStatus(e,t,i,s);return Ue.parseNameStatus(o,e)}catch(e){return}}async getRecentLogCommitForFile(e,t){return this.getLogCommitForFile(e,t,void 0)}async getRecentShaForFile(e,t){return await Wt.log_recent(e,t)}async getLogCommit(e,t){H.log(`getLogCommit('${e}', '${t}'`);const i=await this.getLog(e,{maxCount:2,ref:t});if(void 0!==i)return i.commits.get(t)}async getLogCommitForFile(e,t,i={}){H.log(`getFileLogCommit('${e}', '${t}', '${i.ref}', ${i.firstIfNotFound})`);const s=await this.getLogForFile(e,t,{maxCount:2,ref:i.ref});if(void 0===s)return;const o=i.ref&&s.commits.get(i.ref);return void 0!==o||i.firstIfNotFound||!i.ref||Wt.isResolveRequired(i.ref)?o||ee.first(s.commits.values()):void 0}async getLog(e,t={}){t=Object.assign({reverse:!1},t),H.log(`getLog('${e}', '${t.ref}', ${t.maxCount}, ${t.reverse})`);const i=null==t.maxCount?Ts.config.advanced.maxListItems||0:t.maxCount;try{const s=await Wt.log(e,{maxCount:i,ref:t.ref,reverse:t.reverse}),o=_t.parse(s,Re.Branch,e,void 0,t.ref,await this.getCurrentUser(e),i,t.reverse,void 0);if(void 0!==o){const i=Object.assign({},t);o.query=(t=>this.getLog(e,Object.assign({},i,{maxCount:t})))}return o}catch(e){return}}async getLogForSearch(e,t,i,s={}){H.log(`getLogForSearch('${e}', '${t}', '${i}', ${s.maxCount})`);let o=null==s.maxCount?Ts.config.advanced.maxListItems||0:s.maxCount,a=void 0;switch(i){case Xt.Author:a=["-m","-M","--all","--full-history","-i",`--author=${t}`];break;case Xt.ChangedLines:a=["-M","--all","--full-history","-i",`-G${t}`];break;case Xt.Changes:a=["-M","--all","--full-history","-i","--pickaxe-regex",`-S${t}`];break;case Xt.Files:a=["-M","--all","--full-history","-i","--",`${t}`];break;case Xt.Message:a=["-m","-M","--all","--full-history"],t&&a.push(`--grep=${t}`);break;case Xt.Sha:a=["-m","-M",t],o=1}try{const r=await Wt.log_search(e,a,{maxCount:o}),n=_t.parse(r,Re.Branch,e,void 0,void 0,await this.getCurrentUser(e),o,!1,void 0);if(void 0!==n){const o=Object.assign({},s);n.query=(s=>this.getLogForSearch(e,t,i,Object.assign({},o,{maxCount:s})))}return n}catch(e){return}}async getLogForFile(e,t,i={}){if(void 0!==e&&e===ae.normalizePath(t))throw new Error(`File name cannot match the repository path; fileName=${t}`);void 0===(i=Object.assign({reverse:!1},i)).renames&&(i.renames=Ts.config.advanced.fileHistoryFollowsRenames);let o="log";void 0!==i.ref&&(o+=`:${i.ref}`),void 0!==i.maxCount&&(o+=`:n${i.maxCount}`),i.renames&&(o+=":follow"),i.reverse&&(o+=":reverse");const a=await Ts.tracker.getOrAdd(new _e(s.Uri.file(t),{repoPath:e,sha:i.ref}));if(this.UseCaching&&void 0===i.range){if(void 0!==a.state){const s=a.state.get(o);if(void 0!==s)return H.log(`getLogForFile[Cached(${o})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),s.item;if("log"!==o){const s=a.state.get("log");if(void 0!==s){if(void 0===i.ref)return H.log(`getLogForFile[Cached(~${o})]('${e}', '${t}', '', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),s.item;H.log(`getLogForFile[? Cache(${o})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`);const a=await s.item;if(void 0!==a&&a.commits.has(i.ref))return H.log(`getLogForFile[Cached(${o})]('${e}', '${t}', '${i.ref}', ${i.maxCount}, undefined, ${i.renames}, ${i.reverse})`),s.item}}}H.log(`getLogForFile[Not Cached(${o})]('${e}', '${t}', ${i.ref}, ${i.maxCount}, undefined, ${i.reverse})`),void 0===a.state&&(a.state=new Qt(a.key))}else H.log(`getLogForFile('${e}', '${t}', ${i.ref}, ${i.maxCount}, ${i.range&&`[${i.range.start.line}, ${i.range.end.line}]`}, ${i.reverse})`);const r=this.getLogForFileCore(e,t,i,a,o);return void 0!==a.state&&void 0===i.range&&(H.log(`Add log cache for '${a.state.key}:${o}'`),a.state.set(o,{item:r})),r}async getLogForFileCore(e,t,i,s,o){if(!await this.isTracked(t,e,{ref:i.ref}))return H.log(`Skipping log; '${t}' is not tracked`),Zt.emptyPromise;const[a,r]=Wt.splitPath(t,e,!1);try{const{range:n}=i,l=L.__rest(i,["range"]),c=null==i.maxCount?Ts.config.advanced.maxListItems||0:i.maxCount,h=await Wt.log_file(r,a,Object.assign({},l,{maxCount:c,startLine:n&&n.start.line+1,endLine:n&&n.end.line+1})),d=_t.parse(h,Re.File,r,a,l.ref,await this.getCurrentUser(r),c,l.reverse,n);if(void 0!==d){const s=Object.assign({},i);d.query=(i=>this.getLogForFile(e,t,Object.assign({},s,{maxCount:i})))}return d}catch(e){if(void 0!==s.state&&void 0===i.range&&!i.reverse){const t=e&&e.toString();return H.log(`Replace log cache with empty promise for '${s.state.key}:${o}'`),s.state.set(o,{item:Zt.emptyPromise,errorMessage:t}),Zt.emptyPromise}return}}async hasRemotes(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasRemotes()}async hasTrackingBranch(e){if(void 0===e)return!1;const t=await this.getRepository(e);return void 0!==t&&t.hasTrackingBranch()}async getMergeBase(e,t,i,s={}){try{const o=await Wt.merge_base(e,t,i,s);if(void 0===o)return;return o.split("\n")[0]}catch(e){return void H.error(e,"GitService.getMergeBase")}}async getRemotes(e,t={}){if(void 0===e)return[];H.log(`getRemotes('${e}')`);const i=await this.getRepository(e),s=void 0!==i?i.getRemotes():this.getRemotesCore(e);return t.includeAll?s:(await s).filter(e=>void 0!==e.provider)}async getRemotesCore(e,t){if(void 0===e)return[];H.log(`getRemotesCore('${e}')`),t=t||nt.createMap(ti.get(ti.name("remotes").value,null));try{const i=await Wt.remote(e);return xt.parse(i,e,nt.factory(t))}catch(e){return H.error(e,"GitService.getRemotesCore"),[]}}async getRepoPath(e,t={}){if(null==e)return await this.getActiveRepoPath();if(e instanceof _e)return e.repoPath;let i=await this.getRepository(e,Object.assign({},t,{skipCacheUpdate:!0}));if(void 0!==i)return i.path;if("string"!=typeof e){const t=await Ts.git.getVersionedUri(e);if(void 0!==t)return t.repoPath}const o=await this.getRepoPathCore("string"==typeof e?e:e.fsPath,!1);if(void 0===o)return;if(void 0!==this._repositoryTree.get(o))return o;const a=this._repositoryTree.findSubstr(o);let r=void 0===a?s.workspace.getWorkspaceFolder(s.Uri.file(o)):a.folder;if(void 0===r){const e=o.split("/");r={uri:s.Uri.file(o),name:e[e.length-1],index:this._repositoryTree.count()}}return i=new dt(r,o,!1,this.onAnyRepositoryChanged.bind(this),this._suspended),this._repositoryTree.set(o,i),setImmediate(async()=>{await this.updateContext(this._repositoryTree),this.fireRepositoriesChanged()}),o}async getRepoPathCore(e,t){try{return await Wt.revparse_toplevel(t?e:y.dirname(e))}catch(e){return void H.error(e,"GitService.getRepoPathCore")}}async getRepoPathOrActive(e,t){const i=await Ts.git.getRepoPath(e);return i||Ts.git.getActiveRepoPath(t)}async getRepositories(e){const t=(await this.getRepositoryTree()).values();return void 0!==e?ee.filter(t,e):t}async getRepositoryTree(){return void 0!==this._repositoriesLoadingPromise&&(await this._repositoriesLoadingPromise,this._repositoriesLoadingPromise=void 0),this._repositoryTree}async getRepository(e,t={}){const i=await this.getRepositoryTree();let s;if("string"==typeof e){const t=i.get(e);if(void 0!==t)return t;s=e}else if(e instanceof _e){if(e.repoPath){const t=i.get(e.repoPath);if(void 0!==t)return t}s=e.fsPath}else s=e.fsPath;const o=i.findSubstr(s);if(void 0!==o&&await this.isTracked(s,o.path,t))return o}async getRepositoryCount(){return(await this.getRepositoryTree()).count()}async getStashList(e){if(void 0===e)return;H.log(`getStashList('${e}')`);const t=await Wt.stash_list(e);return St.parse(t,e)}async getStatusForFile(e,t){H.log(`getStatusForFile('${e}', '${t}')`);const i=Wt.validateVersion(2,11)?2:1,s=await Wt.status_file(e,t,i),o=Ft.parse(s,e,i);if(void 0!==o&&o.files.length)return o.files[0]}async getStatusForRepo(e){if(void 0===e)return;H.log(`getStatusForRepo('${e}')`);const t=Wt.validateVersion(2,11)?2:1,i=await Wt.status(e,t);return Ft.parse(i,e,t)}async getTags(e){if(void 0===e)return[];H.log(`getTags('${e}')`);const t=await Wt.tag(e);return Tt.parse(t,e)||[]}async getVersionedFile(e,t,i){if(H.log(`getVersionedFile('${e}', '${t}', '${i}')`),i===Zt.deletedSha)return;if(!i||Wt.isUncommitted(i)&&!Wt.isStagedUncommitted(i))return await this.fileExists(e,t)?s.Uri.file(t):void 0;const o=await Wt.getVersionedFile(e,t,i);return void 0!==o?(this._versionedUriCache.set(_e.toKey(o),new _e(s.Uri.file(t),{sha:i,repoPath:e,versionedPath:o})),s.Uri.file(o)):void 0}getVersionedFileText(e,t,i){return H.log(`getVersionedFileText('${e}', '${t}', ${i})`),Wt.show(e,t,i,{encoding:Zt.getEncoding(e,t)})}getVersionedUri(e){return this._versionedUriCache.get(_e.toKey(e))}isTrackable(e){let t;return(t="string"==typeof e?e:e.scheme)===P.File||t===P.Git||t===P.GitLensGit}async isTracked(e,t,i={}){if(i.ref===Zt.deletedSha)return!1;let s,o,a=i.ref;if("string"==typeof e)[o,t]=Wt.splitPath(e,t),s=_e.toKey(e);else{if(!this.isTrackable(e))return!1;o=e.fsPath,t=e.repoPath,a=e.sha,s=_e.toKey(o)}void 0!==a&&(s+=`:${a}`),H.log(`isTracked('${o}', '${t}'${void 0!==a?`, '${a}'`:""})`);let r=this._trackedCache.get(s);try{return void 0!==r?r=await r:(r=this.isTrackedCore(o,void 0===t?"":t,a),i.skipCacheUpdate?r=await r:(this._trackedCache.set(s,r),r=await r,this._trackedCache.set(s,r),r))}finally{H.log(`isTracked('${o}', '${t}'${void 0!==a?`, '${a}'`:""}) = ${r}`)}}async isTrackedCore(e,t,i){if(i===Zt.deletedSha)return!1;try{let s=!!await Wt.ls_files(void 0===t?"":t,e);return s||void 0===i||(s=!!await Wt.ls_files(void 0===t?"":t,e,{ref:i}))||(s=!!await Wt.ls_files(void 0===t?"":t,e,{ref:`${i}^`})),s}catch(e){return H.error(e,"GitService.isTrackedCore"),!1}}async getDiffTool(e){return await Wt.config_get("diff.guitool",e)||await Wt.config_get("diff.tool",e)}async openDiffTool(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return H.log(`openDiffTool('${e}', '${t.fsPath}', ${i}, '${s}')`),Wt.difftool_fileDiff(e,t.fsPath,s,i)}async openDirectoryDiff(e,t,i,s){if(!s&&void 0===(s=await this.getDiffTool(e)))throw new Error("No diff tool found");return H.log(`openDirectoryDiff('${e}', '${t}', '${i}', '${s}')`),Wt.difftool_dirDiff(e,s,t,i)}async resolveReference(e,t,i){return!Zt.isResolveRequired(t)||t.endsWith("^3")?t:(H.log(`resolveReference('${e}', '${t}', '${i&&i.toString()}')`),null==i?await Wt.revparse(e,t)||t:await Wt.log_resolve(e,ae.normalizePath(y.relative(e,i.fsPath)),t)||t)}stopWatchingFileSystem(){this._repositoryTree.forEach(e=>e.stopWatchingFileSystem())}stashApply(e,t,i=!1){return H.log(`stashApply('${e}', '${t}', ${i})`),Wt.stash_apply(e,t,i)}stashDelete(e,t){return H.log(`stashDelete('${e}', '${t}')`),Wt.stash_delete(e,t)}stashSave(e,t,i){if(H.log(`stashSave('${e}', '${t}', ${i})`),void 0===i)return Wt.stash_save(e,t);Zt.ensureGitVersion("2.13.2","Stashing individual files");const s=i.map(t=>Wt.splitPath(t.fsPath,e)[0]);return Wt.stash_push(e,s,t)}static getEncoding(e,t){const i="string"==typeof e?s.Uri.file(y.join(e,t)):e;return Wt.getEncoding(s.workspace.getConfiguration("files",i).get("encoding"))}static initialize(e){return Wt.getGitInfo(e)}static getGitPath(){return Wt.gitInfo().path}static getGitVersion(){return Wt.gitInfo().version}static isResolveRequired(e){return Wt.isResolveRequired(e)}static isSha(e){return Wt.isSha(e)}static isStagedUncommitted(e){return Wt.isStagedUncommitted(e)}static isUncommitted(e){return Wt.isUncommitted(e)}static shortenSha(e,t={}){if(void 0!==e)return t=Object.assign({deleted:"(deleted)",working:""},t),""===e?t.working:e===Zt.deletedSha?t.deleted:Wt.isSha(e)||Wt.isStagedUncommitted(e)?Wt.shortenSha(e,t):e}static compareGitVersion(e,t){return re.compare(re.fromString(this.getGitVersion()),re.fromString(e))}static ensureGitVersion(e,t){const i=this.getGitVersion();if(-1===re.compare(re.fromString(i),re.fromString(e)))throw new Error(`${t} requires a newer version of Git (>= ${e}) than is currently installed (${i}). Please install a more recent version of Git to use this GitLens feature.`)}}Zt.emptyPromise=Promise.resolve(void 0),Zt.deletedSha="ffffffffffffffffffffffffffffffffffffffff",Zt.stagedUncommittedSha=Wt.stagedUncommittedSha,Zt.uncommittedSha=Wt.uncommittedSha;const Jt=new Proxy({},{get:(e,t,i)=>Jt});class ei{constructor(){this._onDidChange=new s.EventEmitter,this.initializingChangeEvent={affectsConfiguration:(e,t)=>!1},this._configAffectedByMode=[`gitlens.${this.name("mode").value}`,`gitlens.${this.name("modes").value}`,`gitlens.${this.name("codeLens").value}`,`gitlens.${this.name("currentLine").value}`,`gitlens.${this.name("gitExplorer").value}`,`gitlens.${this.name("historyExplorer").value}`,`gitlens.${this.name("hovers").value}`,`gitlens.${this.name("statusBar").value}`]}static configure(e){e.subscriptions.push(s.workspace.onDidChangeConfiguration(ti.onConfigurationChanged,ti))}get onDidChange(){return this._onDidChange.event}onConfigurationChanged(e){if(!e.affectsConfiguration(x,null))return;Ts.resetConfig(),ti.changed(e,ti.name("defaultGravatarsStyle").value)&&Te.clear();const t=ti.name("keymap").value;if(ti.changed(e,t)&&E(F.KeyMap,this.get(t)),ti.changed(e,ti.name("mode").value)||ti.changed(e,ti.name("modes").value)){const t=e.affectsConfiguration;e=Object.assign({},e,{affectsConfiguration:(e,i)=>!!this._configAffectedByMode.some(t=>e.startsWith(t))||t(e,i)})}this._onDidChange.fire(e)}get(e,t,i){return void 0===i?s.workspace.getConfiguration(void 0===e?void 0:x,t).get(void 0===e?x:e):s.workspace.getConfiguration(void 0===e?void 0:x,t).get(void 0===e?x:e,i)}changed(e,t,i){return e.affectsConfiguration(`${x}.${t}`,i)}initializing(e){return e===this.initializingChangeEvent}inspect(e,t){return s.workspace.getConfiguration(void 0===e?void 0:x,t).inspect(void 0===e?x:e)}async migrate(e,t,i={}){const o=ti.inspect(e);if(void 0===o)return!1;let a=!1;return void 0!==o.globalValue&&(await this.update(t,i.migrationFn?i.migrationFn(o.globalValue):o.globalValue,s.ConfigurationTarget.Global),a=!0),void 0!==o.workspaceValue&&(await this.update(t,i.migrationFn?i.migrationFn(o.workspaceValue):o.workspaceValue,s.ConfigurationTarget.Workspace),a=!0),void 0!==o.workspaceFolderValue&&(await this.update(t,i.migrationFn?i.migrationFn(o.workspaceFolderValue):o.workspaceFolderValue,s.ConfigurationTarget.WorkspaceFolder),a=!0),a||void 0===i.fallbackValue||(await this.update(t,i.fallbackValue,s.ConfigurationTarget.Global),a=!0),a}async migrateIfMissing(e,t,i={}){const o=ti.inspect(e);if(void 0===o)return;const a=ti.inspect(t);void 0!==o.globalValue&&(void 0!==a&&void 0!==a.globalValue||await this.update(t,i.migrationFn?i.migrationFn(o.globalValue):o.globalValue,s.ConfigurationTarget.Global)),void 0!==o.workspaceValue&&(void 0!==a&&void 0!==a.workspaceValue||await this.update(t,i.migrationFn?i.migrationFn(o.workspaceValue):o.workspaceValue,s.ConfigurationTarget.Workspace)),void 0!==o.workspaceFolderValue&&(void 0!==a&&void 0!==a.workspaceFolderValue||await this.update(t,i.migrationFn?i.migrationFn(o.workspaceFolderValue):o.workspaceFolderValue,s.ConfigurationTarget.WorkspaceFolder))}name(e){return J.propOf(Jt,e)}update(e,t,i,o){return s.workspace.getConfiguration(x,i===s.ConfigurationTarget.Global?void 0:o).update(e,t,i)}async updateEffective(e,t,i=null){const o=await ti.inspect(e,i);if(void 0!==o.workspaceFolderValue){if(t===o.workspaceFolderValue)return;return await ti.update(e,t,s.ConfigurationTarget.WorkspaceFolder,i)}if(void 0!==o.workspaceValue){if(t===o.workspaceValue)return;return await ti.update(e,t,s.ConfigurationTarget.Workspace)}if(o.globalValue!==t&&(void 0!==o.globalValue||t!==o.defaultValue))return await ti.update(e,t===o.defaultValue?void 0:t,s.ConfigurationTarget.Global)}}const ti=new ei;var ii;!function(e){e.Computing="computing",e.Computed="computed"}(ii||(ii={}));class si{constructor(e,t,i,o){this.editor=e,this.trackedDocument=t,this.decoration=i,this.highlightDecoration=o,this.correlationKey=si.getCorrelationKey(this.editor),this.document=this.editor.document,this.disposable=s.Disposable.from(s.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this))}static getCorrelationKey(e){return void 0!==e?e.id:""}async dispose(){await this.clear(),this.disposable&&this.disposable.dispose()}async onTextEditorSelectionChanged(e){if(a.equals(this.document,e.textEditor&&e.textEditor.document))return this.selection(e.selections[0].active.line)}get editorId(){return void 0===this.editor||void 0===this.editor.document?"":this.editor.id}get editorUri(){if(void 0!==this.editor&&void 0!==this.editor.document)return this.editor.document.uri}clear(){if(this.status=void 0,void 0!==this.editor){if(void 0!==this.decoration)try{this.editor.setDecorations(this.decoration,[])}catch(e){}if(void 0!==this.additionalDecorations&&this.additionalDecorations.length>0){for(const e of this.additionalDecorations)try{this.editor.setDecorations(e.decoration,[])}catch(e){}this.additionalDecorations=void 0}if(void 0!==this.highlightDecoration)try{this.editor.setDecorations(this.highlightDecoration,[])}catch(e){}}}reset(e){void 0===this._resetDebounced&&(this._resetDebounced=J.debounce(this.onReset,250)),this._resetDebounced(e)}async onReset(e){void 0!==e&&(await this.clear(),this.decoration=e.decoration,this.highlightDecoration=e.highlightDecoration),await this.provideAnnotation(void 0===this.editor?void 0:this.editor.selection.active.line)}async restore(e){if(!1!==this.editor._disposed){if(this.status=ii.Computing,e===s.window.activeTextEditor&&await E(F.AnnotationStatus,this.status),this.editor=e,this.correlationKey=si.getCorrelationKey(e),this.document=e.document,void 0!==this.decorations&&this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),void 0!==this.additionalDecorations&&this.additionalDecorations.length))for(const e of this.additionalDecorations)this.editor.setDecorations(e.decoration,e.ranges);this.status=ii.Computed,e===s.window.activeTextEditor&&(await E(F.AnnotationStatus,this.status),await this.selection(e.selection.active.line))}}async provideAnnotation(e){return this.status=ii.Computing,await this.onProvideAnnotation(e)?(this.status=ii.Computed,!0):(this.status=void 0,!1)}}const oi=/^(?:(#?)([0-9a-f]{3}|[0-9a-f]{6})|((?:rgb|hsl)a?)\((-?\d+%?)[,\s]+(-?\d+%?)[,\s]+(-?\d+%?)[,\s]*(-?[\d\.]+%?)?\))$/i;function ai(e){e=e.trim();const t=oi.exec(e);if(null==t)return null;if("#"===t[1]){const e=t[2];switch(e.length){case 3:return[parseInt(e[0]+e[0],16),parseInt(e[1]+e[1],16),parseInt(e[2]+e[2],16),1];case 6:return[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16),1]}return null}switch(t[3]){case"rgb":return[parseInt(t[4],10),parseInt(t[5],10),parseInt(t[6],10),1];case"rgba":return[parseInt(t[4],10),parseInt(t[5],10),parseInt(t[6],10),parseFloat(t[7])];default:return null}}const ri="#f66a0a",ni="#0a60f6",li=/[`\>\#\*\_\-\+\.]/g,ci=`${T.ZeroWidthSpace}===`;let hi;class di{static applyHeatmap(e,t,i){const s=this.getHeatmapColor(t,i);e.renderOptions.before.borderColor=s}static getHeatmapColor(e,t){const i=t.cold?t.colors.cold:t.colors.hot,s=t.computeAge(e);if(0===s)return i;if(void 0===hi||hi.color!==i){let e=ai(i);null==e&&(e=ai(t.cold?ni:ri));const[s,o,a]=e;hi={color:i,rgb:`${s}, ${o}, ${a}`}}return`rgba(${hi.rgb}, ${(1-s/10).toFixed(2)})`}static getHoverCommandBar(e,t,i,s=0){let o=`[\`${T.MuchGreaterThan}\`](${Ho.getMarkdownCommandArgs(e)} "Open Changes") `;if(void 0!==e.previousSha){i===p.RecentChanges&&(i=p.Blame);const t=_e.toRevisionUri(e.previousSha,e.previousUri.fsPath,e.repoPath);o+=`[\`${T.SquareWithTopShadow}\`](${ta.getMarkdownCommandArgs(t,i||p.Blame,s)} "Blame Previous Revision") `}return t&&(o+=`[\`${T.ArrowUpRight}\`](${Jo.getMarkdownCommandArgs(e.sha)} "Open in Remote") `),o+=`[\`${T.MiddleEllipsis}\`](${ga.getMarkdownCommandArgs(e.sha)} "Show More Actions")`}static getHoverMessage(e,t,i,o,a=0){null===t&&(t="MMMM Do, YYYY h:mma");let r="",n="",l="",c="";if(e.isUncommitted)l=`\`${"working"===e.shortSha?"00000000":e.shortSha}\``;else{n=`\n\n${this.getHoverCommandBar(e,0!==i.length,o,a)}`,l=`[\`${e.shortSha}\`](${ua.getMarkdownCommandArgs(e.sha)} "Show Commit Details")`,r=be.fromTemplate("${message}",e);for(const e of i)if(void 0!==e.provider){r=e.provider.enrichMessage(r);break}r.replace(li,"\\$&").replace(/^===/gm,ci).replace(/\n/g,"  \n"),r=`\n\n> ${r}`}Ts.config.hovers.avatars&&(c=` &nbsp; ![](${e.getGravatarUri(Ts.config.defaultGravatarsStyle).toString()})`);const h=new s.MarkdownString(`${l}${c} &nbsp;__${e.author}__, ${e.fromNow()} &nbsp; _(${e.formatDate(t)})_ ${r}${n}`);return h.isTrusted=!0,h}static getHoverDiffMessage(e,t,i){if(void 0===i||void 0===e.previousSha)return;const o=this.getCodeDiff(i);let a;a=e.isUncommitted?void 0!==t.sha&&Zt.isStagedUncommitted(t.sha)?`[\`Changes\`](${Ho.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${T.Dash} &nbsp; [\`${e.previousShortSha}\`](${ua.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${T.ArrowLeftRightLong} _${t.shortSha}_\n${o}`:`[\`Changes\`](${Ho.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${T.Dash} &nbsp; _uncommitted changes_\n${o}`:`[\`Changes\`](${Ho.getMarkdownCommandArgs(e)} "Open Changes") &nbsp; ${T.Dash} &nbsp; [\`${e.previousShortSha}\`](${ua.getMarkdownCommandArgs(e.previousSha)} "Show Commit Details") ${T.ArrowLeftRightLong} [\`${e.shortSha}\`](${ua.getMarkdownCommandArgs(e.sha)} "Show Commit Details")\n${o}`;const r=new s.MarkdownString(a);return r.isTrusted=!0,r}static getCodeDiff(e){const t=void 0===e.previous?void 0:e.previous[0];return`\`\`\`\n-  ${void 0===t||void 0===t.line?"":t.line.trim()}\n+  ${void 0===e.line?"":e.line.trim()}\n\`\`\``}static async changesHover(e,t,i){const s=!e.isUncommitted||void 0!==i.sha&&Zt.isStagedUncommitted(i.sha)?e.previousSha:void 0,o=await Ts.git.getDiffForLine(i,t,s);return{hoverMessage:this.getHoverDiffMessage(e,i,o)}}static gutter(e,t,i,s){const o={renderOptions:{before:Object.assign({},s)}};e.isUncommitted&&(o.renderOptions.before.color=s.uncommittedColor);const a=be.fromTemplate(t,e,i);return o.renderOptions.before.contentText=ae.pad(a.replace(/ /g,T.Space),1,1),o}static gutterRenderOptions(e,t,i,o){let a=0;for(const e of j.values(o.tokenOptions))if(void 0!==e){if(null==e.truncateTo){a=-1;break}a+=e.truncateTo}a>=0&&(a+=ae.getWidth(ae.interpolate(i,void 0)))>0&&(a+=3);let r,n=void 0,l=void 0;if(t.enabled&&(n="solid",l="left"===t.location?"0 0 0 2px":"0 2px 0 0"),a>=0){const e=s.workspace.getConfiguration("editor").get("letterSpacing");r=null!=e&&0!==e?`calc(${a}ch + ${Math.round(a*e)}px)`:`${a}ch`}return{backgroundColor:new s.ThemeColor("gitlens.gutterBackgroundColor"),borderStyle:n,borderWidth:l,color:new s.ThemeColor("gitlens.gutterForegroundColor"),fontWeight:"normal",fontStyle:"normal",height:"100%",margin:"0 26px -1px 0",textDecoration:e?"overline solid rgba(0, 0, 0, .2)":"none",width:r,uncommittedColor:new s.ThemeColor("gitlens.gutterUncommittedForegroundColor")}}static heatmap(e,t,i){const s={renderOptions:{before:Object.assign({},i)}};return di.applyHeatmap(s,e.date,t),s}static heatmapRenderOptions(){return{borderStyle:"solid",borderWidth:"0 0 0 2px",contentText:T.ZeroWidthSpace,height:"100%",margin:"0 26px -1px 0"}}static trailing(e,t,i,o=!0){const a=be.fromTemplate(t,e,{truncateMessageAtNewLine:!0,dateFormat:i});return{renderOptions:{after:{backgroundColor:new s.ThemeColor("gitlens.trailingLineBackgroundColor"),color:new s.ThemeColor("gitlens.trailingLineForegroundColor"),contentText:ae.pad(a.replace(/ /g,T.Space),1,1),fontWeight:"normal",fontStyle:"normal",textDecoration:`none;${o?"":" position: absolute;"}`}}}}}class mi extends si{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri,this._blame=e.document.isDirty?Ts.git.getBlameForFileContents(this._uri,e.document.getText()):Ts.git.getBlameForFile(this._uri),e.document.isDirty&&t.setForceDirtyStateChangeOnNextDocumentChange()}clear(){this._hoverProviderDisposable&&this._hoverProviderDisposable.dispose(),super.clear()}async onReset(e){return void 0!==this.editor&&(this._blame=this.editor.document.isDirty?Ts.git.getBlameForFileContents(this._uri,this.editor.document.getText()):Ts.git.getBlameForFile(this._uri)),super.onReset(e)}async selection(e,t){if(!this.highlightDecoration)return;if(!(void 0!==t||(t=await this._blame)&&t.lines.length))return;let i=void 0;if("string"==typeof e)i=e;else if("number"==typeof e){if(e>=0){const s=t.lines[e];i=s&&s.sha}}else i=ee.first(t.commits.values()).sha;if(!i)return void this.editor.setDecorations(this.highlightDecoration,[]);const o=G.filterMap(t.lines,e=>e.sha===i?this.editor.document.validateRange(new s.Range(e.line,0,e.line,Number.MAX_SAFE_INTEGER)):void 0);this.editor.setDecorations(this.highlightDecoration,o)}async validate(){const e=await this._blame;return void 0!==e&&0!==e.lines.length}async getBlame(){const e=await this._blame;if(void 0!==e&&0!==e.lines.length)return e}getComputedHeatmap(e){const t=[];let i,s;for(const o of e.lines)s!==o.sha&&(s=o.sha,void 0!==(i=e.commits.get(o.sha))&&t.push(i.date));t.sort((e,t)=>e.getTime()-t.getTime());const o=Math.floor(t.length/2),a=t.length%2?t[o].getTime():(t[o-1].getTime()+t[o].getTime())/2,r=[],n=t[t.length-1].getTime();let l=(n-a)/5;for(let e=5;e>0;e--)r.push(a+l*e);r.push(a);const c=t[0].getTime();l=(a-c)/4;for(let e=1;e<=4;e++)r.push(a-l*e);const h=new Date;return h.setDate(h.getDate()-(Ts.config.heatmap.ageThreshold||90)),{cold:n<h.getTime(),colors:{cold:Ts.config.heatmap.coldColor,hot:Ts.config.heatmap.hotColor},median:a,newest:n,oldest:c,computeAge:e=>{const t=e.getTime();let i=0;for(let e=0;e<r.length&&(i=e,!(t>=r[e]));e++);return i}}}registerHoverProviders(e){if(!Ts.config.hovers.enabled||!Ts.config.hovers.annotations.enabled||!e.details&&!e.changes)return;const t=[];e.changes&&t.push(s.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),e.details&&t.push(s.languages.registerHoverProvider({pattern:this.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=s.Disposable.from(...t)}async provideDetailsHover(e,t,i){const o=await this.getCommitForHover(t);if(void 0===o)return;let a=void 0;o.isUncommitted||void 0!==(a=await Ts.git.getLogCommitForFile(o.repoPath,o.uri.fsPath,{ref:o.sha}))&&(a.previousFileName=o.previousFileName,a.previousSha=o.previousSha);const r=di.getHoverMessage(a||o,Ts.config.defaultDateFormat,await Ts.git.getRemotes(o.repoPath),this.annotationType,this.editor.selection.active.line);return new s.Hover(r,e.validateRange(new s.Range(t.line,0,t.line,Number.MAX_SAFE_INTEGER)))}async provideChangesHover(e,t,i){const o=await this.getCommitForHover(t);if(void 0===o)return;const a=await di.changesHover(o,t.line,await _e.fromUri(e.uri));return void 0!==a.hoverMessage?new s.Hover(a.hoverMessage,e.validateRange(new s.Range(t.line,0,t.line,Number.MAX_SAFE_INTEGER))):void 0}async getCommitForHover(e){if("line"!==Ts.config.hovers.annotations.over&&0!==e.character)return;const t=await this.getBlame();if(void 0===t)return;const i=t.lines[e.line];return t.commits.get(i.sha)}}class ui extends mi{async onProvideAnnotation(e,t){this.annotationType=p.Blame;const i=await this.getBlame();if(void 0===i)return!1;const o=process.hrtime(),a=Ts.config.blame,r=ae.getTokensFromTemplate(a.format).reduce((e,t)=>(e[t.key]=t.options,e),{}),n={dateFormat:null===a.dateFormat?Ts.config.defaultDateFormat:a.dateFormat,tokenOptions:r},l=a.avatars,c=Ts.config.defaultGravatarsStyle,h=a.separateLines,d=di.gutterRenderOptions(h,a.heatmap,a.format,n);this.decorations=[];const m=Object.create(null),u=l?Object.create(null):void 0;let g,f,v,w,b=!1;a.heatmap.enabled&&(w=this.getComputedHeatmap(i));for(const e of i.lines){const t=e.line;v!==e.sha?(b=!1,v=e.sha,void 0!==(g=i.commits.get(e.sha))&&(void 0===(f=m[e.sha])?(f=di.gutter(g,a.format,n,d),void 0!==w&&di.applyHeatmap(f,g.date,w),f.range=new s.Range(t,0,t,0),this.decorations.push(f),l&&void 0!==g.email&&this.addOrUpdateGravatarDecoration(g,f.range,c,u),m[e.sha]=f):(f=Object.assign({},f,{range:new s.Range(t,0,t,0)}),this.decorations.push(f),l&&void 0!==g.email&&this.addOrUpdateGravatarDecoration(g,f.range,c,u)))):(f=Object.assign({},f),a.compact&&!b&&(f.renderOptions={before:Object.assign({},f.renderOptions.before,{contentText:T.Space.repeat(ae.getWidth(f.renderOptions.before.contentText))})},h&&(f.renderOptions.before.textDecoration="none"),b=!0),f.range=new s.Range(t,0,t,0),this.decorations.push(f),l&&!a.compact&&void 0!==g&&void 0!==g.email&&this.addOrUpdateGravatarDecoration(g,f.range,c,u))}if(this.decorations.length&&(this.editor.setDecorations(this.decoration,this.decorations),l)){this.additionalDecorations=[];for(const e of j.values(u))this.additionalDecorations.push(e),this.editor.setDecorations(e.decoration,e.ranges)}const _=process.hrtime(o);return H.log(`${1e3*_[0]+Math.floor(_[1]/1e6)} ms to compute gutter blame annotations`),this.registerHoverProviders(Ts.config.hovers.annotations),this.selection(e,i),!0}addOrUpdateGravatarDecoration(e,t,i,o){const a=o[e.email];void 0===a?o[e.email]={decoration:s.window.createTextEditorDecorationType({gutterIconPath:e.getGravatarUri(i),gutterIconSize:"16px 16px"}),ranges:[t]}:a.ranges.push(t)}}class gi extends mi{async onProvideAnnotation(e,t){this.annotationType=p.Heatmap;const i=await this.getBlame();if(void 0===i)return!1;const o=process.hrtime(),a=di.heatmapRenderOptions();this.decorations=[];const r=Object.create(null);let n,l;const c=this.getComputedHeatmap(i);for(const e of i.lines){const t=e.line;void 0===(l=r[e.sha])?void 0!==(n=i.commits.get(e.sha))&&((l=di.heatmap(n,c,a)).range=new s.Range(t,0,t,0),this.decorations.push(l),r[e.sha]=l):(l=Object.assign({},l,{range:new s.Range(t,0,t,0)}),this.decorations.push(l))}this.decorations.length&&this.editor.setDecorations(this.decoration,this.decorations);const h=process.hrtime(o);return H.log(`${1e3*h[0]+Math.floor(h[1]/1e6)} ms to compute heatmap annotations`),this.registerHoverProviders(Ts.config.hovers.annotations),this.selection(e,i),!0}}class pi extends si{constructor(e,t,i,s){super(e,t,i,s),this._uri=t.uri}async onProvideAnnotation(e){this.annotationType=p.RecentChanges;const t=await Ts.git.getRecentLogCommitForFile(this._uri.repoPath,this._uri.fsPath);if(void 0===t)return!1;const i=await Ts.git.getDiffForFile(this._uri,t.previousSha);if(void 0===i)return!1;const o=process.hrtime(),a=Ts.config,r=a.defaultDateFormat;this.decorations=[];for(const e of i.chunks){let i=e.currentPosition.start-2;for(const o of e.lines){if(void 0===o.line)continue;if(i++,"unchanged"===o.state)continue;const e=this.editor.document.validateRange(new s.Range(new s.Position(i,0),new s.Position(i,Number.MAX_SAFE_INTEGER)));let n=void 0;a.hovers.enabled&&a.hovers.annotations.enabled&&(a.hovers.annotations.details&&this.decorations.push({hoverMessage:di.getHoverMessage(t,r,await Ts.git.getRemotes(t.repoPath),this.annotationType,this.editor.selection.active.line),range:e}),a.hovers.annotations.changes&&void 0===(n=di.getHoverDiffMessage(t,this._uri,o)))||this.decorations.push({hoverMessage:n,range:e})}}this.editor.setDecorations(this.decoration,this.decorations);const n=process.hrtime(o);return H.log(`${1e3*n[0]+Math.floor(n[1]/1e6)} ms to compute recent changes annotations`),!0}async selection(e){}async validate(){return!0}}var fi;!function(e){e.User="User",e.BlameabilityChanged="BlameabilityChanged",e.ColumnChanged="ColumnChanged",e.Disposing="Disposing",e.DocumentChanged="DocumentChanged",e.DocumentClosed="DocumentClosed"}(fi||(fi={}));const vi={blameAnnotation:s.window.createTextEditorDecorationType({rangeBehavior:s.DecorationRangeBehavior.ClosedOpen,textDecoration:"none"}),blameHighlight:void 0,heatmapAnnotation:s.window.createTextEditorDecorationType({}),heatmapHighlight:void 0,recentChangesAnnotation:void 0,recentChangesHighlight:void 0};class wi{constructor(){this._onDidToggleAnnotations=new s.EventEmitter,this._annotationProviders=new Map,this._keyboardScope=void 0,this._annotationType=void 0,this._disposable=s.Disposable.from(ti.onDidChange(this.onConfigurationChanged,this)),this._toggleModes=new Map,this.onConfigurationChanged(ti.initializingChangeEvent)}get onDidToggleAnnotations(){return this._onDidToggleAnnotations.event}dispose(){this.clearAll(),vi.blameAnnotation&&vi.blameAnnotation.dispose(),vi.blameHighlight&&vi.blameHighlight.dispose(),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ti.initializing(e),i=Ts.config;if(t||ti.changed(e,ti.name("blame")("highlight").value)){vi.blameHighlight&&vi.blameHighlight.dispose();const e=i.blame.highlight;e.enabled?vi.blameHighlight=s.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:s.OverviewRulerLane.Right,backgroundColor:e.locations.includes(w.Line)?new s.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(w.Overview)?new s.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(w.Gutter)?Ts.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(w.Gutter)?Ts.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}}):vi.blameHighlight=void 0}if(t||ti.changed(e,ti.name("recentChanges")("highlight").value)){vi.recentChangesAnnotation&&vi.recentChangesAnnotation.dispose();const e=i.recentChanges.highlight;vi.recentChangesAnnotation=s.window.createTextEditorDecorationType({gutterIconSize:"contain",isWholeLine:!0,overviewRulerLane:s.OverviewRulerLane.Right,backgroundColor:e.locations.includes(w.Line)?new s.ThemeColor("gitlens.lineHighlightBackgroundColor"):void 0,overviewRulerColor:e.locations.includes(w.Overview)?new s.ThemeColor("gitlens.lineHighlightOverviewRulerColor"):void 0,dark:{gutterIconPath:e.locations.includes(w.Gutter)?Ts.context.asAbsolutePath("images/dark/highlight-gutter.svg"):void 0},light:{gutterIconPath:e.locations.includes(w.Gutter)?Ts.context.asAbsolutePath("images/light/highlight-gutter.svg"):void 0}})}if((t||ti.changed(e,ti.name("blame")("toggleMode").value))&&(this._toggleModes.set(p.Blame,i.blame.toggleMode),t||i.blame.toggleMode!==l.File||this.clearAll()),(t||ti.changed(e,ti.name("heatmap")("toggleMode").value))&&(this._toggleModes.set(p.Heatmap,i.heatmap.toggleMode),t||i.heatmap.toggleMode!==l.File||this.clearAll()),(t||ti.changed(e,ti.name("recentChanges")("toggleMode").value))&&(this._toggleModes.set(p.RecentChanges,i.recentChanges.toggleMode),t||i.recentChanges.toggleMode!==l.File||this.clearAll()),!t&&(ti.changed(e,ti.name("blame").value)||ti.changed(e,ti.name("recentChanges").value)||ti.changed(e,ti.name("heatmap").value)||ti.changed(e,ti.name("hovers").value)))for(const e of this._annotationProviders.values())void 0!==e&&(e.annotationType===p.RecentChanges?e.reset({decoration:vi.recentChangesAnnotation,highlightDecoration:vi.recentChangesHighlight}):e.annotationType===p.Blame?e.reset({decoration:vi.blameAnnotation,highlightDecoration:vi.blameHighlight}):this.show(e.editor,p.Heatmap))}async onActiveTextEditorChanged(e){if(void 0!==e&&!N(e))return;if(this._editor=e,this.isInWindowToggle())return void await this.show(e,this._annotationType);const t=this.getProvider(e);void 0===t?(E(F.AnnotationStatus,void 0),this.detachKeyboardHook()):(E(F.AnnotationStatus,t.status),this.attachKeyboardHook())}onBlameStateChanged(e){if(e.blameable)return;const t=s.window.activeTextEditor;void 0!==t&&this.clear(t,fi.BlameabilityChanged)}onDirtyStateChanged(e){for(const[t,i]of this._annotationProviders)e.document.is(i.document)&&this.clearCore(t,fi.DocumentChanged)}onTextDocumentClosed(e){if(Ts.git.isTrackable(e.uri))for(const[t,i]of this._annotationProviders)i.document===e&&this.clearCore(t,fi.DocumentClosed)}onTextEditorViewColumnChanged(e){const t=this.getProvider(e.textEditor);if(void 0!==t)t.restore(e.textEditor);else{const t=ee.find(this._annotationProviders.values(),t=>t.editor.document===e.textEditor.document);if(null==t)return;this.clearCore(t.correlationKey,fi.ColumnChanged)}}onVisibleTextEditorsChanged(e){let t;for(const i of e)void 0!==(t=this.getProvider(i))&&t.restore(i)}isInWindowToggle(){return this.getToggleMode(this._annotationType)===l.Window}getToggleMode(e){return void 0===e?l.File:this._toggleModes.get(e)||l.File}clear(e,t=fi.User){return this.isInWindowToggle()?this.clearAll():this.clearCore(si.getCorrelationKey(e),t)}async clearAll(){this._annotationType=void 0;for(const[e]of this._annotationProviders)await this.clearCore(e,fi.Disposing)}async getAnnotationType(e){const t=this.getProvider(e);if(void 0===t)return;const i=await Ts.tracker.get(e.document);return void 0!==i&&i.isBlameable?t.annotationType:void 0}getProvider(e){if(void 0!==e&&void 0!==e.document)return this._annotationProviders.get(si.getCorrelationKey(e))}async show(e,t,i){if(this.getToggleMode(t)===l.Window){let i=void 0===this._annotationType;const o=!i&&this._annotationType!==t;if(this._annotationType=t,o&&(await this.clearAll(),i=!0),i)for(const i of s.window.visibleTextEditors)i!==e&&this.show(i,t)}if(void 0===e)return!1;if(this._editor=e,!(await Ts.tracker.getOrAdd(e.document)).isBlameable)return!1;const o=this.getProvider(e);return void 0!==o&&o.annotationType===t?(await o.selection(i),!0):void 0!==await s.window.withProgress({location:s.ProgressLocation.Window},async s=>{await E(F.AnnotationStatus,ii.Computing);const a=this.showAnnotationsCore(o,e,t,i,s),r=await a;return e===this._editor&&await E(F.AnnotationStatus,r&&r.status),a})}async toggle(e,t,i){if(void 0!==e){const i=await Ts.tracker.getOrAdd(e.document);if(t===p.RecentChanges&&!i.isTracked||!i.isBlameable)return!1}const s=this.getProvider(e);if(void 0===s)return this.show(e,t,i);const o=s.annotationType!==t;return this.isInWindowToggle()?await this.clearAll():await this.clearCore(s.correlationKey,fi.User),!!o&&this.show(e,t,i)}async attachKeyboardHook(){void 0===this._keyboardScope&&(this._keyboardScope=await Ts.keyboard.beginScope({escape:{onDidPressKey:async e=>{const t=this._editor;void 0!==t&&await this.clear(t,fi.User)}}}))}async clearCore(e,t){const i=this._annotationProviders.get(e);void 0!==i&&(H.log(`${t}:`,`Clear annotations for ${e}`),this._annotationProviders.delete(e),await i.dispose(),0!==this._annotationProviders.size&&e!==si.getCorrelationKey(this._editor)||(await E(F.AnnotationStatus,void 0),await this.detachKeyboardHook()),0===this._annotationProviders.size&&(H.log("Remove all listener registrations for annotations"),this._annotationsDisposable&&this._annotationsDisposable.dispose(),this._annotationsDisposable=void 0),this._onDidToggleAnnotations.fire())}async detachKeyboardHook(){void 0!==this._keyboardScope&&(await this._keyboardScope.dispose(),this._keyboardScope=void 0)}async showAnnotationsCore(e,t,i,o,a){if(void 0!==a){let e="annotations";switch(i){case p.Blame:e="blame annotations";break;case p.Heatmap:e="heatmap annotations";break;case p.RecentChanges:e="recent changes annotations"}a.report({message:`Computing ${e} for ${y.basename(t.document.fileName)}`})}await this.attachKeyboardHook();const r=await Ts.tracker.getOrAdd(t.document);let n=void 0;switch(i){case p.Blame:n=new ui(t,r,vi.blameAnnotation,vi.blameHighlight);break;case p.Heatmap:n=new gi(t,r,vi.heatmapAnnotation,vi.heatmapHighlight);break;case p.RecentChanges:n=new pi(t,r,vi.recentChangesAnnotation,vi.recentChangesHighlight)}if(void 0!==n&&await n.validate())return void 0!==e&&await this.clearCore(e.correlationKey,fi.User),this._annotationsDisposable||0!==this._annotationProviders.size||(H.log("Add listener registrations for annotations"),this._annotationsDisposable=s.Disposable.from(s.window.onDidChangeActiveTextEditor(J.debounce(this.onActiveTextEditorChanged,50),this),s.window.onDidChangeTextEditorViewColumn(this.onTextEditorViewColumnChanged,this),s.window.onDidChangeVisibleTextEditors(J.debounce(this.onVisibleTextEditorsChanged,50),this),s.workspace.onDidCloseTextDocument(this.onTextDocumentClosed,this),Ts.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),Ts.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this))),this._annotationProviders.set(n.correlationKey,n),await n.provideAnnotation(o)?(this._onDidToggleAnnotations.fire(),n):void 0}}const bi=s.window.createTextEditorDecorationType({after:{margin:"0 0 0 3em",textDecoration:"none"},rangeBehavior:s.DecorationRangeBehavior.ClosedOpen});class _i{constructor(){this._enabled=!1,this._disposable=s.Disposable.from(ti.onDidChange(this.onConfigurationChanged,this),Ts.fileAnnotations.onDidToggleAnnotations(this.onFileAnnotationsToggled,this),s.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(ti.initializingChangeEvent)}dispose(){this.clearAnnotations(this._editor),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),Ts.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ti.initializing(e);(t||ti.changed(e,ti.name("currentLine").value))&&((t||ti.changed(e,ti.name("currentLine")("enabled").value))&&(Ts.config.currentLine.enabled?(this._enabled=!0,this.resume()):(this._enabled=!1,this.setLineTracker(!1))),this.refresh(s.window.activeTextEditor))}get suspended(){return!this._enabled||void 0!==this._suspended}resume(e="user"){switch(this.setLineTracker(!0),e){case"debugging":if("user"!==this._suspended)return this._suspended=void 0,!0;break;case"user":if(void 0!==this._suspended)return this._suspended=void 0,!0}return!1}suspend(e="user"){return this.setLineTracker(!1),"user"!==this._suspended&&(this._suspended=e,!0)}onActiveLinesChanged(e){e.pending||void 0===e.lines?this.clear(e.editor):this.refresh(e.editor)}onDebugSessionStarted(){void 0===this._debugSessionEndDisposable&&(this._debugSessionEndDisposable=s.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this)),this.suspend("debugging")&&this.refresh(s.window.activeTextEditor)}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0),this.resume("debugging")&&this.refresh(s.window.activeTextEditor)}onFileAnnotationsToggled(){this.refresh(s.window.activeTextEditor)}clear(e){this._editor!==e&&void 0!==this._editor&&this.clearAnnotations(this._editor),this.clearAnnotations(e)}async toggle(e){this._enabled=!(this._enabled&&!this.suspended),this._enabled?this.resume("user")&&await this.refresh(e):this.suspend("user")&&await this.refresh(e)}clearAnnotations(e){void 0!==e&&!0!==e._disposed&&e.setDecorations(bi,[])}async refresh(e){if(void 0===e&&void 0===this._editor)return;const t=Ts.lineTracker.lines;if(void 0===e||void 0===t||!N(e))return this.clear(this._editor);this._editor!==e&&(this.clear(this._editor),this._editor=e);const i=Ts.config.currentLine;if(this.suspended)return this.clear(e);if(!(await Ts.tracker.getOrAdd(e.document)).isBlameable&&this.suspended)return this.clear(e);if(void 0===e.document||!Ts.lineTracker.includesAll(t))return;const o=Ts.config.currentLine.scrollable,a=[];for(const r of t){const t=Ts.lineTracker.getState(r);if(void 0===t||void 0===t.commit)continue;const n=di.trailing(t.commit,i.format,null===i.dateFormat?Ts.config.defaultDateFormat:i.dateFormat,o);n.range=e.document.validateRange(new s.Range(r,Number.MAX_SAFE_INTEGER,r,Number.MAX_SAFE_INTEGER)),a.push(n)}e.setDecorations(bi,a)}setLineTracker(e){e?Ts.lineTracker.isSubscribed(this)||Ts.lineTracker.start(this,s.Disposable.from(Ts.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this))):Ts.lineTracker.stop(this)}}class Ci extends s.CodeLens{constructor(e,t,i,s,o,a,r,n,l){super(r,l),this.languageId=e,this.symbol=t,this.uri=i,this.blame=s,this.blameRange=o,this.isFullRange=a,this.desiredCommand=n}getBlame(){return this.blame&&this.blame()}}class yi extends s.CodeLens{constructor(e,t,i,s,o,a,r,n){super(r),this.languageId=e,this.symbol=t,this.uri=i,this.blame=s,this.blameRange=o,this.isFullRange=a,this.desiredCommand=n}getBlame(){return this.blame()}}class xi{constructor(e,t,i){this._git=t,this._tracker=i,this._onDidChangeCodeLenses=new s.EventEmitter}get onDidChangeCodeLenses(){return this._onDidChangeCodeLenses.event}reset(e){this._onDidChangeCodeLenses.fire()}async provideCodeLenses(e,t){const i=await this._tracker.getOrAdd(e);if(!i.isBlameable)return[];let o=!1;if(e.isDirty)if(i.isDirtyIdle){const t=Ts.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.lineCount>t&&(o=!0)}else o=!0;const a=ti.get(ti.name("codeLens").value,e.uri);let r=a.scopesByLanguage&&a.scopesByLanguage.find(t=>void 0!==t.language&&t.language.toLowerCase()===e.languageId);null==r&&(r={language:void 0}),null==r.scopes&&(r.scopes=a.scopes),null==r.symbolScopes&&(r.symbolScopes=a.symbolScopes),r.symbolScopes=null!=r.symbolScopes?r.symbolScopes=r.symbolScopes.map(e=>e.toLowerCase()):[];const n=[],l=i.uri;let c,d;if(o)1===r.scopes.length&&r.scopes.includes(h.Document)||(d=await s.commands.executeCommand(D.ExecuteDocumentSymbolProvider,e.uri));else{if(t.isCancellationRequested)return n;if(1===r.scopes.length&&r.scopes.includes(h.Document)?c=e.isDirty?await this._git.getBlameForFileContents(l,e.getText()):await this._git.getBlameForFile(l):[c,d]=await Promise.all([e.isDirty?this._git.getBlameForFileContents(l,e.getText()):this._git.getBlameForFile(l),s.commands.executeCommand(D.ExecuteDocumentSymbolProvider,e.uri)]),void 0===c||0===c.lines.length)return n}if(t.isCancellationRequested)return n;const m=J.once(()=>e.validateRange(new s.Range(0,1e6,1e6,1e6))),u=o?{title:this.getDirtyTitle(a)}:void 0;if(void 0!==d&&(H.log("GitCodeLensProvider.provideCodeLenses:",`${d.length} symbol(s) found`),d.forEach(t=>this.provideCodeLens(n,e,t,r,m,c,l,a,o,u))),(r.scopes.includes(h.Document)||r.symbolScopes.includes("file"))&&!r.symbolScopes.includes("!file")&&!n.find(e=>0===e.range.start.line&&0===e.range.end.line)){const t=m();let i=void 0;if(o||a.recentChange.enabled){o||(i=J.once(()=>this._git.getBlameForRangeSync(c,l,t)));const r=new s.SymbolInformation(l.getFilename(),s.SymbolKind.File,"",new s.Location(l.fileUri(),new s.Range(0,0,0,t.start.character)));n.push(new Ci(e.languageId,r,l,i,t,!0,$i(r),a.recentChange.command,u))}if(!o&&a.authors.enabled){void 0===i&&(i=J.once(()=>this._git.getBlameForRangeSync(c,l,t)));const o=new s.SymbolInformation(l.getFilename(),s.SymbolKind.File,"",new s.Location(l.fileUri(),new s.Range(0,1,0,t.start.character)));n.push(new yi(e.languageId,o,l,i,t,!0,$i(o),a.authors.command))}}return n}validateSymbolAndGetBlameRange(e,t,i){let o,a=!1;const r=s.SymbolKind[e.kind].toLowerCase();switch(e.kind){case s.SymbolKind.File:(t.scopes.includes(h.Containers)||t.symbolScopes.includes(r))&&(a=!t.symbolScopes.includes(`!${r}`)),a&&(o=i());break;case s.SymbolKind.Package:(t.scopes.includes(h.Containers)||t.symbolScopes.includes(r))&&(a=!t.symbolScopes.includes(`!${r}`)),a&&0===$i(e).start.line&&0===$i(e).end.line&&(o=i());break;case s.SymbolKind.Class:case s.SymbolKind.Interface:case s.SymbolKind.Module:case s.SymbolKind.Namespace:case s.SymbolKind.Struct:(t.scopes.includes(h.Containers)||t.symbolScopes.includes(r))&&(a=!t.symbolScopes.includes(`!${r}`));break;case s.SymbolKind.Constructor:case s.SymbolKind.Enum:case s.SymbolKind.Function:case s.SymbolKind.Method:(t.scopes.includes(h.Blocks)||t.symbolScopes.includes(r))&&(a=!t.symbolScopes.includes(`!${r}`));break;default:t.symbolScopes.includes(r)&&(a=!t.symbolScopes.includes(`!${r}`))}return a?o||$i(e):void 0}provideCodeLens(e,t,i,o,a,r,n,l,c,h){const d=this.validateSymbolAndGetBlameRange(i,o,a);if(void 0===d)return;const m=t.lineAt($i(i).start);if(e.length&&e[e.length-1].range.start.line===m.lineNumber)return;let u,g=0;if((c||l.recentChange.enabled)&&(c||(u=J.once(()=>this._git.getBlameForRangeSync(r,n,d))),e.push(new Ci(t.languageId,i,n,u,d,!1,m.range.with(new s.Position(m.range.start.line,g)),l.recentChange.command,h)),g++),l.authors.enabled){let o=!d.isSingleLine;if(!o&&"csharp"===t.languageId)switch(i.kind){case s.SymbolKind.File:break;case s.SymbolKind.Package:case s.SymbolKind.Module:case s.SymbolKind.Namespace:case s.SymbolKind.Class:case s.SymbolKind.Interface:case s.SymbolKind.Constructor:case s.SymbolKind.Method:case s.SymbolKind.Function:case s.SymbolKind.Enum:o=!0}o&&!c&&(void 0===u&&(u=J.once(()=>this._git.getBlameForRangeSync(r,n,d))),e.push(new yi(t.languageId,i,n,u,d,!1,m.range.with(new s.Position(m.range.start.line,g)),l.authors.command)))}}resolveCodeLens(e,t){return e instanceof Ci?this.resolveGitRecentChangeCodeLens(e,t):e instanceof yi?this.resolveGitAuthorsCodeLens(e,t):Promise.reject(void 0)}resolveGitRecentChangeCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const o=ee.first(i.commits.values());let a=`${o.author}, ${o.formattedDate}`;switch(Ts.config.debug&&(a+=` [${e.languageId}: ${s.SymbolKind[e.symbol.kind]}(${e.range.start.character}-${e.range.end.character}${e.symbol.containerName?`|${e.symbol.containerName}`:""}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Commit (${o.shortSha})]`),e.desiredCommand){case c.DiffWithPrevious:return this.applyDiffWithPreviousCommand(a,e,i,o);case c.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(a,e,i,o);case c.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(a,e,i,o);case c.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(a,e,i,o);case c.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(a,e,i,o);case c.ToggleFileBlame:return this.applyToggleFileBlameCommand(a,e,i);default:return e}}resolveGitAuthorsCodeLens(e,t){const i=e.getBlame();if(void 0===i)return e;const o=i.authors.size;let a=`${o} ${o>1?"authors":"author"} (${ee.first(i.authors.values()).name}${o>1?" and others":""})`;switch(Ts.config.debug&&(a+=` [${e.languageId}: ${s.SymbolKind[e.symbol.kind]}(${e.range.start.character}-${e.range.end.character}${e.symbol.containerName?`|${e.symbol.containerName}`:""}), Lines (${e.blameRange.start.line+1}-${e.blameRange.end.line+1}), Authors (${ee.join(ee.map(i.authors.values(),e=>e.name),", ")})]`),e.desiredCommand){case c.DiffWithPrevious:return this.applyDiffWithPreviousCommand(a,e,i);case c.ShowQuickCommitDetails:return this.applyShowQuickCommitDetailsCommand(a,e,i);case c.ShowQuickCommitFileDetails:return this.applyShowQuickCommitFileDetailsCommand(a,e,i);case c.ShowQuickCurrentBranchHistory:return this.applyShowQuickCurrentBranchHistoryCommand(a,e,i);case c.ShowQuickFileHistory:return this.applyShowQuickFileHistoryCommand(a,e,i);case c.ToggleFileBlame:return this.applyToggleFileBlameCommand(a,e,i);default:return e}}applyDiffWithPreviousCommand(e,t,i,o){if(void 0===o){const e=i.allLines[t.range.start.line];o=i.commits.get(e.sha)}return t.command={title:e,command:ji.DiffWithPrevious,arguments:[s.Uri.file(t.uri.fsPath),{commit:o}]},t}applyShowQuickCommitDetailsCommand(e,t,i,o){return t.command={title:e,command:void 0!==o&&o.isUncommitted?"":c.ShowQuickCommitDetails,arguments:[s.Uri.file(t.uri.fsPath),{commit:o,sha:void 0===o?void 0:o.sha}]},t}applyShowQuickCommitFileDetailsCommand(e,t,i,o){return t.command={title:e,command:void 0!==o&&o.isUncommitted?"":c.ShowQuickCommitFileDetails,arguments:[s.Uri.file(t.uri.fsPath),{commit:o,sha:void 0===o?void 0:o.sha}]},t}applyShowQuickCurrentBranchHistoryCommand(e,t,i,o){return t.command={title:e,command:c.ShowQuickCurrentBranchHistory,arguments:[s.Uri.file(t.uri.fsPath)]},t}applyShowQuickFileHistoryCommand(e,t,i,o){return t.command={title:e,command:c.ShowQuickFileHistory,arguments:[s.Uri.file(t.uri.fsPath),{range:t.isFullRange?void 0:t.blameRange}]},t}applyToggleFileBlameCommand(e,t,i){return t.command={title:e,command:ji.ToggleFileBlame,arguments:[s.Uri.file(t.uri.fsPath)]},t}getDirtyTitle(e){return e.recentChange.enabled&&e.authors.enabled?Ts.config.strings.codeLens.unsavedChanges.recentChangeAndAuthors:e.recentChange.enabled?Ts.config.strings.codeLens.unsavedChanges.recentChangeOnly:Ts.config.strings.codeLens.unsavedChanges.authorsOnly}}function $i(e){return e.location&&e.location.range||e.range}xi.selector=[{scheme:P.File},{scheme:P.Git},{scheme:P.GitLensGit}];class Si{constructor(){this._canToggle=!1,this._disposable=s.Disposable.from(ti.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ti.initializingChangeEvent)}dispose(){this._providerDisposable&&this._providerDisposable.dispose(),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ti.initializing(e),i=ti.name("codeLens").value;if(t||ti.changed(e,i,null)||ti.changed(e,ti.name("defaultDateStyle").value)||ti.changed(e,ti.name("defaultDateFormat").value)){t||H.log("CodeLens config changed; resetting CodeLens provider");const e=Ts.config.codeLens;e.enabled&&(e.recentChange.enabled||e.authors.enabled)?void 0!==this._provider?this._provider.reset():this.createProvider():(void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),this._provider=void 0),this._canToggle=e.recentChange.enabled||e.authors.enabled,E(F.CanToggleCodeLens,this._canToggle)}}onBlameStateChanged(e){void 0!==this._provider&&e.blameable&&(H.log("Blame state changed; resetting CodeLens provider"),this._provider.reset("saved"))}onDirtyIdleTriggered(e){if(void 0===this._provider||!e.document.isBlameable)return;const t=Ts.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.document.lineCount>t||(H.log("Dirty idle triggered; resetting CodeLens provider"),this._provider.reset("idle"))}toggleCodeLens(){if(this._canToggle){if(H.log("toggleCodeLens()"),void 0!==this._provider)return void 0!==this._providerDisposable&&(this._providerDisposable.dispose(),this._providerDisposable=void 0),void(this._provider=void 0);this.createProvider()}}createProvider(){this._provider=new xi(Ts.context,Ts.git,Ts.tracker),this._providerDisposable=s.Disposable.from(s.languages.registerCodeLensProvider(xi.selector,this._provider),Ts.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),Ts.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))}}class ki extends s.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class Di extends s.CodeLens{constructor(e,t,i){super(i),this.fileName=e,this.commit=t}}class Fi{async provideCodeLenses(e,t){const i=_e.fromRevisionUri(e.uri),o=[],a=await Ts.git.getLogCommitForFile(i.repoPath,i.fsPath,{ref:i.sha,firstIfNotFound:!0});return void 0===a?o:(a.previousSha&&o.push(new Di(a.previousUri.fsPath,a,new s.Range(0,0,0,1))),o.push(new ki(a.uri.fsPath,a,new s.Range(0,1,0,2))),o)}resolveCodeLens(e,t){return e instanceof ki?this._resolveDiffWithWorkingTreeCodeLens(e,t):e instanceof Di?this._resolveGitDiffWithPreviousCodeLens(e,t):Promise.reject(void 0)}_resolveDiffWithWorkingTreeCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Working`,command:ji.DiffWithWorking,arguments:[s.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}_resolveGitDiffWithPreviousCodeLens(e,t){return e.command={title:`Compare Revision (${e.commit.shortSha}) with Previous (${e.commit.previousShortSha})`,command:ji.DiffWithPrevious,arguments:[s.Uri.file(e.fileName),{commit:e.commit,line:e.range.start.line}]},Promise.resolve(e)}}Fi.selector={scheme:P.GitLensGit};class Pi{async provideTextDocumentContent(e,t){const i=_e.fromRevisionUri(e);if(!i.repoPath||i.sha===Zt.deletedSha)return"";try{return await Ts.git.getVersionedFileText(i.repoPath,i.fsPath,i.sha||"HEAD")}catch(e){return H.error(e,"GitContentProvider","getVersionedFileText"),void s.window.showErrorMessage(`Unable to show Git revision ${Zt.shortenSha(i.sha)} of '${y.relative(i.repoPath,i.fsPath)}'`)}}}Pi.scheme=P.GitLensGit;class Ti{constructor(){this._disposable=s.Disposable.from(ti.onDidChange(this.onConfigurationChanged,this),s.debug.onDidStartDebugSession(this.onDebugSessionStarted,this)),this.onConfigurationChanged(ti.initializingChangeEvent)}dispose(){this.unregister(),this._debugSessionEndDisposable&&this._debugSessionEndDisposable.dispose(),Ts.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){(ti.initializing(e)||ti.changed(e,ti.name("hovers")("enabled").value)||ti.changed(e,ti.name("hovers")("currentLine")("enabled").value))&&(Ts.config.hovers.enabled&&Ts.config.hovers.currentLine.enabled?(Ts.lineTracker.start(this,s.Disposable.from(Ts.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this))),this.register(s.window.activeTextEditor)):(Ts.lineTracker.stop(this),this.unregister()))}get debugging(){return void 0!==this._debugSessionEndDisposable}onActiveLinesChanged(e){e.pending||"editor"!==e.reason||(void 0!==e.editor&&void 0!==e.lines?this.register(e.editor):this.unregister())}onDebugSessionStarted(){void 0===this._debugSessionEndDisposable&&(this._debugSessionEndDisposable=s.debug.onDidTerminateDebugSession(this.onDebugSessionEnded,this))}onDebugSessionEnded(){void 0!==this._debugSessionEndDisposable&&(this._debugSessionEndDisposable.dispose(),this._debugSessionEndDisposable=void 0)}async provideDetailsHover(e,t,i){if(!Ts.lineTracker.includes(t.line))return;const o=Ts.lineTracker.getState(t.line),a=void 0!==o?o.commit:void 0;if(void 0===a)return;const r=await Ts.fileAnnotations.getAnnotationType(s.window.activeTextEditor);if(void 0!==r&&Ts.config.hovers.annotations.details)return;const n=!this.debugging&&"line"===Ts.config.hovers.currentLine.over;if(!n&&Ts.lineAnnotations.suspended)return;const l=e.validateRange(new s.Range(t.line,n?0:Number.MAX_SAFE_INTEGER,t.line,Number.MAX_SAFE_INTEGER));if(!n&&l.start.character!==t.character)return;let c=void 0!==o?o.logCommit:void 0;if(void 0!==c||a.isUncommitted||void 0!==(c=await Ts.git.getLogCommitForFile(a.repoPath,a.uri.fsPath,{ref:a.sha}))&&(c.previousSha=a.previousSha,c.previousFileName=a.previousFileName,void 0!==o&&(o.logCommit=c)),void 0===await Ts.tracker.get(e))return;const h=di.getHoverMessage(c||a,Ts.config.defaultDateFormat,await Ts.git.getRemotes(a.repoPath),r,t.line);return new s.Hover(h,l)}async provideChangesHover(e,t,i){if(!Ts.lineTracker.includes(t.line))return;const o=Ts.lineTracker.getState(t.line),a=void 0!==o?o.commit:void 0;if(void 0===a)return;if(Ts.config.hovers.annotations.changes){if(void 0!==await Ts.fileAnnotations.getAnnotationType(s.window.activeTextEditor))return}const r=!this.debugging&&"line"===Ts.config.hovers.currentLine.over;if(!r&&Ts.lineAnnotations.suspended)return;const n=e.validateRange(new s.Range(t.line,r?0:Number.MAX_SAFE_INTEGER,t.line,Number.MAX_SAFE_INTEGER));if(!r&&n.start.character!==t.character)return;const l=await Ts.tracker.get(e);if(void 0===l)return;const c=await di.changesHover(a,t.line,l.uri);return void 0!==c.hoverMessage?new s.Hover(c.hoverMessage,n):void 0}register(e){if(this.unregister(),void 0===e)return;const t=Ts.config.hovers;if(!t.enabled||!t.currentLine.enabled||!t.currentLine.details&&!t.currentLine.changes)return;const i=[];t.currentLine.changes&&i.push(s.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideChangesHover.bind(this)})),t.currentLine.details&&i.push(s.languages.registerHoverProvider({pattern:e.document.uri.fsPath},{provideHover:this.provideDetailsHover.bind(this)})),this._hoverProviderDisposable=s.Disposable.from(...i)}unregister(){void 0!==this._hoverProviderDisposable&&(this._hoverProviderDisposable.dispose(),this._hoverProviderDisposable=void 0)}}const Ri=Object.create(null),Ei=["left","right",",",".","escape"],Bi=[];class Ni{constructor(e){this.mapping=e;for(const t in e)e[t]=e[t]||Ri}async dispose(){const e=Bi.indexOf(this.mapping);H.log("KeyboardScope.dispose",Bi.length,e),e===Bi.length-1?(Bi.pop(),await this.updateKeyCommandsContext(Bi[Bi.length-1])):Bi.splice(e,1)}async begin(){return Bi.push(this.mapping),await this.updateKeyCommandsContext(this.mapping),this}async clearKeyCommand(e){const t=Bi[Bi.length-1];t===this.mapping&&t[e]&&(H.log("KeyboardScope.clearKeyCommand",Bi.length,e),t[e]=void 0,await E(`${F.Key}:${e}`,!1))}async setKeyCommand(e,t){const i=Bi[Bi.length-1];i===this.mapping&&(H.log("KeyboardScope.setKeyCommand",Bi.length,e,!!i[e]),i[e]?i[e]=t:(i[e]=t,await E(`${F.Key}:${e}`,!0)))}async updateKeyCommandsContext(e){const t=[];for(const i of Ei)t.push(E(`${F.Key}:${i}`,!(!e||!e[i])));await Promise.all(t)}}class Ai{constructor(){const e=Ei.map(e=>s.commands.registerCommand(`${x}.key.${e}`,()=>this.execute(e),this));this._disposable=s.Disposable.from(...e)}dispose(){this._disposable&&this._disposable.dispose()}async beginScope(e){return H.log("Keyboard.beginScope",Bi.length),await new Ni(e?Object.assign(Object.create(null),e):Object.create(null)).begin()}async execute(e){if(Bi.length)try{let t=Bi[Bi.length-1][e];if("function"==typeof t&&(t=await t()),!t||"function"!=typeof t.onDidPressKey)return;return H.log("Keyboard.execute",e),await t.onDidPressKey(e)}catch(e){return void H.error(e,"Keyboard.execute")}}}class Oi{constructor(){this._disposable=s.Disposable.from(ti.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ti.initializingChangeEvent)}dispose(){this.clearBlame(),this._blameStatusBarItem&&this._blameStatusBarItem.dispose(),this._modeStatusBarItem&&this._modeStatusBarItem.dispose(),Ts.lineTracker.stop(this),this._disposable&&this._disposable.dispose()}onConfigurationChanged(e){const t=ti.initializing(e);if(t||ti.changed(e,ti.name("mode").value)){const t=Ts.config.mode.active&&Ts.config.mode.statusBar.enabled?Ts.config.modes[Ts.config.mode.active]:void 0;if(t&&t.statusBarItemName){const i="left"!==Ts.config.mode.statusBar.alignment?s.StatusBarAlignment.Right:s.StatusBarAlignment.Left;ti.changed(e,ti.name("mode")("statusBar")("alignment").value)&&void 0!==this._modeStatusBarItem&&this._modeStatusBarItem.alignment!==i&&(this._modeStatusBarItem.dispose(),this._modeStatusBarItem=void 0),this._modeStatusBarItem=this._modeStatusBarItem||s.window.createStatusBarItem(i,i===s.StatusBarAlignment.Right?999:1),this._modeStatusBarItem.command=ji.SwitchMode,this._modeStatusBarItem.text=t.statusBarItemName,this._modeStatusBarItem.tooltip="Switch GitLens Mode",this._modeStatusBarItem.show()}else void 0!==this._modeStatusBarItem&&(this._modeStatusBarItem.dispose(),this._modeStatusBarItem=void 0)}if(t||ti.changed(e,ti.name("statusBar").value))if(Ts.config.statusBar.enabled){const i="left"!==Ts.config.statusBar.alignment?s.StatusBarAlignment.Right:s.StatusBarAlignment.Left;ti.changed(e,ti.name("statusBar")("alignment").value)&&void 0!==this._blameStatusBarItem&&this._blameStatusBarItem.alignment!==i&&(this._blameStatusBarItem.dispose(),this._blameStatusBarItem=void 0),this._blameStatusBarItem=this._blameStatusBarItem||s.window.createStatusBarItem(i,i===s.StatusBarAlignment.Right?1e3:0),this._blameStatusBarItem.command=Ts.config.statusBar.command,(t||ti.changed(e,ti.name("statusBar")("enabled").value))&&Ts.lineTracker.start(this,s.Disposable.from(Ts.lineTracker.onDidChangeActiveLines(this.onActiveLinesChanged,this)))}else ti.changed(e,ti.name("statusBar")("enabled").value)&&(Ts.lineTracker.stop(this),void 0!==this._blameStatusBarItem&&(this._blameStatusBarItem.dispose(),this._blameStatusBarItem=void 0))}onActiveLinesChanged(e){let t=!(Ts.config.statusBar.reduceFlicker&&"selection"===e.reason&&(e.pending||void 0!==e.lines));if(!e.pending&&void 0!==e.lines){const i=Ts.lineTracker.getState(e.lines[0]);if(void 0!==i&&void 0!==i.commit)return void this.updateBlame(i.commit,e.editor);t=!0}t&&this.clearBlame()}clearBlame(){void 0!==this._blameStatusBarItem&&this._blameStatusBarItem.hide()}updateBlame(e,t){const i=Ts.config.statusBar;if(i.enabled&&void 0!==this._blameStatusBarItem&&N(t)){switch(this._blameStatusBarItem.text=`$(git-commit) ${be.fromTemplate(i.format,e,{truncateMessageAtNewLine:!0,dateFormat:null===i.dateFormat?Ts.config.defaultDateFormat:i.dateFormat})}`,i.command){case C.ToggleFileBlame:this._blameStatusBarItem.tooltip="Toggle Blame Annotations";break;case C.DiffWithPrevious:this._blameStatusBarItem.command=ji.DiffLineWithPrevious,this._blameStatusBarItem.tooltip="Compare Line Revision with Previous";break;case C.DiffWithWorking:this._blameStatusBarItem.command=ji.DiffLineWithWorking,this._blameStatusBarItem.tooltip="Compare Line Revision with Working";break;case C.ToggleCodeLens:this._blameStatusBarItem.tooltip="Toggle Git CodeLens";break;case C.ShowQuickCommitDetails:this._blameStatusBarItem.tooltip="Show Commit Details";break;case C.ShowQuickCommitFileDetails:this._blameStatusBarItem.tooltip="Show Line Commit Details";break;case C.ShowQuickFileHistory:this._blameStatusBarItem.tooltip="Show File History";break;case C.ShowQuickCurrentBranchHistory:this._blameStatusBarItem.tooltip="Show Branch History"}this._blameStatusBarItem.show()}}}class Li{constructor(){this._onDidChangeActiveLines=new s.EventEmitter,this._state=new Map}get onDidChangeActiveLines(){return this._onDidChangeActiveLines.event}dispose(){this.stop()}onActiveTextEditorChanged(e){this._editor!==e&&(void 0===e||N(e))&&(this.reset(),this._editor=e,this._lines=void 0!==e?e.selections.map(e=>e.active.line):void 0,this.trigger("editor"))}onTextEditorSelectionChanged(e){if(this._editor!==e.textEditor&&!N(e.textEditor))return;const t=this._editor===e.textEditor?"selection":"editor",i=e.selections.map(e=>e.active.line);this._editor===e.textEditor&&this.includesAll(i)||(this.reset(),this._editor=e.textEditor,this._lines=i,this.trigger(t))}getState(e){return this._state.get(e)}setState(e,t){this._state.set(e,t)}get lines(){return this._lines}includes(e){return void 0!==this._lines&&this._lines.includes(e)}includesAll(e){return Li.includesAll(e,this._lines)}refresh(){this.trigger("editor")}reset(){this._state.clear()}start(e,t){void 0===this._disposable&&(this._disposable=s.Disposable.from(s.window.onDidChangeActiveTextEditor(J.debounce(this.onActiveTextEditorChanged,0),this),s.window.onDidChangeTextEditorSelection(this.onTextEditorSelectionChanged,this)),setImmediate(()=>this.onActiveTextEditorChanged(s.window.activeTextEditor)))}stop(e){void 0!==this._disposable&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this._disposable.dispose(),this._disposable=void 0)}async fireLinesChanged(e){this._onDidChangeActiveLines.fire(e)}trigger(e){this.onLinesChanged({editor:this._editor,lines:this._lines,reason:e})}onLinesChanged(e){void 0!==e.lines?(void 0===this._linesChangedDebounced&&(this._linesChangedDebounced=J.debounce(e=>{s.window.activeTextEditor===e.editor&&Li.includesAll(e.lines,e.editor&&e.editor.selections.map(e=>e.active.line))&&this.fireLinesChanged(e)},250,{track:!0})),this._linesChangedDebounced.pending()||this.fireLinesChanged(Object.assign({},e,{pending:!0})),this._linesChangedDebounced(e)):setImmediate(()=>{s.window.activeTextEditor===e.editor&&(void 0!==this._linesChangedDebounced&&this._linesChangedDebounced.cancel(),this.fireLinesChanged(e))})}static includesAll(e,t){return void 0===e&&void 0===t||void 0!==e&&void 0!==t&&(t.length===e.length&&t.every((t,i)=>t===e[i]))}}class Ui{constructor(e,t){this.commit=e,this.logCommit=t}}class Ii extends Li{constructor(){super(...arguments),this._count=0,this._subscriptions=new Map,this._suspended=!1}async fireLinesChanged(e){this.reset();let t=!1;return this._suspended||e.pending||void 0===e.lines||void 0===e.editor||(t=await this.updateState(e.lines,e.editor)),super.fireLinesChanged(t?e:Object.assign({},e,{lines:void 0}))}onBlameStateChanged(e){this.trigger("editor")}onDirtyIdleTriggered(e){const t=Ts.config.advanced.blame.sizeThresholdAfterEdit;t>0&&e.document.lineCount>t||this.resume()}async onDirtyStateChanged(e){e.dirty?this.suspend():this.resume({force:!0})}resume(e={}){(e.force||this._suspended)&&(this._suspended=!1,this.trigger("editor"))}suspend(e={}){!e.force&&this._suspended||(this._suspended=!0,this.trigger("editor"))}isSubscribed(e){return this._subscriptions.has(e)}start(e,t){this.isSubscribed(e)||(this._subscriptions.set(e,t),this._count++,1===this._count&&(super.start(),this._disposable=s.Disposable.from(this._disposable,Ts.tracker.onDidChangeBlameState(this.onBlameStateChanged,this),Ts.tracker.onDidChangeDirtyState(this.onDirtyStateChanged,this),Ts.tracker.onDidTriggerDirtyIdle(this.onDirtyIdleTriggered,this))))}stop(e){const t=this._subscriptions.get(e);void 0!==t&&(this._subscriptions.delete(e),t.dispose(),void 0!==this._disposable?(this._count--,0===this._count&&super.stop()):this._count=0)}async updateState(e,t){const i=await Ts.tracker.getOrAdd(t.document);if(!i.isBlameable||!this.includesAll(e))return!1;if(1===e.length){const s=t.document.isDirty?await Ts.git.getBlameForLineContents(i.uri,e[0],t.document.getText()):await Ts.git.getBlameForLine(i.uri,e[0]);if(void 0===s)return!1;this.setState(s.line.line,new Ui(s.commit))}else{const s=t.document.isDirty?await Ts.git.getBlameForFileContents(i.uri,t.document.getText()):await Ts.git.getBlameForFile(i.uri);if(void 0===s)return!1;for(const t of e){const e=s.lines[t];this.setState(t,new Ui(s.commits.get(e.sha)))}}return!(!i.isBlameable||!this.includesAll(e))&&(t.document.isDirty&&i.setForceDirtyStateChangeOnNextDocumentChange(),!0)}}var Mi,Wi,Hi,ji;!function(e){e.ActiveEditorChanged="active-editor-changed",e.AutoRefreshChanged="auto-refresh-changed",e.Command="command",e.ConfigurationChanged="configuration",e.NodeCommand="node-command",e.RepoChanged="repo-changed",e.ViewChanged="view-changed",e.VisibleEditorsChanged="visible-editors-changed"}(Mi||(Mi={})),function(e){e.Branch="gitlens:branch",e.BranchWithTracking="gitlens:branch:tracking",e.Branches="gitlens:branches",e.BranchesWithRemotes="gitlens:branches:remotes",e.CurrentBranch="gitlens:branch:current",e.CurrentBranchWithTracking="gitlens:branch:current:tracking",e.RemoteBranch="gitlens:branch:remote",e.Commit="gitlens:commit",e.CommitOnCurrentBranch="gitlens:commit:current",e.CommitFile="gitlens:file:commit",e.Commits="gitlens:commits",e.ComparisonResults="gitlens:results:comparison",e.FileHistory="gitlens:history-file",e.Folder="gitlens:folder",e.History="gitlens:history",e.Message="gitlens:message",e.Pager="gitlens:pager",e.Remote="gitlens:remote",e.Remotes="gitlens:remotes",e.Repositories="gitlens:repositories",e.Repository="gitlens:repository",e.Results="gitlens:results",e.ResultsCommits="gitlens:results:commits",e.ResultsFiles="gitlens:results:files",e.SearchResults="gitlens:results:search",e.Stash="gitlens:stash",e.StashFile="gitlens:file:stash",e.Stashes="gitlens:stashes",e.Status="gitlens:status",e.StatusFile="gitlens:file:status",e.StatusFiles="gitlens:status:files",e.StatusFileCommits="gitlens:status:file-commits",e.StatusUpstream="gitlens:status:upstream",e.Tag="gitlens:tag",e.Tags="gitlens:tags"}(Wi||(Wi={}));class Gi{constructor(e){this.uri=e,this.supportsPaging=!1}dispose(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0),this.resetChildren()}getCommand(){}refresh(){}resetChildren(){void 0!==this.children&&(this.children.forEach(e=>e.dispose()),this.children=void 0)}}class Vi extends Gi{get repoPath(){return this.uri.repoPath}}class zi extends Gi{constructor(e,t,i){super(new _e),this.message=e,this.tooltip=t,this.iconPath=i}getChildren(){return[]}getTreeItem(){const e=new s.TreeItem(this.message,s.TreeItemCollapsibleState.None);return e.contextValue=Wi.Message,e.tooltip=this.tooltip,e.iconPath=this.iconPath,e}}class Qi extends Gi{constructor(e,t,i){super(new _e),this.message=e,this.node=t,this.explorer=i,this.args={}}getChildren(){return[]}getTreeItem(){const e=new s.TreeItem(this.message,s.TreeItemCollapsibleState.None);return e.contextValue=Wi.Pager,e.command=this.getCommand(),e.iconPath={dark:Ts.context.asAbsolutePath("images/dark/icon-unfold.svg"),light:Ts.context.asAbsolutePath("images/light/icon-unfold.svg")},e}getCommand(){return{title:"Refresh",command:this.explorer.getQualifiedCommand("refreshNode"),arguments:[this.node,this.args]}}}class qi extends Qi{constructor(e,t,i){super(`${e} ${T.Space}${T.Dash}${T.Space} this may take a while`,t,i),this.args={maxCount:0}}}!function(e){e[e.CommitLabel=1]="CommitLabel",e[e.FileLabel=2]="FileLabel",e[e.CommitIcon=4]="CommitIcon",e[e.StatusIcon=8]="StatusIcon",e[e.Gravatar=16]="Gravatar",e[e.File=10]="File"}(Hi||(Hi={}));class Ki extends Vi{constructor(e,t,i,s){super(_e.fromFileStatus(e,t.repoPath,t.sha)),this.status=e,this.commit=t,this.explorer=i,this.displayAs=s,this.priority=!1}get ref(){return this.commit.sha}async getChildren(){return[]}async getTreeItem(){if(!this.commit.isFile){const e=this.commit.toFileCommit(this.status);if(void 0===e){const e=await Ts.git.getLogForFile(this.repoPath,this.status.fileName,{maxCount:2,ref:this.commit.sha});void 0!==e&&(this.commit=e.commits.get(this.commit.sha)||this.commit)}else this.commit=e}const e=new s.TreeItem(this.label,s.TreeItemCollapsibleState.None);if(e.contextValue=this.resourceType,e.tooltip=this.tooltip,(this.displayAs&Hi.CommitIcon)===Hi.CommitIcon)e.iconPath={dark:Ts.context.asAbsolutePath(y.join("images","dark","icon-commit.svg")),light:Ts.context.asAbsolutePath(y.join("images","light","icon-commit.svg"))};else if((this.displayAs&Hi.StatusIcon)===Hi.StatusIcon){const t=De(this.status.status);e.iconPath={dark:Ts.context.asAbsolutePath(y.join("images","dark",t)),light:Ts.context.asAbsolutePath(y.join("images","light",t))}}else(this.displayAs&Hi.Gravatar)===Hi.Gravatar&&(e.iconPath=this.commit.getGravatarUri(Ts.config.defaultGravatarsStyle));return e.command=this.getCommand(),this._label=void 0,this._tooltip=void 0,e}get folderName(){return void 0===this._folderName&&(this._folderName=y.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=this.displayAs&Hi.CommitLabel?be.fromTemplate(this.getCommitTemplate(),this.commit,{truncateMessageAtNewLine:!0,dateFormat:Ts.config.defaultDateFormat}):Pe.fromTemplate(this.getCommitFileTemplate(),this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0,this._tooltip=void 0}get resourceType(){return Wi.CommitFile}get tooltip(){return void 0===this._tooltip&&(this.displayAs&Hi.CommitLabel?this._tooltip=be.fromTemplate(this.commit.isUncommitted?`\${author} ${T.Dash} \${id}\n\${ago} (\${date})`:`\${author} ${T.Dash} \${id}\n\${ago} (\${date})\n\n\${message}`,this.commit,{dateFormat:Ts.config.defaultDateFormat}):this._tooltip=Pe.fromTemplate("${file}\n${directory}/\n\n${status}",this.status)),this._tooltip}getCommitTemplate(){return this.explorer.config.commitFormat}getCommitFileTemplate(){return this.explorer.config.commitFileFormat}getCommand(){return{title:"Compare File with Previous Revision",command:ji.DiffWithPrevious,arguments:[_e.fromFileStatus(this.status,this.commit.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class Yi extends Gi{constructor(e,t,i,s,o){super(_e.fromRepoPath(e)),this.repoPath=e,this.folderName=t,this.relativePath=i,this.root=s,this.explorer=o,this.priority=!0}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];let e;if(Yi.getFileNesting(this.explorer.config.files,this.root.descendants,void 0===this.relativePath)!==g.List){e=[];for(const t of j.values(this.root.children))void 0!==t.value?(t.value.relativePath=this.root.relativePath,e.push(t.value)):e.push(new Yi(this.repoPath,t.name,t.relativePath,t,this.explorer))}else this.root.descendants.forEach(e=>e.relativePath=this.root.relativePath),e=this.root.descendants;return e.sort((e,t)=>(e instanceof Yi?-1:1)-(t instanceof Yi?-1:1)||(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label)),e}async getTreeItem(){const e=new s.TreeItem(this.label,s.TreeItemCollapsibleState.Collapsed);return e.contextValue=Wi.Folder,e.iconPath=s.ThemeIcon.Folder,e.tooltip=this.label,e}get label(){return this.folderName}static getFileNesting(e,t,i){const s=e.layout||g.Auto;if(s===g.Auto){if(i||e.compact){const i=e.threshold||5;if(t.length<=i)return g.List}return g.Tree}return s}}class Xi extends Vi{constructor(e,t,i,s){super(e.toGitUri()),this.commit=e,this.explorer=t,this.branch=i,this.getBranchTips=s}get ref(){return this.commit.sha}async getChildren(){const e=this.commit;let t=[...ee.map(e.fileStatuses,t=>new Ki(t,e.toFileCommit(t),this.explorer,Hi.File))];if(this.explorer.config.files.layout!==g.List){const e=G.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>ae.normalizePath(y.join(...e)),this.explorer.config.files.compact),i=new Yi(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>e.label.localeCompare(t.label));return t}getTreeItem(){let e=be.fromTemplate(this.explorer.config.commitFormat,this.commit,{truncateMessageAtNewLine:!0,dateFormat:Ts.config.defaultDateFormat});const t=this.getBranchTips&&this.getBranchTips(this.commit.sha);void 0!==t&&(e=`${T.AngleBracketLeftHeavy}${T.SpaceThin}${t}${T.SpaceThin}${T.AngleBracketRightHeavy}${T.ArrowHeadRight}${T.Space} ${e}`);const i=new s.TreeItem(e,s.TreeItemCollapsibleState.Collapsed);return i.contextValue=void 0===this.branch||this.branch.current?Wi.CommitOnCurrentBranch:Wi.Commit,this.explorer.config.avatars?i.iconPath=this.commit.getGravatarUri(Ts.config.defaultGravatarsStyle):i.iconPath={dark:Ts.context.asAbsolutePath("images/dark/icon-commit.svg"),light:Ts.context.asAbsolutePath("images/light/icon-commit.svg")},i.tooltip=be.fromTemplate(this.commit.isUncommitted?`\${author} ${T.Dash} \${id}\n\${ago} (\${date})`:`\${author} ${T.Dash} \${id}${void 0!==t?` (${t})`:""}\n\${ago} (\${date})\n\n\${message}`,this.commit,{dateFormat:Ts.config.defaultDateFormat}),i}getCommand(){return{title:"Compare File with Previous Revision",command:ji.DiffWithPrevious,arguments:[this.uri,{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class Zi extends Vi{constructor(e,t,i){super(t),this.branch=e,this.explorer=i,this.supportsPaging=!0}get current(){return this.branch.current}get label(){const e=this.branch.getName();return this.explorer.config.branches.layout===u.List?e:this.current||Ce.isDetached(e)?e:this.branch.getBasename()}get markCurrent(){return!0}get ref(){return this.branch.ref}async getChildren(){const e=await Ts.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.ref});if(void 0===e)return[new zi("No commits yet")];const t=await Ts.git.getBranches(this.uri.repoPath),i=t[0].sha.length,s=G.groupByFilterMap(t,e=>e.sha,e=>e.name===this.branch.name?void 0:e.name),o=e=>{const t=s.get(e.substr(0,i));if(void 0!==t&&0!==t.length)return t.join(", ")},a=[...ee.map(e.commits.values(),e=>new Xi(e,this.explorer,this.branch,o))];return e.truncated&&a.push(new qi("Show All Commits",this,this.explorer)),a}async getTreeItem(){let e=this.label,t=`${this.branch.getName()}${this.current?" (current)":""}`,i="";this.branch.remote||void 0===this.branch.tracking||(this.explorer.config.showTrackingBranch&&(e+=`${this.branch.getTrackingStatus({prefix:`${T.Space} `})}${T.Space} ${T.ArrowLeftRightLong}${T.Space} ${this.branch.tracking}`),t+=`\n\nTracking ${T.Dash} ${this.branch.tracking}\n${this.branch.getTrackingStatus({empty:"up-to-date",expand:!0,separator:"\n"})}`,(this.branch.state.ahead||this.branch.state.behind)&&(this.branch.state.behind&&(i="-red"),this.branch.state.ahead&&(i=this.branch.state.behind?"-yellow":"-green")));const o=new s.TreeItem(`${this.markCurrent&&this.current?`${T.Check} ${T.Space}`:""}${e}`,s.TreeItemCollapsibleState.Collapsed);return o.tooltip=t,this.branch.remote?o.contextValue=Wi.RemoteBranch:this.current?o.contextValue=this.branch.tracking?Wi.CurrentBranchWithTracking:Wi.CurrentBranch:o.contextValue=this.branch.tracking?Wi.BranchWithTracking:Wi.Branch,o.iconPath={dark:Ts.context.asAbsolutePath(`images/dark/icon-branch${i}.svg`),light:Ts.context.asAbsolutePath(`images/light/icon-branch${i}.svg`)},o}}class Ji extends Gi{constructor(e,t,i,s,o){super(_e.fromRepoPath(e)),this.repoPath=e,this.folderName=t,this.relativePath=i,this.root=s,this.explorer=o}async getChildren(){if(void 0===this.root.descendants||void 0===this.root.children)return[];const e=[];for(const t of j.values(this.root.children))void 0!==t.value?e.push(t.value):e.push(new Ji(this.repoPath,t.name,t.relativePath,t,this.explorer));return e}async getTreeItem(){const e=new s.TreeItem(this.label,s.TreeItemCollapsibleState.Collapsed);return e.contextValue=Wi.Folder,e.iconPath=s.ThemeIcon.Folder,e.tooltip=this.label,e}get label(){return this.folderName}}class es extends Gi{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:branches`}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>(e.current?-1:1)-(t.current?-1:1)||e.name.localeCompare(t.name));const t=[...ee.filterMap(e,e=>e.remote?void 0:new Zi(e,this.uri,this.explorer))];if(this.explorer.config.branches.layout===u.List)return t;const i=t.length>0&&t[0].current?t.splice(0,1)[0]:void 0,s=G.makeHierarchical(t,e=>e.branch.detached?[e.branch.name]:e.branch.getName().split("/"),(...e)=>e.join("/"),this.explorer.config.files.compact),o=new Ji(this.repo.path,"",void 0,s,this.explorer),a=await o.getChildren();return void 0!==i&&a.splice(0,0,i),a}async getTreeItem(){const e=new s.TreeItem("Branches",s.TreeItemCollapsibleState.Collapsed),t=await this.repo.getRemotes();return e.contextValue=void 0!==t&&t.length>0?Wi.BranchesWithRemotes:Wi.Branches,e.iconPath={dark:Ts.context.asAbsolutePath("images/dark/icon-branch.svg"),light:Ts.context.asAbsolutePath("images/light/icon-branch.svg")},e}}class ts extends Gi{constructor(e,t,i,s){super(t),this.remote=e,this.repo=i,this.explorer=s}async getChildren(){const e=await this.repo.getBranches();if(void 0===e)return[];e.sort((e,t)=>e.name.localeCompare(t.name));const t=[...ee.filterMap(e,e=>e.remote&&e.name.startsWith(this.remote.name)?new Zi(e,this.uri,this.explorer):void 0)];if(this.explorer.config.branches.layout===u.List)return t;const i=G.makeHierarchical(t,e=>e.branch.detached?[e.branch.name]:e.branch.getName().split("/"),(...e)=>e.join("/"),this.explorer.config.files.compact),s=new Ji(this.repo.path,"",void 0,i,this.explorer);return await s.getChildren()}getTreeItem(){const e=this.remote.types.find(e=>e.type===We.Fetch),t=this.remote.types.find(e=>e.type===We.Push);let i;i=e&&t?T.ArrowLeftRightLong:e?T.ArrowLeft:t?T.ArrowRight:T.Dash;const o=`${this.remote.name} ${T.Space}${i}${T.Space} ${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain} ${T.Space}${T.Dot}${T.Space} ${this.remote.path}`,a=new s.TreeItem(o,s.TreeItemCollapsibleState.Collapsed);return a.contextValue=Wi.Remote,a.tooltip=`${this.remote.name}\n${this.remote.path} (${void 0!==this.remote.provider?this.remote.provider.name:this.remote.domain})`,void 0!==this.remote.provider?a.iconPath={dark:Ts.context.asAbsolutePath(`images/dark/icon-${this.remote.provider.icon}.svg`),light:Ts.context.asAbsolutePath(`images/light/icon-${this.remote.provider.icon}.svg`)}:a.iconPath={dark:Ts.context.asAbsolutePath("images/dark/icon-remote.svg"),light:Ts.context.asAbsolutePath("images/light/icon-remote.svg")},a}}class is extends Gi{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:remotes`}async getChildren(){const e=await this.repo.getRemotes();return void 0===e||0===e.length?[new zi("No remotes configured")]:(e.sort((e,t)=>e.name.localeCompare(t.name)),[...ee.map(e,e=>new ts(e,this.uri,this.repo,this.explorer))])}getTreeItem(){const e=new s.TreeItem("Remotes",s.TreeItemCollapsibleState.Collapsed);return e.contextValue=Wi.Remotes,e.iconPath={dark:Ts.context.asAbsolutePath("images/dark/icon-remote.svg"),light:Ts.context.asAbsolutePath("images/light/icon-remote.svg")},e}}class ss extends Ki{constructor(e,t,i){super(e,t,i,Hi.File)}get resourceType(){return Wi.StashFile}getCommitTemplate(){return this.explorer.config.stashFormat}getCommitFileTemplate(){return this.explorer.config.stashFileFormat}}class os extends Vi{constructor(e,t){super(e.toGitUri()),this.commit=e,this.explorer=t}get ref(){return this.commit.sha}async getChildren(){const e=this.commit.fileStatuses,t=await Ts.git.getLog(this.commit.repoPath,{maxCount:1,ref:`${this.commit.stashName}^3`});if(void 0!==t){const i=ee.first(t.commits.values());void 0!==i&&0!==i.fileStatuses.length&&(i.fileStatuses.forEach(e=>e.status="?"),e.splice(e.length,0,...i.fileStatuses))}const i=e.map(e=>new ss(e,this.commit.toFileCommit(e),this.explorer));return i.sort((e,t)=>e.label.localeCompare(t.label)),i}getTreeItem(){const e=new s.TreeItem(be.fromTemplate(this.explorer.config.stashFormat,this.commit,{truncateMessageAtNewLine:!0,dateFormat:Ts.config.defaultDateFormat}),s.TreeItemCollapsibleState.Collapsed);return e.contextValue=Wi.Stash,e.tooltip=be.fromTemplate("${ago} (${date})\n\n${message}",this.commit,{dateFormat:Ts.config.defaultDateFormat}),e}}class as extends Gi{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:stashes`}async getChildren(){const e=await this.repo.getStashList();return void 0===e?[new zi("No stashed changes")]:[...ee.map(e.commits.values(),e=>new os(e,this.explorer))]}getTreeItem(){const e=new s.TreeItem("Stashes",s.TreeItemCollapsibleState.Collapsed);return e.contextValue=Wi.Stashes,e.iconPath={dark:Ts.context.asAbsolutePath("images/dark/icon-stash.svg"),light:Ts.context.asAbsolutePath("images/light/icon-stash.svg")},e}}class rs extends Gi{constructor(e,t,i,s){super(_e.fromFileStatus(t,e,"HEAD")),this.repoPath=e,this.status=t,this.commits=i,this.explorer=s}async getChildren(){return this.commits.map(e=>new Ki(this.status,e,this.explorer,Hi.CommitLabel|(this.explorer.config.avatars?Hi.Gravatar:Hi.CommitIcon)))}async getTreeItem(){const e=new s.TreeItem(this.label,s.TreeItemCollapsibleState.Collapsed);1===this.commits.length&&this.commit.isUncommitted?(e.collapsibleState=s.TreeItemCollapsibleState.None,e.contextValue=Wi.StatusFile,this.commit.isStagedUncommitted?e.tooltip=Pe.fromTemplate("${status} in index\n\n${file}\n${directory}/",this.status):e.tooltip=Pe.fromTemplate("${status} in working tree\n\n${file}\n${directory}/",this.status),e.command=this.getCommand()):(e.contextValue=Wi.StatusFileCommits,e.tooltip=Pe.fromTemplate(`\${status} in ${this.getChangedIn()}\n\n\${file}\n\${directory}/`,this.status));const t=De(this.status.status);return e.iconPath={dark:Ts.context.asAbsolutePath(y.join("images","dark",t)),light:Ts.context.asAbsolutePath(y.join("images","light",t))},this._label=void 0,e.tooltip=e.tooltip.charAt(0).toUpperCase()+e.tooltip.slice(1),e}get folderName(){return void 0===this._folderName&&(this._folderName=y.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Pe.fromTemplate(this.explorer.config.statusFileFormat,Object.assign({},this.status,{commit:this.commit}),{relativePath:this.relativePath})),this._label}get commit(){return this.commits[0]}get priority(){return this.commit.isUncommitted}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}getChangedIn(){const e=[];let t=0;for(const i of this.commits)i.isUncommitted?i.isStagedUncommitted?e.push("working tree"):e.push("index"):t++;return t>0&&e.push(ae.pluralize("commit",t)),e.length>2&&(e[e.length-1]=`and ${e[e.length-1]}`),e.join(e.length>2?", ":" and ")}getCommand(){return{title:"Compare File with Previous Revision",command:ji.DiffWithPrevious,arguments:[_e.fromFileStatus(this.status,this.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class ns extends Gi{constructor(e,t,i,s=!1){super(_e.fromRepoPath(e.repoPath)),this.status=e,this.range=t,this.explorer=i,this.active=s,this.supportsPaging=!0,this.repoPath=e.repoPath}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:files`}async getChildren(){let e=[];const t=this.repoPath;let i;void 0!==this.range&&void 0!==(i=await Ts.git.getLog(t,{maxCount:this.maxCount,ref:this.range}))&&(e=Array.from(ee.flatMap(i.commits.values(),e=>e.fileStatuses.map(t=>Object.assign({},t,{commit:e}))))),0!==this.status.files.length&&this.includeWorkingTree&&e.splice(0,0,...ee.flatMap(this.status.files,e=>{if(void 0!==e.workTreeStatus&&void 0!==e.indexStatus){const i=new Date;return i.setMilliseconds(i.getMilliseconds()-1),[Object.assign({},e,{status:e.status,commit:new Me(Re.File,t,Zt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,Zt.stagedUncommittedSha,e.fileName)}),Object.assign({},e,{status:e.status,commit:new Me(Re.File,t,Zt.stagedUncommittedSha,"You",void 0,i,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]}return void 0!==e.indexStatus?[Object.assign({},e,{status:e.status,commit:new Me(Re.File,t,Zt.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]:[Object.assign({},e,{status:e.status,commit:new Me(Re.File,t,Zt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName)})]})),e.sort((e,t)=>t.commit.date.getTime()-e.commit.date.getTime());const s=G.groupBy(e,e=>e.fileName);let o=[...ee.map(j.values(s),e=>new rs(t,e[e.length-1],e.map(e=>e.commit),this.explorer))];if(this.explorer.config.files.layout!==g.List){const e=G.makeHierarchical(o,e=>e.uri.getRelativePath().split("/"),(...e)=>ae.normalizePath(y.join(...e)),this.explorer.config.files.compact),i=new Yi(t,"",void 0,e,this.explorer);o=await i.getChildren()}else o.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return void 0!==i&&i.truncated&&o.push(new qi("Show All Changes",this,this.explorer)),o}async getTreeItem(){let e=void 0!==this.status.files&&this.includeWorkingTree?this.status.files.length:0;if(void 0!==this.status.upstream&&this.status.state.ahead>0)if(e>0){const t=await Ts.git.getDiffStatus(this.repoPath,`${this.status.upstream}...`);if(void 0!==t){const i=new Set;for(const e of this.status.files)i.add(e.fileName);for(const e of t)i.add(e.fileName);e=i.size}}else{const t=await Ts.git.getChangedFilesCount(this.repoPath,`${this.status.upstream}...`);void 0!==t&&(e+=t.files)}const t=`${ae.pluralize("file",e)} changed`,i=new s.TreeItem(t,s.TreeItemCollapsibleState.Collapsed);return i.id=this.id,i.contextValue=Wi.StatusFiles,i.iconPath={dark:Ts.context.asAbsolutePath("images/dark/icon-diff.svg"),light:Ts.context.asAbsolutePath("images/light/icon-diff.svg")},i}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}}class ls extends Gi{constructor(e,t,i,s=!1){super(_e.fromRepoPath(e.repoPath)),this.status=e,this.direction=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.status.repoPath})${this.active?":active":""}:status:upstream:${this.direction}`}async getChildren(){const e="ahead"===this.direction?`${this.status.upstream}..${this.status.ref}`:`${this.status.ref}..${this.status.upstream}`;let t=await Ts.git.getLog(this.uri.repoPath,{maxCount:0,ref:e});if(void 0===t)return[];if("ahead"!==this.direction)return[...ee.map(t.commits.values(),e=>new Xi(e,this.explorer))];const i=Array.from(t.commits.values()),s=i[i.length-1];return void 0===s.previousSha&&void 0!==(t=await Ts.git.getLog(this.uri.repoPath,{maxCount:2,ref:s.sha}))&&(i[i.length-1]=ee.first(t.commits.values())),[...ee.map(i,e=>new Xi(e,this.explorer))]}async getTreeItem(){const e="ahead"===this.direction,t=e?`${ae.pluralize("commit",this.status.state.ahead)} ahead`:`${ae.pluralize("commit",this.status.state.behind)} behind`,i=new s.TreeItem(t,s.TreeItemCollapsibleState.Collapsed);i.id=this.id,i.contextValue=Wi.StatusUpstream,i.tooltip=`${t}${e?" of ":""}${this.status.upstream}`;const o=e?"upload":"download";return i.iconPath={dark:Ts.context.asAbsolutePath(`images/dark/icon-${o}.svg`),light:Ts.context.asAbsolutePath(`images/light/icon-${o}.svg`)},i}}class cs extends Gi{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:status`}async getChildren(){this.resetChildren();const e=[],t=await this.repo.getStatus();if(void 0!==t&&(t.state.behind&&e.push(new ls(t,"behind",this.explorer,this.active)),t.state.ahead&&e.push(new ls(t,"ahead",this.explorer,this.active)),t.state.ahead||0!==t.files.length&&this.includeWorkingTree)){const i=t.upstream?`${t.upstream}..${t.ref}`:void 0;e.push(new ns(t,i,this.explorer,this.active))}let i=await this.repo.getBranch();return void 0!==i&&(void 0!==t&&(i=new Ce(i.repoPath,i.name,i.current,i.sha,i.tracking,t.state.ahead,t.state.behind,i.detached)),e.push(new hs(i,this.uri,this.explorer))),this.children=e,this.children}async getTreeItem(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0);const e=await this.repo.getStatus();if(void 0===e)return new s.TreeItem("No repo status");this.explorer.autoRefresh&&this.includeWorkingTree&&(this.disposable=s.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChangeFileSystem(this.onFileSystemChanged,this),{dispose:()=>this.repo.stopWatchingFileSystem()}),this.repo.startWatchingFileSystem());let t=!1;const i=0!==e.files.length&&this.includeWorkingTree;let o,a=`${e.getUpstreamStatus({prefix:`${T.Space} `})}${i?e.getDiffStatus({prefix:`${T.Space} `}):""}`,r=`${e.branch} (current)`,n="";e.upstream&&(this.explorer.config.showTrackingBranch&&(a+=`${T.Space} ${T.ArrowLeftRightLong}${T.Space} ${e.upstream}`),r+=`\n\nTracking ${T.Dash} ${e.upstream}\n${e.getUpstreamStatus({empty:"up-to-date",expand:!0,separator:"\n"})}`,(e.state.ahead||e.state.behind)&&(t=!0,e.state.behind&&(n="-red"),e.state.ahead&&(n=e.state.behind?"-yellow":"-green"))),i&&(r+=`\n\nHas uncommitted changes${e.getDiffStatus({expand:!0,prefix:"\n",separator:"\n"})}`),o=(t||i)&&this.active?s.TreeItemCollapsibleState.Expanded:s.TreeItemCollapsibleState.Collapsed;const l=new s.TreeItem(`${e.branch}${a}`,o);return l.id=this.id,l.contextValue=Wi.Status,l.tooltip=r,l.iconPath={dark:Ts.context.asAbsolutePath(`images/dark/icon-repo${n}.svg`),light:Ts.context.asAbsolutePath(`images/light/icon-repo${n}.svg`)},l}get includeWorkingTree(){return this.explorer.config.includeWorkingTree}onAutoRefreshChanged(){void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}async onFileSystemChanged(e){this.explorer.refreshNode(this)}}class hs extends Zi{constructor(e,t,i){super(e,t,i)}get markCurrent(){return!1}async getTreeItem(){const e=await super.getTreeItem();return e.label.startsWith("(")&&e.label.endsWith(")")?e.label=`History ${e.label}`:e.label=`History (${e.label})`,e}}class ds extends Vi{constructor(e,t,i){super(t),this.tag=e,this.explorer=i,this.supportsPaging=!0}get label(){return this.explorer.config.branches.layout===u.Tree?this.tag.getBasename():this.tag.name}get ref(){return this.tag.name}async getChildren(){const e=await Ts.git.getLog(this.uri.repoPath,{maxCount:this.maxCount,ref:this.tag.name});if(void 0===e)return[new zi("No commits yet")];const t=[...ee.map(e.commits.values(),e=>new Xi(e,this.explorer))];return e.truncated&&t.push(new qi("Show All Commits",this,this.explorer)),t}async getTreeItem(){const e=new s.TreeItem(this.label,s.TreeItemCollapsibleState.Collapsed);return e.tooltip=`${this.tag.name}${void 0===this.tag.annotation?"":`\n${this.tag.annotation}`}`,e.contextValue=Wi.Tag,e}}class ms extends Gi{constructor(e,t,i,s=!1){super(e),this.repo=t,this.explorer=i,this.active=s}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}:tags`}async getChildren(){const e=await this.repo.getTags();if(0===e.length)return[new zi("No tags yet")];e.sort((e,t)=>e.name.localeCompare(t.name));const t=[...e.map(e=>new ds(e,this.uri,this.explorer))];if(this.explorer.config.branches.layout===u.List)return t;const i=G.makeHierarchical(t,e=>e.tag.name.split("/"),(...e)=>e.join("/"),this.explorer.config.files.compact),s=new Ji(this.repo.path,"",void 0,i,this.explorer);return await s.getChildren()}async getTreeItem(){const e=new s.TreeItem("Tags",s.TreeItemCollapsibleState.Collapsed);return e.contextValue=Wi.Tags,e.iconPath={dark:Ts.context.asAbsolutePath("images/dark/icon-tag.svg"),light:Ts.context.asAbsolutePath("images/light/icon-tag.svg")},e}}class us extends Gi{constructor(e,t,i,s=!1,o){super(e),this.repo=t,this.explorer=i,this.active=s,this.activeParent=o}get id(){return`gitlens:repository(${this.repo.path})${this.active?":active":""}`}async getChildren(){return void 0===this.children&&(this.updateSubscription(),this.children=[new cs(this.uri,this.repo,this.explorer,this.active),new es(this.uri,this.repo,this.explorer,this.active),new is(this.uri,this.repo,this.explorer,this.active),new as(this.uri,this.repo,this.explorer,this.active),new ms(this.uri,this.repo,this.explorer,this.active)]),this.children}getTreeItem(){this.updateSubscription();const e=this.active?`Active Repository ${ae.pad(T.Dash,1,1)} ${this.repo.formattedName||this.uri.repoPath}`:`${this.repo.formattedName||this.uri.repoPath}`,t=new s.TreeItem(e,this.active?s.TreeItemCollapsibleState.Expanded:s.TreeItemCollapsibleState.Collapsed);return t.id=this.id,t.contextValue=Wi.Repository,t}refresh(){this.resetChildren(),this.updateSubscription()}updateSubscription(){this.explorer.autoRefresh?this.disposable=this.disposable||s.Disposable.from(this.explorer.onDidChangeAutoRefresh(this.onAutoRefreshChanged,this),this.repo.onDidChange(this.onRepoChanged,this)):void 0!==this.disposable&&(this.disposable.dispose(),this.disposable=void 0)}onAutoRefreshChanged(){this.updateSubscription()}onRepoChanged(e){if(H.log(`RepositoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),void 0===this.children||e.changed(lt.Repository)||e.changed(lt.Config))this.explorer.refreshNode(this.active&&void 0!==this.activeParent?this.activeParent:this);else{if(e.changed(lt.Stashes)){const e=this.children.find(e=>e instanceof as);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(lt.Remotes)){const e=this.children.find(e=>e instanceof is);void 0!==e&&this.explorer.refreshNode(e)}if(e.changed(lt.Tags)){const e=this.children.find(e=>e instanceof ms);void 0!==e&&this.explorer.refreshNode(e)}}}}class gs extends Gi{constructor(e){super(void 0),this.explorer=e,Ts.context.subscriptions.push(s.window.onDidChangeActiveTextEditor(J.debounce(this.onActiveEditorChanged,500),this)),this.onActiveEditorChanged(s.window.activeTextEditor)}dispose(){super.dispose(),void 0!==this._repositoryNode&&(this._repositoryNode.dispose(),this._repositoryNode=void 0)}get id(){return"gitlens:repository:active"}async onActiveEditorChanged(e){if(void 0!==e&&!N(e))return;let t=!1;try{const i=await Ts.git.getActiveRepoPath(e);if(void 0===i)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));if(void 0!==this._repositoryNode&&this._repositoryNode.repo.path===i)return;const s=await Ts.git.getRepository(i);if(void 0===s||s.closed)return void(void 0!==this._repositoryNode&&(t=!0,this._repositoryNode.dispose(),this._repositoryNode=void 0));t=!0,void 0!==this._repositoryNode&&this._repositoryNode.dispose(),this._repositoryNode=new us(_e.fromRepoPath(s.path),s,this.explorer,!0,this)}finally{t&&this.explorer.refreshNode(this)}}async getChildren(){return void 0!==this._repositoryNode?this._repositoryNode.getChildren():[]}getTreeItem(){const e=void 0!==this._repositoryNode?this._repositoryNode.getTreeItem():new s.TreeItem("No active repository",s.TreeItemCollapsibleState.None);return e.id=this.id,e}}class ps extends Gi{constructor(e,t){super(e.toGitUri()),this.commit=e,this.explorer=t}getChildren(){return[new Xi(this.commit,this.explorer)]}getTreeItem(){const e=new s.TreeItem(`1 result for commits with an id matching '${this.commit.shortSha}'`,s.TreeItemCollapsibleState.Expanded);return e.contextValue=Wi.Results,e}}class fs extends Gi{constructor(e,t,i,s,o=Wi.ResultsCommits){super(_e.fromRepoPath(e)),this.repoPath=e,this.labelFn=t,this.logFn=i,this.explorer=s,this.contextValue=o,this.supportsPaging=!0}async getChildren(){const e=await this.getLog();if(void 0===e)return[];const t=[...ee.map(e.commits.values(),e=>new Xi(e,this.explorer))];return e.truncated&&t.push(new qi("Show All Results",this,this.explorer)),t}async getTreeItem(){const e=await this.getLog(),t=new s.TreeItem(await this.getLabel(),e&&e.count>0?s.TreeItemCollapsibleState.Expanded:s.TreeItemCollapsibleState.None);return t.contextValue=this.contextValue,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await this.logFn(this.maxCount);this._cache={label:await this.labelFn(e),log:e}}return this._cache}async getLabel(){return(await this.ensureCache()).label}async getLog(){return(await this.ensureCache()).log}}class vs extends Gi{constructor(e,t,i,s,o){super(_e.fromFileStatus(t,e,i||(s||void 0))),this.repoPath=e,this.status=t,this.ref1=i,this.ref2=s,this.explorer=o}getChildren(){return[]}getTreeItem(){const e=new s.TreeItem(this.label,s.TreeItemCollapsibleState.None);e.contextValue=Wi.StatusFile,e.tooltip=Pe.fromTemplate("${file}\n${directory}/\n\n${status}",this.status);const t=De(this.status.status);return e.iconPath={dark:Ts.context.asAbsolutePath(y.join("images","dark",t)),light:Ts.context.asAbsolutePath(y.join("images","light",t))},e.command=this.getCommand(),e}get folderName(){return void 0===this._folderName&&(this._folderName=y.dirname(this.uri.getRelativePath())),this._folderName}get label(){return void 0===this._label&&(this._label=Pe.fromTemplate(this.explorer.config.statusFileFormat,this.status,{relativePath:this.relativePath})),this._label}get relativePath(){return this._relativePath}set relativePath(e){this._relativePath=e,this._label=void 0}get priority(){return!1}getCommand(){return{title:"Open Changes",command:ji.DiffWith,arguments:[this.uri,{lhs:{sha:this.ref1,uri:this.uri},rhs:{sha:this.ref2,uri:"R"===this.status.status?_e.fromFileStatus(this.status,this.uri.repoPath,this.ref2,!0):this.uri},repoPath:this.uri.repoPath,line:0,showOptions:{preserveFocus:!0,preview:!0}}]}}}class ws extends Gi{constructor(e,t,i,s){super(_e.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s,this.supportsPaging=!0}async getChildren(){const e=await this.getDiff();if(void 0===e)return[];let t=[...ee.map(e,e=>new vs(this.repoPath,e,this.ref1,this.ref2,this.explorer))];if(this.explorer.config.files.layout!==g.List){const e=G.makeHierarchical(t,e=>e.uri.getRelativePath().split("/"),(...e)=>ae.normalizePath(y.join(...e)),this.explorer.config.files.compact),i=new Yi(this.repoPath,"",void 0,e,this.explorer);t=await i.getChildren()}else t.sort((e,t)=>(e.priority?-1:1)-(t.priority?-1:1)||e.label.localeCompare(t.label));return t}async getTreeItem(){const e=await this.getDiff(),t=new s.TreeItem(await this.getLabel(),e&&e.length>0?s.TreeItemCollapsibleState.Expanded:s.TreeItemCollapsibleState.None);return t.contextValue=Wi.ResultsFiles,t}refresh(){this._cache=void 0}async ensureCache(){if(void 0===this._cache){const e=await Ts.git.getDiffStatus(this.uri.repoPath,this.ref1,this.ref2),t=void 0!==e?e.length:0,i=`${ae.pluralize("file",t,{zero:"No"})} changed`;this._cache={label:i,diff:e}}return this._cache}async getDiff(){return(await this.ensureCache()).diff}async getLabel(){return(await this.ensureCache()).label}}class bs extends Gi{constructor(e,t,i,s){super(_e.fromRepoPath(e)),this.repoPath=e,this.ref1=t,this.ref2=i,this.explorer=s}async getChildren(){this.resetChildren();return this.children=[new fs(this.uri.repoPath,async e=>{const t=void 0!==e?e.count:0,i=void 0!==e&&e.truncated;return ae.pluralize("commit",t,{number:i?`${t}+`:void 0,zero:"No"})},e=>Ts.git.getLog(this.uri.repoPath,{maxCount:e,ref:`${this.ref1.ref}...${this.ref2.ref||"HEAD"}`}),this.explorer),new ws(this.uri.repoPath,this.ref1.ref,this.ref2.ref,this.explorer)],this.children}async getTreeItem(){let e="";if(await Ts.git.getRepositoryCount()>1){const t=await Ts.git.getRepository(this.uri.repoPath);e=` ${ae.pad(T.Dash,1,1)} ${t&&t.formattedName||this.uri.repoPath}`}const t=new s.TreeItem(`Comparing ${this.ref1.label||Zt.shortenSha(this.ref1.ref,{working:"Working Tree"})} to ${this.ref2.label||Zt.shortenSha(this.ref2.ref,{working:"Working Tree"})}${e}`,s.TreeItemCollapsibleState.Expanded);return t.contextValue=Wi.ComparisonResults,t}}class _s extends Gi{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){this.updateSubscription();const e=[],t=Hi.CommitLabel|(this.explorer.config.avatars?Hi.Gravatar:Hi.StatusIcon),i=await Ts.git.getStatusForFile(this.uri.repoPath,this.uri.fsPath);if(void 0!==i&&(void 0!==i.indexStatus||void 0!==i.workTreeStatus)){let s,o;void 0!==i.workTreeStatus?(s=Zt.uncommittedSha,void 0!==i.indexStatus?o=Zt.stagedUncommittedSha:"?"!==i.workTreeStatus&&(o="HEAD")):(s=Zt.stagedUncommittedSha,o="HEAD");const a=new Me(Re.File,this.uri.repoPath,s,"You",void 0,new Date,"",i.fileName,[i],i.status,i.originalFileName,o,i.originalFileName||i.fileName);e.push(new Ki(i,a,this.explorer,t))}const s=await Ts.git.getLogForFile(this.uri.repoPath,this.uri.fsPath,{ref:this.uri.sha});return void 0!==s&&e.push(...ee.map(s.commits.values(),e=>new Ki(e.fileStatuses[0],e,this.explorer,t))),0===e.length?[new zi("No file history")]:e}getTreeItem(){this.updateSubscription();const e=new s.TreeItem(`${this.uri.getFormattedPath()}`,s.TreeItemCollapsibleState.Expanded);return e.contextValue=Wi.FileHistory,e.tooltip=`History of ${this.uri.getFilename()}\n${this.uri.getDirectory()}/`,e.iconPath={dark:Ts.context.asAbsolutePath("images/dark/icon-history.svg"),light:Ts.context.asAbsolutePath("images/light/icon-history.svg")},e}updateSubscription(){this.disposable||(this.disposable=s.Disposable.from(this.repo.onDidChange(this.onRepoChanged,this),this.repo.onDidChangeFileSystem(this.onRepoFileSystemChanged,this),{dispose:()=>this.repo.stopWatchingFileSystem()}),this.repo.startWatchingFileSystem())}onRepoChanged(e){e.changed(lt.Repository)&&(H.log(`FileHistoryNode.onRepoChanged(${e.changes.join()}); triggering node refresh`),this.explorer.refreshNode(this))}onRepoFileSystemChanged(e){e.uris.some(e=>e.toString()===this.uri.toString())&&(H.log("FileHistoryNode.onRepoFileSystemChanged; triggering node refresh"),this.explorer.refreshNode(this))}}class Cs extends Gi{constructor(e,t,i){super(e),this.repo=t,this.explorer=i}async getChildren(){return this.resetChildren(),this.children=[new _s(this.uri,this.repo,this.explorer)],this.children}getTreeItem(){const e=new s.TreeItem(`${this.uri.getFormattedPath()}`,s.TreeItemCollapsibleState.Expanded);return e.contextValue=Wi.History,e.iconPath={dark:Ts.context.asAbsolutePath("images/dark/icon-history.svg"),light:Ts.context.asAbsolutePath("images/light/icon-history.svg")},e}}class ys extends Gi{constructor(e,t){super(void 0),this.repositories=e,this.explorer=t}async getChildren(){return void 0===this.children&&(this.children=this.repositories.sort((e,t)=>e.index-t.index).filter(e=>!e.closed).map(e=>new us(_e.fromRepoPath(e.path),e,this.explorer)),this.children.length>1&&this.children.splice(0,0,new gs(this.explorer))),this.children}refresh(){this.resetChildren()}getTreeItem(){const e=new s.TreeItem("Repositories",s.TreeItemCollapsibleState.Expanded);return e.contextValue=Wi.Repositories,e}}class xs{constructor(){s.commands.registerCommand("gitlens.explorers.openChanges",this.openChanges,this),s.commands.registerCommand("gitlens.explorers.openChangesWithWorking",this.openChangesWithWorking,this),s.commands.registerCommand("gitlens.explorers.openFile",this.openFile,this),s.commands.registerCommand("gitlens.explorers.openFileRevision",this.openFileRevision,this),s.commands.registerCommand("gitlens.explorers.openFileRevisionInRemote",this.openFileRevisionInRemote,this),s.commands.registerCommand("gitlens.explorers.openChangedFiles",this.openChangedFiles,this),s.commands.registerCommand("gitlens.explorers.openChangedFileChanges",this.openChangedFileChanges,this),s.commands.registerCommand("gitlens.explorers.openChangedFileChangesWithWorking",this.openChangedFileChangesWithWorking,this),s.commands.registerCommand("gitlens.explorers.openChangedFileRevisions",this.openChangedFileRevisions,this),s.commands.registerCommand("gitlens.explorers.applyChanges",this.applyChanges,this),s.commands.registerCommand("gitlens.explorers.closeRepository",this.closeRepository,this),s.commands.registerCommand("gitlens.explorers.compareAncestryWithWorking",this.compareAncestryWithWorking,this),s.commands.registerCommand("gitlens.explorers.compareWithHead",this.compareWithHead,this),s.commands.registerCommand("gitlens.explorers.compareWithRemote",this.compareWithRemote,this),s.commands.registerCommand("gitlens.explorers.compareWithSelected",this.compareWithSelected,this),s.commands.registerCommand("gitlens.explorers.compareWithWorking",this.compareWithWorking,this),s.commands.registerCommand("gitlens.explorers.selectForCompare",this.selectForCompare,this),s.commands.registerCommand("gitlens.explorers.terminalCheckoutBranch",this.terminalCheckoutBranch,this),s.commands.registerCommand("gitlens.explorers.terminalCreateBranch",this.terminalCreateBranch,this),s.commands.registerCommand("gitlens.explorers.terminalDeleteBranch",this.terminalDeleteBranch,this),s.commands.registerCommand("gitlens.explorers.terminalMergeBranch",this.terminalMergeBranch,this),s.commands.registerCommand("gitlens.explorers.terminalRebaseBranch",this.terminalRebaseBranch,this),s.commands.registerCommand("gitlens.explorers.terminalRebaseBranchToRemote",this.terminalRebaseBranchToRemote,this),s.commands.registerCommand("gitlens.explorers.terminalSquashBranchIntoCommit",this.terminalSquashBranchIntoCommit,this),s.commands.registerCommand("gitlens.explorers.terminalCheckoutCommit",this.terminalCheckoutCommit,this),s.commands.registerCommand("gitlens.explorers.terminalCherryPickCommit",this.terminalCherryPickCommit,this),s.commands.registerCommand("gitlens.explorers.terminalPushCommit",this.terminalPushCommit,this),s.commands.registerCommand("gitlens.explorers.terminalRebaseCommit",this.terminalRebaseCommit,this),s.commands.registerCommand("gitlens.explorers.terminalResetCommit",this.terminalResetCommit,this),s.commands.registerCommand("gitlens.explorers.terminalRevertCommit",this.terminalRevertCommit,this),s.commands.registerCommand("gitlens.explorers.terminalRemoveRemote",this.terminalRemoveRemote,this),s.commands.registerCommand("gitlens.explorers.terminalCreateTag",this.terminalCreateTag,this),s.commands.registerCommand("gitlens.explorers.terminalDeleteTag",this.terminalDeleteTag,this)}dispose(){this._disposable&&this._disposable.dispose()}async applyChanges(e){await this.openFile(e),void 0!==e.uri.sha&&"HEAD"!==e.uri.sha&&await Ts.git.checkoutFile(e.uri)}closeRepository(e){(e instanceof us||e instanceof cs)&&(e.repo.closed=!0)}compareWithHead(e){e instanceof Vi&&Ts.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"HEAD")}compareWithRemote(e){e.branch.tracking&&Ts.resultsExplorer.showComparisonInResults(e.repoPath,e.branch.tracking,e.ref)}compareWithWorking(e){e instanceof Vi&&Ts.resultsExplorer.showComparisonInResults(e.repoPath,e.ref,"")}async compareAncestryWithWorking(e){const t=await Ts.git.getBranch(e.repoPath);if(void 0===t)return;const i=await Ts.git.getMergeBase(e.repoPath,t.ref,e.ref);void 0!==i&&Ts.resultsExplorer.showComparisonInResults(e.repoPath,{ref:i,label:`ancestry with ${e.ref} (${Zt.shortenSha(i)})`},"")}compareWithSelected(e){if(void 0!==this._selection&&e instanceof Vi&&this._selection.repoPath===e.repoPath)if(void 0===this._selection.uri)Ts.resultsExplorer.showComparisonInResults(this._selection.repoPath,this._selection.ref,e.ref);else{if(!(e instanceof Ki))return;const t={repoPath:this._selection.repoPath,lhs:{sha:this._selection.ref,uri:this._selection.uri},rhs:{sha:e.ref,uri:e.uri}};s.commands.executeCommand(ji.DiffWith,t)}}selectForCompare(e){e instanceof Vi&&(this._selection={ref:e.ref,repoPath:e.repoPath,uri:e instanceof Ki?e.uri:void 0},E(F.ExplorersCanCompare,!0))}openChanges(e){const t=e.getCommand();if(void 0===t||void 0===t.arguments)return;const[i,o]=t.arguments;return o.showOptions.preview=!1,s.commands.executeCommand(t.command,i,o)}openChangesWithWorking(e){const t={commit:e.commit,showOptions:{preserveFocus:!0,preview:!1}};return s.commands.executeCommand(ji.DiffWithWorking,e.commit.toGitUri(),t)}openFile(e){return Do(e.uri,{preserveFocus:!0,preview:!1})}openFileRevision(e,t={showOptions:{preserveFocus:!0,preview:!1}}){return Do(t.uri||("D"===e.commit.status?_e.toRevisionUri(e.commit.previousSha,e.commit.previousUri.fsPath,e.commit.repoPath):_e.toRevisionUri(e.uri)),t.showOptions||{preserveFocus:!0,preview:!1})}async openChangedFileChanges(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=e.commit.fileStatuses.map(e=>_e.fromFileStatus(e,i));for(const o of s)await this.openDiffWith(i,{uri:o,sha:void 0!==e.commit.previousSha?e.commit.previousSha:Zt.deletedSha},{uri:o,sha:e.commit.sha},t)}async openChangedFileChangesWithWorking(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=G.filterMap(e.commit.fileStatuses,e=>"D"!==e.status?_e.fromFileStatus(e,i):void 0);for(const o of s)await this.openDiffWith(i,{uri:o,sha:e.commit.sha},{uri:o,sha:""},t)}async openChangedFiles(e,t={preserveFocus:!1,preview:!1}){const i=e.commit.repoPath,s=G.filterMap(e.commit.fileStatuses,e=>_e.fromFileStatus(e,i));for(const e of s)await Do(e,t)}async openChangedFileRevisions(e,t={preserveFocus:!1,preview:!1}){const i=G.filterMap(e.commit.fileStatuses,t=>_e.toRevisionUri("D"===t.status?e.commit.previousFileSha:e.commit.sha,t,e.commit.repoPath));for(const e of i)await Do(e,t)}async openDiffWith(e,t,i,o={preserveFocus:!1,preview:!1}){const a={repoPath:e,lhs:t,rhs:i,showOptions:o};return s.commands.executeCommand(ji.DiffWith,a)}async openFileRevisionInRemote(e){return s.commands.executeCommand(ji.OpenFileInRemote,e.commit.toGitUri("D"===e.commit.status),{range:!1})}async terminalCheckoutBranch(e){e instanceof Zi&&this.sendTerminalCommand("checkout",`${e.ref}`,e.repoPath)}async terminalCreateBranch(e){if(!(e instanceof Vi))return;let t=!1,i=void 0;e instanceof Zi&&e.branch.remote&&(t=!0,i=e.branch.getName());const o=await s.window.showInputBox({prompt:"Please provide a branch name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Branch name",value:i});void 0!==o&&""!==o&&this.sendTerminalCommand("branch",`${t?"-t ":""}${o} ${e.ref}`,e.repoPath)}terminalDeleteBranch(e){e instanceof Zi&&(e.branch.remote?this.sendTerminalCommand("push",`${e.branch.getRemote()} :${e.branch.getName()}`,e.repoPath):this.sendTerminalCommand("branch",`-d ${e.ref}`,e.repoPath))}terminalMergeBranch(e){e instanceof Zi&&this.sendTerminalCommand("merge",`${e.ref}`,e.repoPath)}terminalRebaseBranch(e){e instanceof Zi&&this.sendTerminalCommand("rebase",`-i ${e.ref}`,e.repoPath)}terminalRebaseBranchToRemote(e){if(e instanceof Zi){if(!e.branch.current||!e.branch.tracking)return;this.sendTerminalCommand("rebase",`-i ${e.branch.tracking}`,e.repoPath)}else e instanceof ls&&this.sendTerminalCommand("rebase",`-i ${e.status.upstream}`,e.status.repoPath)}terminalSquashBranchIntoCommit(e){e instanceof Zi&&this.sendTerminalCommand("merge",`--squash ${e.ref}`,e.repoPath)}terminalCheckoutCommit(e){e instanceof Xi&&this.sendTerminalCommand("checkout",`${e.ref}`,e.repoPath)}terminalCherryPickCommit(e){e instanceof Xi&&this.sendTerminalCommand("cherry-pick",`-e ${e.ref}`,e.repoPath)}async terminalPushCommit(e){if(!(e instanceof Xi))return;const t=e.branch||await Ts.git.getBranch(e.repoPath);void 0!==t&&this.sendTerminalCommand("push",`${t.getRemote()} ${e.ref}:${t.getName()}`,e.repoPath)}terminalRebaseCommit(e){e instanceof Xi&&this.sendTerminalCommand("rebase",`-i ${e.ref}^`,e.repoPath)}terminalResetCommit(e){e instanceof Xi&&this.sendTerminalCommand("reset",`--soft ${e.ref}`,e.repoPath)}terminalRevertCommit(e){e instanceof Xi&&this.sendTerminalCommand("revert",`-e ${e.ref}`,e.repoPath)}terminalRemoveRemote(e){e instanceof ts&&this.sendTerminalCommand("remote",`remove ${e.remote.name}`,e.remote.repoPath)}async terminalCreateTag(e){if(!(e instanceof Vi))return;const t=await s.window.showInputBox({prompt:"Please provide a tag name (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag name"});if(void 0===t||""===t)return;const i=await s.window.showInputBox({prompt:"Please provide an optional message to annotate the tag (Press 'Enter' to confirm or 'Escape' to cancel)",placeHolder:"Tag message"});if(void 0===i)return;const o=`${""!==i?`-a -m "${i}" `:""}${t} ${e.ref}`;this.sendTerminalCommand("tag",o,e.repoPath)}terminalDeleteTag(e){e instanceof ds&&this.sendTerminalCommand("tag",`-d ${e.ref}`,e.repoPath)}ensureTerminal(e){return void 0===this._terminal&&(this._terminal=s.window.createTerminal(k),this._disposable=s.window.onDidCloseTerminal(e=>{e.name===k&&(this._terminal=void 0,this._disposable.dispose(),this._disposable=void 0)},this),Ts.context.subscriptions.push(this._disposable),this._terminalCwd=void 0),this._terminalCwd!==e&&(this._terminal.sendText(`cd "${e}"`,!0),this._terminalCwd=e),this._terminal}sendTerminalCommand(e,t,i){const s=this.ensureTerminal(i);s.show(!1),s.sendText(`git ${e} ${t}`,!1)}}class $s extends s.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeTreeData=new s.EventEmitter,Ts.explorerCommands,s.commands.registerCommand("gitlens.historyExplorer.refresh",this.refresh,this),s.commands.registerCommand("gitlens.historyExplorer.refreshNode",this.refreshNode,this),s.commands.registerCommand("gitlens.historyExplorer.close",()=>this.dock(!1),this),s.commands.registerCommand("gitlens.historyExplorer.dock",this.dock,this),s.commands.registerCommand("gitlens.historyExplorer.setRenameFollowingOn",()=>$s.setRenameFollowing(!0),this),s.commands.registerCommand("gitlens.historyExplorer.setRenameFollowingOff",()=>$s.setRenameFollowing(!1),this),Ts.context.subscriptions.push(s.window.onDidChangeActiveTextEditor(J.debounce(this.onActiveEditorChanged,500),this),s.window.onDidChangeVisibleTextEditors(J.debounce(this.onVisibleEditorsChanged,500),this),ti.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ti.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=ti.initializing(e);(t||ti.changed(e,ti.name("historyExplorer").value)||ti.changed(e,ti.name("explorers").value)||ti.changed(e,ti.name("defaultGravatarsStyle").value)||ti.changed(e,ti.name("advanced")("fileHistoryFollowsRenames").value))&&((t||ti.changed(e,ti.name("historyExplorer")("enabled").value)||ti.changed(e,ti.name("historyExplorer")("location").value))&&E(F.HistoryExplorer,!!this.config.enabled&&this.config.location),(t||ti.changed(e,ti.name("historyExplorer")("enabled").value))&&(this.config.enabled?this.undock(!t,!ti.changed(e,ti.name("mode").value)):this.dock(!t,!ti.changed(e,ti.name("mode").value))),t&&this.setRoot(await this.getRootNode(s.window.activeTextEditor)),(t||ti.changed(e,ti.name("historyExplorer")("location").value))&&(this._disposable&&(this._disposable.dispose(),this._onDidChangeTreeData=new s.EventEmitter),this._tree=s.window.createTreeView(`gitlens.historyExplorer:${this.config.location}`,{treeDataProvider:this}),this._disposable=this._tree),t||void 0===this._root||this.refresh(Mi.ConfigurationChanged))}async onActiveEditorChanged(e){const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(Mi.ActiveEditorChanged,t)}onVisibleEditorsChanged(e){void 0!==this._root&&(0!==e.length&&e.some(e=>e.document&&Ts.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(Mi.VisibleEditorsChanged)))}get config(){return Object.assign({},Ts.config.explorers,Ts.config.historyExplorer)}getParent(e){}async getChildren(e){return void 0===this._root?[new zi(`No active file ${T.Dash} no history to show`)]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}async dock(e=!0,t=!0){e&&await Ts.gitExplorer.switchTo(f.History),await E(F.HistoryExplorer,!1),t&&await ti.updateEffective(ti.name("historyExplorer")("enabled").value,!1)}getQualifiedCommand(e){return`gitlens.historyExplorer.${e}`}async refresh(e,t){void 0===e&&(e=Mi.Command),H.log("HistoryExplorer.refresh",`reason='${e}'`),void 0!==this._root&&void 0!==t||(this.clearRoot(),this.setRoot(await this.getRootNode(s.window.activeTextEditor))),this._onDidChangeTreeData.fire()}refreshNode(e,t){H.log(`HistoryExplorer.refreshNode(${e.id||""})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._root===e?void 0:e)}async show(){if(void 0!==this._root&&void 0!==this._tree)try{await this._tree.reveal(this._root,{select:!1})}catch(e){H.error(e)}}async undock(e=!0,t=!0){e&&await Ts.gitExplorer.switchTo(f.Repository),await E(F.HistoryExplorer,this.config.location),t&&await ti.updateEffective(ti.name("historyExplorer")("enabled").value,!0)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}getRootNode(e){return $s.getHistoryNode(this,e,this._root)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}static async getHistoryNode(e,t,i){if(null==t||0===s.window.visibleTextEditors.length||!s.window.visibleTextEditors.some(e=>e.document&&Ts.git.isTrackable(e.document.uri)))return;if(void 0===t.document||!Ts.git.isTrackable(t.document.uri))return i;let o=await _e.fromUri(t.document.uri);const a=await Ts.git.getRepository(o);if(void 0===a)return;let r;if(void 0!==o.sha){const[e,t]=await Ts.git.findWorkingFileName(o.fsPath,o.repoPath,o.sha);void 0!==e&&(r=s.Uri.file(void 0!==t?y.join(t,e):e))}return n.equals(r||o,i&&i.uri)?i:(void 0!==r&&(o=await _e.fromUri(r)),new Cs(o,a,e))}static setRenameFollowing(e){return ti.updateEffective(ti.name("advanced")("fileHistoryFollowsRenames").value,e)}}class Ss extends s.Disposable{constructor(){super(()=>this.dispose()),this._onDidChangeAutoRefresh=new s.EventEmitter,this._onDidChangeTreeData=new s.EventEmitter,Ts.explorerCommands,s.commands.registerCommand("gitlens.gitExplorer.refresh",this.refresh,this),s.commands.registerCommand("gitlens.gitExplorer.refreshNode",this.refreshNode,this),s.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(g.Auto),this),s.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToList",()=>this.setFilesLayout(g.List),this),s.commands.registerCommand("gitlens.gitExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(g.Tree),this),s.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOn",()=>this.setAutoRefresh(Ts.config.gitExplorer.autoRefresh,!0),this),s.commands.registerCommand("gitlens.gitExplorer.setAutoRefreshToOff",()=>this.setAutoRefresh(Ts.config.gitExplorer.autoRefresh,!1),this),s.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOn",()=>$s.setRenameFollowing(!0),this),s.commands.registerCommand("gitlens.gitExplorer.setRenameFollowingOff",()=>$s.setRenameFollowing(!1),this),s.commands.registerCommand("gitlens.gitExplorer.switchToHistoryView",()=>this.switchTo(f.History),this),s.commands.registerCommand("gitlens.gitExplorer.switchToRepositoryView",()=>this.switchTo(f.Repository),this),s.commands.registerCommand("gitlens.gitExplorer.undockHistory",this.undockHistory,this),Ts.context.subscriptions.push(s.window.onDidChangeActiveTextEditor(J.debounce(this.onActiveEditorChanged,500),this),s.window.onDidChangeVisibleTextEditors(J.debounce(this.onVisibleEditorsChanged,500),this),ti.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ti.initializingChangeEvent)}get onDidChangeAutoRefresh(){return this._onDidChangeAutoRefresh.event}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=ti.initializing(e);if(!(t||ti.changed(e,ti.name("gitExplorer").value)||ti.changed(e,ti.name("explorers").value)||ti.changed(e,ti.name("defaultGravatarsStyle").value)||ti.changed(e,ti.name("advanced")("fileHistoryFollowsRenames").value)))return;(t||ti.changed(e,ti.name("gitExplorer")("enabled").value)||ti.changed(e,ti.name("gitExplorer")("location").value))&&E(F.GitExplorer,!!this.config.enabled&&this.config.location),(t||ti.changed(e,ti.name("gitExplorer")("autoRefresh").value))&&this.setAutoRefresh(Ts.config.gitExplorer.autoRefresh);let i=this.view;if((t||ti.changed(e,ti.name("gitExplorer")("view").value))&&(i=this.config.view)===f.Auto&&(i=Ts.context.workspaceState.get(O.GitExplorerView,f.Repository)),t&&(this.view=i,E(F.GitExplorerView,this.view),this.setRoot(await this.getRootNode(s.window.activeTextEditor))),t||ti.changed(e,ti.name("gitExplorer")("location").value))return this._disposable&&(this._disposable.dispose(),this._onDidChangeTreeData=new s.EventEmitter),this._tree=s.window.createTreeView(`gitlens.gitExplorer:${this.config.location}`,{treeDataProvider:this}),void(this._disposable=this._tree);this.reset(i,ti.changed(e,ti.name("advanced")("fileHistoryFollowsRenames").value))}async onActiveEditorChanged(e){if(this.view!==f.History)return;const t=await this.getRootNode(e);this.setRoot(t)&&this.refresh(Mi.ActiveEditorChanged,t)}onRepositoriesChanged(){this.view===f.Repository&&(this.clearRoot(),H.log(`GitExplorer[view=${this.view}].onRepositoriesChanged`),this.refresh(Mi.RepoChanged))}onVisibleEditorsChanged(e){void 0!==this._root&&this.view===f.History&&(0!==e.length&&e.some(e=>e.document&&Ts.git.isTrackable(e.document.uri))||(this.clearRoot(),this.refresh(Mi.VisibleEditorsChanged)))}get autoRefresh(){return this.config.autoRefresh&&Ts.context.workspaceState.get(O.GitExplorerAutoRefresh,!0)}get config(){return Object.assign({},Ts.config.explorers,Ts.config.gitExplorer)}get view(){return this._view}set view(e){this._view=Ts.config.historyExplorer.enabled?f.Repository:e}getParent(){}async getChildren(e){return void 0!==this._loading&&(await this._loading,this._loading=void 0),void 0===this._root?[new zi(this.view===f.History?`No active file ${T.Dash} no history to show`:"No repositories found")]:void 0===e?this._root.getChildren():e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.gitExplorer.${e}`}async refresh(e,t){void 0===e&&(e=Mi.Command),H.log(`GitExplorer[view=${this.view}].refresh`,`reason='${e}'`),(void 0===this._root||void 0===t&&this.view===f.History)&&(this.clearRoot(),this.setRoot(await this.getRootNode(s.window.activeTextEditor))),void 0!==this._root&&this._root.refresh(),this._onDidChangeTreeData.fire()}refreshNode(e,t){H.log(`GitExplorer[view=${this.view}].refreshNode(${e.id||""})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(e===this._root?void 0:e)}async reset(e,t=!1){if(this.setView(e),t&&void 0!==this._root&&this.clearRoot(),this.setRoot(await this.getRootNode(s.window.activeTextEditor))||t)return this.refresh(Mi.ViewChanged)}async setAutoRefresh(e,t){void 0!==this._autoRefreshDisposable&&(this._autoRefreshDisposable.dispose(),this._autoRefreshDisposable=void 0);let i=!1;e&&(void 0===t?t=Ts.context.workspaceState.get(O.GitExplorerAutoRefresh,!0):(i=t,await Ts.context.workspaceState.update(O.GitExplorerAutoRefresh,t),this._onDidChangeAutoRefresh.fire()),t&&(this._autoRefreshDisposable=Ts.git.onDidChangeRepositories(this.onRepositoriesChanged,this),Ts.context.subscriptions.push(this._autoRefreshDisposable))),E(F.GitExplorerAutoRefresh,e&&t),i&&this.refresh(Mi.AutoRefreshChanged)}setView(e){this.view!==e&&(Ts.config.gitExplorer.view===f.Auto&&Ts.context.workspaceState.update(O.GitExplorerView,e),this.view=e,E(F.GitExplorerView,this.view),e!==f.Repository&&Ts.git.stopWatchingFileSystem())}async show(e){if(void 0===this._root||void 0===this._tree)return;await this.switchTo(e);const[t]=await this._root.getChildren();try{await this._tree.reveal(t,{select:!1})}catch(e){H.error(e)}}async switchTo(e){return this.view!==e&&(await this.reset(e,!0),!0)}clearRoot(){void 0!==this._root&&(this._root.dispose(),this._root=void 0)}async getRootNode(e){switch(this.view){case f.History:{const t=this.getHistoryNode(e||s.window.activeTextEditor);return this._loading=t.then(e=>J.wait(0)),t}default:{const e=Ts.git.getRepositories();this._loading=e.then(e=>J.wait(0));const t=[...await e];if(0===t.length)return;const i=t.filter(e=>!e.closed);if(0===i.length)return;if(1===i.length){const e=i[0];return new us(_e.fromRepoPath(e.path),e,this,!0)}return new ys(i,this)}}}getHistoryNode(e){return $s.getHistoryNode(this,e,this._root)}setFilesLayout(e){return ti.updateEffective(ti.name("gitExplorer")("files")("layout").value,e)}setRoot(e){return this._root!==e&&(void 0!==this._root&&this._root.dispose(),this._root=e,!0)}undockHistory(e=!0){return Ts.historyExplorer.undock(e)}}class ks{constructor(){this._roots=[],this._onDidChangeTreeData=new s.EventEmitter,this._enabled=!1,Ts.explorerCommands,s.commands.registerCommand("gitlens.resultsExplorer.refresh",this.refreshNodes,this),s.commands.registerCommand("gitlens.resultsExplorer.refreshNode",this.refreshNode,this),s.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToAuto",()=>this.setFilesLayout(g.Auto),this),s.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToList",()=>this.setFilesLayout(g.List),this),s.commands.registerCommand("gitlens.resultsExplorer.setFilesLayoutToTree",()=>this.setFilesLayout(g.Tree),this),s.commands.registerCommand("gitlens.resultsExplorer.clearResultsNode",this.clearResultsNode,this),s.commands.registerCommand("gitlens.resultsExplorer.close",this.close,this),s.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOn",()=>this.setKeepResults(!0),this),s.commands.registerCommand("gitlens.resultsExplorer.setKeepResultsToOff",()=>this.setKeepResults(!1),this),s.commands.registerCommand("gitlens.resultsExplorer.swapComparision",this.swapComparision,this),E(F.ResultsExplorerKeepResults,this.keepResults),Ts.context.subscriptions.push(ti.onDidChange(this.onConfigurationChanged,this)),this.onConfigurationChanged(ti.initializingChangeEvent)}get onDidChangeTreeData(){return this._onDidChangeTreeData.event}dispose(){this._disposable&&this._disposable.dispose()}async onConfigurationChanged(e){const t=ti.initializing(e);(t||ti.changed(e,ti.name("resultsExplorer").value)||ti.changed(e,ti.name("explorers").value)||ti.changed(e,ti.name("defaultGravatarsStyle").value))&&((t||ti.changed(e,ti.name("resultsExplorer")("location").value))&&E(F.ResultsExplorer,!!this.enabled&&this.config.location),(t||ti.changed(e,ti.name("resultsExplorer")("location").value))&&(this._disposable&&(this._disposable.dispose(),this._onDidChangeTreeData=new s.EventEmitter),this._tree=s.window.createTreeView(`gitlens.resultsExplorer:${this.config.location}`,{treeDataProvider:this}),this._disposable=this._tree),t||0===this._roots.length||this.refresh(Mi.ConfigurationChanged))}get config(){return Object.assign({},Ts.config.explorers,Ts.config.resultsExplorer)}get enabled(){return this._enabled}get keepResults(){return Ts.context.workspaceState.get(O.ResultsExplorerKeepResults,!1)}close(){this.clearResults(),this._enabled=!1,E(F.ResultsExplorer,!1)}getParent(e){}async getChildren(e){return 0===this._roots.length?[new zi("No results")]:void 0===e?this._roots:e.getChildren()}async getTreeItem(e){return e.getTreeItem()}getQualifiedCommand(e){return`gitlens.resultsExplorer.${e}`}async refresh(e){void 0===e&&(e=Mi.Command),H.log("ResultsExplorer.refresh",`reason='${e}'`),this._onDidChangeTreeData.fire()}refreshNode(e,t){H.log(`ResultsExplorer.refreshNode(${e.id||""})`),void 0!==t&&e.supportsPaging&&(e.maxCount=t.maxCount),e.refresh(),this._onDidChangeTreeData.fire(this._roots.includes(e)?void 0:e)}refreshNodes(){H.log("ResultsExplorer.refreshNodes"),this._roots.forEach(e=>e.refresh()),this._onDidChangeTreeData.fire()}async show(){if(void 0!==this._roots&&0!==this._roots.length&&void 0!==this._tree)try{await this._tree.reveal(this._roots[0],{select:!1})}catch(e){H.error(e)}}showComparisonInResults(e,t,i){this.showResults(this.addResults(new bs(e,"string"==typeof t?{ref:t}:t,"string"==typeof i?{ref:i}:i,this)))}showCommitInResults(e){this.showResults(this.addResults(new ps(e,this)))}showCommitsInResults(e,t){const i=void 0===e.query?t=>Promise.resolve(e):e.query;this.showResults(this.addResults(new fs(e.repoPath,async i=>{if("string"==typeof t)return t;const s=void 0!==i?i.count:0,o=void 0!==i&&i.truncated,a=void 0===t.resultsType?{singular:"result",plural:"results"}:t.resultsType;let r="";if(await Ts.git.getRepositoryCount()>1){const t=await Ts.git.getRepository(e.repoPath);r=` ${ae.pad(T.Dash,1,1)} ${t&&t.formattedName||e.repoPath}`}return`${ae.pluralize(a.singular,s,{number:o?`${s}+`:void 0,plural:a.plural,zero:"No"})} for ${t.label}${r}`},J.seeded(i,e),this,Wi.SearchResults)))}async showResults(e){this._enabled=!0,await E(F.ResultsExplorer,this.config.location),setTimeout(()=>this._tree.reveal(e,{select:!0}),250)}addResults(e){return this._roots.includes(e)?e:(this._roots.length>0&&!this.keepResults&&this.clearResults(),this._roots.splice(0,0,e),this.refreshNode(e),e)}clearResults(){0!==this._roots.length&&(this._roots.forEach(e=>e.dispose()),this._roots=[],this.refresh())}clearResultsNode(e){const t=this._roots.findIndex(t=>t===e);-1!==t&&(this._roots.splice(t,1),e.dispose(),this.refresh())}setFilesLayout(e){return ti.updateEffective(ti.name("resultsExplorer")("files")("layout").value,e)}setKeepResults(e){Ts.context.workspaceState.update(O.ResultsExplorerKeepResults,e),E(F.ResultsExplorerKeepResults,e)}swapComparision(e){e instanceof bs&&this.showComparisonInResults(e.repoPath,e.ref2,e.ref1)}}class Ds{constructor(){this._disposable=s.Disposable.from(ti.onDidChange(this.onConfigurationChanged,this),...this.registerCommands())}dispose(){this._disposable&&this._disposable.dispose(),this._disposablePanel&&this._disposablePanel.dispose()}onConfigurationChanged(e){this.postUpdatedConfiguration()}onPanelDisposed(){this._disposablePanel&&this._disposablePanel.dispose(),this._panel=void 0}onViewStateChanged(e){if(H.log("WebviewEditor.onViewStateChanged",e.webviewPanel.visible),this._invalidateOnVisible&&e.webviewPanel.visible){const e=this._invalidateOnVisible;switch(this._invalidateOnVisible=void 0,e){case"config":this.postUpdatedConfiguration();break;default:this.show()}}}async onMessageReceived(e){if(null!=e)switch(H.log(`WebviewEditor.onMessageReceived: type=${e.type}, data=${JSON.stringify(e)}`),e.type){case"saveSettings":const t="workspace"===e.scope?s.ConfigurationTarget.Workspace:s.ConfigurationTarget.Global;for(const i in e.changes){const s=await ti.inspect(i),o=e.changes[i];await ti.update(i,o===s.defaultValue?void 0:o,t)}for(const i of e.removes)await ti.update(i,void 0,t)}}get visible(){return void 0!==this._panel&&this._panel.visible}hide(){void 0!==this._panel&&this._panel.dispose()}async show(){let e=(await this.getHtml()).replace(/{{root}}/g,s.Uri.file(Ts.context.asAbsolutePath(".")).with({scheme:"vscode-resource"}).toString());e.includes("'{{bootstrap}}'")&&(e=e.replace("'{{bootstrap}}'",JSON.stringify(this.getBootstrap()))),void 0===this._panel?(this._panel=s.window.createWebviewPanel(this.id,this.title,s.ViewColumn.Active,{retainContextWhenHidden:!0,enableFindWidget:!0,enableCommandUris:!0,enableScripts:!0}),this._disposablePanel=s.Disposable.from(this._panel,this._panel.onDidDispose(this.onPanelDisposed,this),this._panel.onDidChangeViewState(this.onViewStateChanged,this),this._panel.webview.onDidReceiveMessage(this.onMessageReceived,this)),this._panel.webview.html=e):(this._panel.webview.html=e,this._panel.reveal(s.ViewColumn.Active))}async getHtml(){if(H.isDebugging)return new Promise((e,t)=>{U.readFile(Ts.context.asAbsolutePath(this.filename),"utf8",(i,s)=>{i?t(i):e(s)})});return(await s.workspace.openTextDocument(Ts.context.asAbsolutePath(this.filename))).getText()}postMessage(e,t="all"){if(void 0===this._panel)return!1;const i=this._panel.webview.postMessage(e);return i||"all"===this._invalidateOnVisible||(this._invalidateOnVisible=t),i}postUpdatedConfiguration(){return this.postMessage({type:"settingsChanged",config:ti.get()},"config")}}class Fs extends Ds{constructor(){super()}get filename(){return"settings.html"}get id(){return"gitlens.settings"}get title(){return"GitLens Settings"}getBootstrap(){return{config:ti.get(),scope:"user",scopes:this.getAvailableScopes()}}registerCommands(){return[s.commands.registerCommand("gitlens.showSettingsPage",this.show,this)]}getAvailableScopes(){const e=[["user","User"]];return void 0!==s.workspace.workspaceFolders&&s.workspace.workspaceFolders.length&&e.push(["workspace","Workspace"]),e}}class Ps extends Ds{constructor(){super()}get filename(){return"welcome.html"}get id(){return"gitlens.welcome"}get title(){return"Welcome to GitLens"}getBootstrap(){return{config:Ts.config}}registerCommands(){return[s.commands.registerCommand("gitlens.showWelcomePage",this.show,this)]}}class Ts{static initialize(e,t){if(this._context=e,this._config=Ts.applyMode(t),e.subscriptions.push(this._lineTracker=new Ii),e.subscriptions.push(this._tracker=new qt),e.subscriptions.push(this._git=new Zt),this._tracker.initialize(),e.subscriptions.push(this._fileAnnotationController=new wi),e.subscriptions.push(this._lineAnnotationController=new _i),e.subscriptions.push(this._lineHoverController=new Ti),e.subscriptions.push(this._statusBarController=new Oi),e.subscriptions.push(this._codeLensController=new Si),e.subscriptions.push(this._keyboard=new Ai),e.subscriptions.push(this._settingsEditor=new Fs),e.subscriptions.push(this._welcomeEditor=new Ps),t.gitExplorer.enabled)e.subscriptions.push(this._gitExplorer=new Ss);else{let t;t=ti.onDidChange(i=>{ti.changed(i,ti.name("gitExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._gitExplorer=new Ss))})}if(t.historyExplorer.enabled)e.subscriptions.push(this._historyExplorer=new $s);else{let t;t=ti.onDidChange(i=>{ti.changed(i,ti.name("historyExplorer")("enabled").value)&&(t.dispose(),e.subscriptions.push(this._historyExplorer=new $s))})}e.subscriptions.push(s.workspace.registerTextDocumentContentProvider(Pi.scheme,new Pi)),e.subscriptions.push(s.languages.registerCodeLensProvider(Fi.selector,new Fi))}static get codeLens(){return this._codeLensController}static get config(){return void 0===this._config&&(this._config=Ts.applyMode(ti.get())),this._config}static get context(){return this._context}static get explorerCommands(){return void 0===this._explorerCommands&&this._context.subscriptions.push(this._explorerCommands=new xs),this._explorerCommands}static get fileAnnotations(){return this._fileAnnotationController}static get git(){return this._git}static get gitExplorer(){return this._gitExplorer}static get historyExplorer(){return void 0===this._historyExplorer&&this._context.subscriptions.push(this._historyExplorer=new $s),this._historyExplorer}static get keyboard(){return this._keyboard}static get lineAnnotations(){return this._lineAnnotationController}static get lineHovers(){return this._lineHoverController}static get lineTracker(){return this._lineTracker}static get resultsExplorer(){return void 0===this._resultsExplorer&&this._context.subscriptions.push(this._resultsExplorer=new ks),this._resultsExplorer}static get settingsEditor(){return this._settingsEditor}static get statusBar(){return this._statusBarController}static get tracker(){return this._tracker}static get welcomeEditor(){return this._welcomeEditor}static resetConfig(){this._config=void 0}static applyMode(e){if(!e.mode.active)return e;const t=e.modes[e.mode.active];return null==t?e:(null!=t.codeLens&&(e.codeLens.enabled=t.codeLens),null!=t.currentLine&&(e.currentLine.enabled=t.currentLine),null!=t.explorers&&(e.gitExplorer.enabled=t.explorers),null!=t.explorers&&(e.historyExplorer.enabled=t.explorers),null!=t.hovers&&(e.hovers.enabled=t.hovers),null!=t.statusBar&&(e.statusBar.enabled=t.statusBar),e)}}function Rs(){return!ti.get(ti.name("advanced")("quickPick")("closeOnFocusOut").value)}function Es(e,t){const i=new s.CancellationTokenSource;return async function(e,t,i){const o=i&&await Ts.keyboard.beginScope(i);try{await s.window.showQuickPick(function(e){return new Promise((t,i)=>{const s=e.token.onCancellationRequested(()=>{s.dispose(),t([])})})}(t),{placeHolder:e,ignoreFocusOut:Rs()},t.token)}catch(e){}finally{t.cancel(),o&&o.dispose()}}(e,i,t),i}class Bs{constructor(e,t,i){void 0===t?(this.command=void 0,this.args=i):"string"==typeof t?(this.command=t,this.args=i):(this.command=t[0],this.args=t.slice(1)),Object.assign(this,e)}execute(){return void 0===this.command?Promise.resolve(void 0):s.commands.executeCommand(this.command,...this.args||[])}onDidPressKey(e){return this.execute()}}class Ns{constructor(e){this.commit=e;const t=e.getShortMessage();e.isStash?(this.label=t,this.description="",this.detail=`${T.Space} ${e.stashName||e.shortSha} ${ae.pad(T.Dot,1,1)} ${e.formattedDate} ${ae.pad(T.Dot,1,1)} ${e.getDiffStatus()}`):(this.label=t,this.description=`${ae.pad("$(git-commit)",1,1)} ${e.shortSha}`,this.detail=`${T.Space} ${e.author}, ${e.formattedDate}${e.isFile?"":` ${ae.pad(T.Dot,1,1)} ${e.getDiffStatus()}`}`)}}class As extends Bs{constructor(e,t,i,s={label:"Choose from Branch or Tag History...",description:`${ae.pad(T.Dash,2,2)} shows list of branches and tags`}){super(s,void 0,void 0),this.repoPath=e,this.placeHolder=t,this.goBackCommand=i}async execute(e={preserveFocus:!1,preview:!1}){const t=Gs.showProgress(this.placeHolder);try{const[e,i]=await Promise.all([Ts.git.getBranches(this.repoPath),Ts.git.getTags(this.repoPath)]);if(t.token.isCancellationRequested)return;return Gs.show(e,i,this.placeHolder,{progressCancellation:t,goBackCommand:this.goBackCommand})}finally{t.cancel()}}}class Os extends Bs{constructor(e,t){super({label:"",description:""},e,t)}}class Ls extends Bs{constructor(e){super({label:e,description:""})}}class Us extends Bs{constructor(e,t){super(t,void 0,void 0),this.uri=e}async execute(e){return Do(this.uri,e)}onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class Is extends Bs{constructor(e,t){super(t,void 0,void 0),this.uris=e}async execute(e={preserveFocus:!1,preview:!1}){for(const t of this.uris)await Do(t,e)}async onDidPressKey(e){return this.execute({preserveFocus:!0,preview:!1})}}class Ms extends Bs{constructor(e,t={label:"Show in Results",description:`${ae.pad(T.Dash,2,2)} displays commit in the GitLens Results explorer`}){super(t,void 0,void 0),this.commit=e}async execute(e={preserveFocus:!1,preview:!1}){Ts.resultsExplorer.showCommitInResults(this.commit)}}class Ws extends Bs{constructor(e,t,i={label:"Show in Results",description:`${ae.pad(T.Dash,2,2)} displays commits in the GitLens Results explorer`}){super(i,void 0,void 0),this.results=e,this.resultsLabel=t}async execute(e={preserveFocus:!1,preview:!1}){Ts.resultsExplorer.showCommitsInResults(this.results,this.resultsLabel)}}class Hs extends Ws{constructor(e,t,i={label:"Show in Results",description:`${ae.pad(T.Dash,2,2)} displays results in the GitLens Results explorer`}){super(e,{label:t},i),this.results=e,this.search=t}}class js{constructor(e){this.branchOrTag=e,e instanceof Ce?(this.label=`${e.current?`$(check)${T.Space}`:T.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${T.Space.repeat(2)} remote branch`:""):(this.label=`${T.Space.repeat(4)} ${e.name}`,this.description=`${T.Space.repeat(2)} tag`)}get name(){return this.branchOrTag.name}get remote(){return this.branchOrTag instanceof Ce&&this.branchOrTag.remote}}class Gs{static showProgress(e){return Es(e,{left:Ri,",":Ri,".":Ri})}static async show(e,t,i,o={}){const a=[...e.filter(e=>!e.remote).map(e=>new js(e)),...t.map(e=>new js(e)),...e.filter(e=>e.remote).map(e=>new js(e))];if(void 0!==o.goBackCommand&&a.splice(0,0,o.goBackCommand),void 0!==o.progressCancellation&&o.progressCancellation.token.isCancellationRequested)return;const r=await Ts.keyboard.beginScope({left:o.goBackCommand||Ri});o.progressCancellation&&o.progressCancellation.cancel();const n=await s.window.showQuickPick(a,{placeHolder:i,ignoreFocusOut:Rs()});return await r.dispose(),n}}class Vs{constructor(e){this.branch=e,this.label=`${e.current?`$(check)${T.Space}`:T.Space.repeat(4)} ${e.name}`,this.description=e.remote?`${T.Space.repeat(2)} remote branch`:""}}class zs{static async show(e,t,i={}){const o=e.map(e=>new Vs(e));return void 0!==i.goBackCommand&&o.splice(0,0,i.goBackCommand),await s.window.showQuickPick(o,{placeHolder:t,ignoreFocusOut:Rs()})}}class Qs extends Bs{constructor(e,t,i){super({label:i?`$(link-external) Copy ${Ge(t)} Url to Clipboard from ${e.provider.name}`:`$(link-external) Open ${Ge(t)} in ${e.provider.name}`,description:`${ae.pad(T.Dash,2,3)} $(repo) ${e.provider.path}`},void 0,void 0),this.clipboard=i,this.remote=e,this.resource=t}async execute(){return this.clipboard?this.remote.provider.copy(this.resource):this.remote.provider.open(this.resource)}}class qs extends Bs{constructor(e,t,i){const s=Ge(t);let o="";switch(t.type){case He.Branch:o=`$(git-branch) ${t.branch}`;break;case He.Branches:o="$(git-branch) Branches";break;case He.Commit:o=`$(git-commit) ${Zt.shortenSha(t.sha)}`;break;case He.File:o=`$(file-text) ${y.basename(t.fileName)}`;break;case He.Repo:o="$(repo) Repository";break;case He.Revision:if(void 0!==t.commit&&t.commit instanceof Me)"D"===t.commit.status?(t.sha=t.commit.previousSha,o=`$(file-text) ${y.basename(t.fileName)} in ${T.Space}$(git-commit) ${t.commit.previousShortSha} (deleted in ${T.Space}$(git-commit) ${t.commit.shortSha})`):(t.sha=t.commit.sha,o=`$(file-text) ${y.basename(t.fileName)} in ${T.Space}$(git-commit) ${t.commit.shortSha}`);else{const e=void 0===t.sha?"":Zt.shortenSha(t.sha);o=`$(file-text) ${y.basename(t.fileName)}${e?` in ${T.Space}$(git-commit) ${e}`:""}`}}const a=e[0];1!==e.length?super({label:`$(link-external) Open ${s} in ${e.every(e=>void 0!==e.provider&&e.provider.name===a.provider.name)?a.provider.name:"Remote"}${T.Ellipsis}`,description:`${ae.pad(T.Dash,2,3)} ${o}`},ji.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}]):super({label:`$(link-external) Open ${s} in ${a.provider.name}`,description:`${ae.pad(T.Dash,2,3)} $(repo) ${a.provider.path} ${ae.pad(T.Dot,1,1)} ${o}`},ji.OpenInRemote,[void 0,{remotes:e,resource:t,goBackCommand:i}])}}class Ks{static async show(e,t,i,o,a){const r=e.map(e=>new Qs(e,i,o));a&&r.splice(0,0,a);const n=await s.window.showQuickPick(r,{placeHolder:t,ignoreFocusOut:Rs()});if(void 0!==n)return n}}class Ys{static showProgress(e){return Es(`${e} history ${T.Dash} search by commit message, filename, or commit id`,{left:Ri,",":Ri,".":Ri})}static async show(e,t,i,o,a,r){const n=Array.from(ee.map(e.commits.values(),e=>new Ns(e))),l=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to ${T.Space}$(git-branch) ${i} history`},ji.ShowQuickBranchHistory,[t,{branch:i,log:e,maxCount:e.maxCount,goBackCommand:a}]),c=await Ts.git.getRemotes(t&&t.repoPath||e.repoPath);c.length&&n.splice(0,0,new qs(c,{type:"branch",branch:i},l)),n.splice(0,0,new Bs({label:"$(search) Show Commit Search",description:`${ae.pad(T.Dash,2,3)} search for commits by message, author, files, or commit id`},ji.ShowCommitSearch,[_e.fromRepoPath(e.repoPath),{goBackCommand:l}]));let h=void 0;if((e.truncated||e.sha)&&(e.truncated&&n.splice(0,0,new Bs({label:"$(sync) Show All Commits",description:`${ae.pad(T.Dash,2,3)} this may take a while`},ji.ShowQuickBranchHistory,[_e.fromRepoPath(e.repoPath),{branch:i,maxCount:0,goBackCommand:a}])),r&&n.splice(0,0,r),e.truncated)){const s=new Bs({label:"$(arrow-right) Show Next Commits",description:`${ae.pad(T.Dash,2,3)} shows ${e.maxCount} newer commits`},ji.ShowQuickBranchHistory,[t,{branch:i,maxCount:e.maxCount,nextPageCommand:r}]),o=ee.last(e.commits.values());null!=o&&(h=new Bs({label:"$(arrow-left) Show Previous Commits",description:`${ae.pad(T.Dash,2,3)} shows ${e.maxCount} older commits`},ji.ShowQuickBranchHistory,[new _e(t||o.uri,o),{branch:i,maxCount:e.maxCount,goBackCommand:a,nextPageCommand:s}]),n.splice(0,0,h))}if(a&&n.splice(0,0,a),o.token.isCancellationRequested)return;const d=await Ts.keyboard.beginScope({left:a,",":h,".":r});o.cancel();const m=await s.window.showQuickPick(n,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${i} history ${T.Dash} search by commit message, filename, or commit id`,ignoreFocusOut:Rs()});return await d.dispose(),m}}class Xs extends Bs{constructor(e,t){super(t||{label:"$(git-pull-request) Apply Changes",description:`${ae.pad(T.Dash,2,3)} $(file-text) ${y.basename(e.fileName)} in ${T.Space}$(git-commit) ${e.shortSha}`},void 0,void 0),this.commit=e}async execute(){const e=this.commit.toGitUri();return await Ts.git.checkoutFile(e),Do(e,{preserveFocus:!0,preview:!1})}}class Zs extends Us{constructor(e,t){super(s.Uri.file(y.resolve(e.repoPath,e.fileName)),t||{label:"$(file-symlink-file) Open File",description:`${ae.pad(T.Dash,2,3)} ${y.basename(e.fileName)}`})}}class Js extends Us{constructor(e,t){let i,s;"D"===e.status?(s=_e.toRevisionUri(e.previousFileSha,e.previousUri.fsPath,e.repoPath),i=`${ae.pad(T.Dash,2,3)} ${y.basename(e.fileName)} in ${T.Space}$(git-commit) ${e.previousShortSha} (deleted in ${T.Space}$(git-commit) ${e.shortSha})`):(s=_e.toRevisionUri(e.sha,e.uri.fsPath,e.repoPath),i=`${ae.pad(T.Dash,2,3)} ${y.basename(e.fileName)} in ${T.Space}$(git-commit) ${e.shortSha}`),super(s,t||{label:"$(file-symlink-file) Open Revision",description:i})}}class eo{static async show(e,t,i,o,a){const r=[],n=e.isStash,l=e.workingFileName&&y.basename(e.workingFileName)||y.basename(e.fileName),c=e.isUncommitted;if(c){const t=await Ts.git.getRecentLogCommitForFile(void 0,e.uri.fsPath);if(void 0===t)return;e=t}await e.resolvePreviousFileSha(),n&&r.push(new Xs(e)),e.previousFileShortSha&&r.push(new Bs({label:"$(git-compare) Open Changes",description:`${ae.pad(T.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${T.Space} $(git-compare) ${T.Space} $(git-commit) ${e.shortSha}`},ji.DiffWithPrevious,[e.uri,{commit:e}])),e.workingFileName&&r.push(new Bs({label:"$(git-compare) Open Changes with Working Tree",description:`${ae.pad(T.Dash,2,3)} $(git-commit) ${e.shortSha} ${T.Space} $(git-compare) ${T.Space} $(file-text) ${l}`},ji.DiffWithWorking,[s.Uri.file(y.resolve(e.repoPath,e.workingFileName)),{commit:e}])),e.workingFileName&&"D"!==e.status&&r.push(new Zs(e)),r.push(new Js(e));const h=await Ts.git.getRemotes(e.repoPath);if(h.length){if(e.workingFileName&&"D"!==e.status){const t=await Ts.git.getBranch(e.repoPath);void 0!==t&&r.push(new qs(h,{type:"file",fileName:e.workingFileName,branch:t.name},o))}n||r.push(new qs(h,{type:"revision",fileName:e.fileName,commit:e},o))}n||(r.push(new Xs(e)),r.push(new Bs({label:"$(clippy) Copy Commit ID to Clipboard",description:`${ae.pad(T.Dash,2,3)} ${e.shortSha}`},ji.CopyShaToClipboard,[t,{sha:e.sha}])),r.push(new Bs({label:"$(clippy) Copy Commit Message to Clipboard",description:`${ae.pad(T.Dash,2,3)} ${e.getShortMessage()}`},ji.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}]))),e.workingFileName&&r.push(new Bs({label:"$(history) Show File History",description:`${ae.pad(T.Dash,2,3)} of ${y.basename(e.fileName)}`},ji.ShowQuickFileHistory,[s.Uri.file(y.resolve(e.repoPath,e.workingFileName)),{fileLog:a,goBackCommand:o}])),n||(r.push(new Bs({label:`$(history) Show ${e.workingFileName?"Previous ":""}File History`,description:`${ae.pad(T.Dash,2,3)} of ${y.basename(e.fileName)} ${ae.pad(T.Dot,1,1)} from ${T.Space}$(git-commit) ${e.shortSha}`},ji.ShowQuickFileHistory,[e.toGitUri(),{goBackCommand:o}])),r.push(new Bs({label:"$(git-commit) Show Commit Details",description:`${ae.pad(T.Dash,2,3)} $(git-commit) ${e.shortSha}`},ji.ShowQuickCommitDetails,[e.toGitUri(),{commit:e,sha:e.sha,goBackCommand:o}]))),i&&r.splice(0,0,i);let d=void 0,m=void 0;n||(void 0===a||a.truncated||void 0!==a.sha?(d=(async()=>{let s=a,o=s&&s.commits.get(e.sha);if(void 0===o||void 0===o.previousSha){if(void 0===(s=await Ts.git.getLogForFile(e.repoPath,t.fsPath,{maxCount:Ts.config.advanced.maxListItems,ref:e.sha,renames:!0})))return Ri;void 0===(o=s&&s.commits.get(e.sha))&&e.isMerge&&(o=ee.first(s.commits.values())),o&&(o.nextSha=e.nextSha,o.nextFileName=e.nextFileName)}return void 0===o||void 0===o.previousSha?Ri:new Os(ji.ShowQuickCommitFileDetails,[o.previousUri,{fileLog:s,sha:o.previousSha,goBackCommand:i}])}),m=(async()=>{let s=a,o=s&&s.commits.get(e.sha);if(void 0===o||void 0===o.nextSha){s=void 0,o=void 0;const i=await Ts.git.findNextCommit(e.repoPath,t.fsPath,e.sha);void 0!==i&&i.sha!==e.sha&&((o=e).nextSha=i.sha,o.nextFileName=i.originalFileName||i.fileName)}return void 0===o||void 0===o.nextSha?Ri:new Os(ji.ShowQuickCommitFileDetails,[o.nextUri,{fileLog:s,sha:o.nextSha,goBackCommand:i}])})):(d=void 0===e.previousSha?void 0:new Os(ji.ShowQuickCommitFileDetails,[e.previousUri,{fileLog:a,sha:e.previousSha,goBackCommand:i}]),m=void 0===e.nextSha?void 0:new Os(ji.ShowQuickCommitFileDetails,[e.nextUri,{fileLog:a,sha:e.nextSha,goBackCommand:i}])));const u=await Ts.keyboard.beginScope({left:i,",":d,".":m}),g=await s.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:`${e.getFormattedPath()} ${ae.pad(T.Dot,1,1)} ${c?`Uncommitted ${T.ArrowRightHollow} `:""}${e.shortSha} ${ae.pad(T.Dot,1,1)} ${e.author}, ${e.formattedDate} ${ae.pad(T.Dot,1,1)} ${e.getShortMessage()}`,ignoreFocusOut:Rs(),onDidSelectItem:e=>{u.setKeyCommand("right",e)}});return await u.dispose(),g}}class to extends Us{constructor(e,t){const i=Se(t.status),s=xe.getFormattedDirectory(t,!0);super(_e.toRevisionUri(e.sha,t,e.repoPath),{label:`${ae.pad(i,4,2)} ${y.basename(t.fileName)}`,description:s}),this.commit=e.toFileCommit(t),this.status=t.status}get sha(){return this.commit.sha}onDidPressKey(e){return void 0===this.commit.previousSha?super.onDidPressKey(e):s.commands.executeCommand(ji.DiffWithPrevious,this.commit.toGitUri(),{commit:this.commit,showOptions:{preserveFocus:!0,preview:!1}})}}class io extends Is{constructor(e,t=!1,i){const s=e.repoPath;super(G.filterMap(e.fileStatuses,e=>_e.fromFileStatus(e,s)),i||{label:"$(file-symlink-file) Open Files",description:""})}}class so extends Is{constructor(e,t){super(G.filterMap(e.fileStatuses,t=>_e.toRevisionUri("D"===t.status?e.previousFileSha:e.sha,t,e.repoPath)),t||{label:"$(file-symlink-file) Open Revisions",description:`${ae.pad(T.Dash,2,3)} in ${T.Space}$(git-commit) ${e.shortSha}`})}}class oo{static async show(e,t,i,o,a){await e.resolvePreviousFileSha();const r=e.fileStatuses.map(t=>new to(e,t)),n=e.isStash;let l=0;if(n)r.splice(l++,0,new Bs({label:"$(git-pull-request) Apply Stashed Changes",description:`${ae.pad(T.Dash,2,3)} ${e.getShortMessage()}`},ji.StashApply,[{confirm:!0,deleteAfter:!1,stashItem:e,goBackCommand:o}])),r.splice(l++,0,new Bs({label:"$(x) Delete Stashed Changes",description:`${ae.pad(T.Dash,2,3)} ${e.getShortMessage()}`},ji.StashDelete,[{confirm:!0,stashItem:e,goBackCommand:o}])),r.splice(l++,0,new Ms(e));else{r.splice(l++,0,new Ms(e));const t=await Ts.git.getRemotes(e.repoPath);t.length&&r.splice(l++,0,new qs(t,{type:"commit",sha:e.sha},o))}r.splice(l++,0,new io(e)),r.splice(l++,0,new so(e)),r.splice(l++,0,new Bs({label:"$(git-compare) Open Directory Compare with Previous Revision",description:`${ae.pad(T.Dash,2,3)} $(git-commit) ${e.previousFileShortSha} ${T.Space} $(git-compare) ${T.Space} $(git-commit) ${e.shortSha}`},ji.DiffDirectory,[e.uri,{ref1:e.previousFileSha,ref2:e.sha}])),r.splice(l++,0,new Bs({label:"$(git-compare) Open Directory Compare with Working Tree",description:`${ae.pad(T.Dash,2,3)} $(git-commit) ${e.shortSha} ${T.Space} $(git-compare) ${T.Space} $(file-directory) Working Tree`},ji.DiffDirectory,[t,{ref1:e.sha}])),n||r.splice(l++,0,new Bs({label:"$(clippy) Copy Commit ID to Clipboard",description:`${ae.pad(T.Dash,2,3)} ${e.shortSha}`},ji.CopyShaToClipboard,[t,{sha:e.sha}])),r.splice(l++,0,new Bs({label:"$(clippy) Copy Commit Message to Clipboard",description:`${ae.pad(T.Dash,2,3)} ${e.getShortMessage()}`},ji.CopyMessageToClipboard,[t,{message:e.message,sha:e.sha}])),r.splice(l++,0,new Bs({label:"Changed Files",description:e.getDiffStatus()},ji.ShowQuickCommitDetails,[t,{commit:e,repoLog:a,sha:e.sha,goBackCommand:i}])),i&&r.splice(0,0,i);let c=void 0,h=void 0;n||(void 0===a||a.truncated||void 0!==a.sha?(c=(async()=>{let t=a,s=t&&t.commits.get(e.sha);return void 0!==s&&void 0!==s.previousSha||(s=(t=await Ts.git.getLog(e.repoPath,{maxCount:Ts.config.advanced.maxListItems,ref:e.sha}))&&t.commits.get(e.sha))&&(s.nextSha=e.nextSha),void 0===s||void 0===s.previousSha?Ri:new Os(ji.ShowQuickCommitDetails,[s.previousUri,{repoLog:t,sha:s.previousSha,goBackCommand:i}])}),h=(async()=>{let t=a,s=t&&t.commits.get(e.sha);if(void 0===s||void 0===s.nextSha){t=void 0,s=void 0;const i=await Ts.git.getLog(e.repoPath,{maxCount:1,reverse:!0,ref:e.sha}),o=i&&ee.first(i.commits.values());void 0!==o&&o.sha!==e.sha&&((s=e).nextSha=o.sha)}return void 0===s||void 0===s.nextSha?Ri:new Os(ji.ShowQuickCommitDetails,[s.nextUri,{repoLog:t,sha:s.nextSha,goBackCommand:i}])})):(c=void 0===e.previousSha?void 0:new Os(ji.ShowQuickCommitDetails,[e.previousUri,{repoLog:a,sha:e.previousSha,goBackCommand:i}]),h=void 0===e.nextSha?void 0:new Os(ji.ShowQuickCommitDetails,[e.nextUri,{repoLog:a,sha:e.nextSha,goBackCommand:i}])));const d=await Ts.keyboard.beginScope({left:i,",":c,".":h}),m=await s.window.showQuickPick(r,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:`${e.shortSha} ${ae.pad(T.Dot,1,1)} ${e.author?`${e.author}, `:""}${e.formattedDate} ${ae.pad(T.Dot,1,1)} ${e.getShortMessage()}`,ignoreFocusOut:Rs(),onDidSelectItem:e=>{d.setKeyCommand("right",e),"function"==typeof e.onDidSelect&&e.onDidSelect()}});return await d.dispose(),m}}class ao{static showProgress(e){return Es(e,{left:Ri,",":Ri,".":Ri})}static async show(e,t,i,o){const a=e&&[...ee.map(e.commits.values(),e=>new Ns(e))]||[new Ls("No results found")];if(void 0!==o.showInResultsExplorerCommand&&a.splice(0,0,o.showInResultsExplorerCommand),void 0!==o.showAllCommand&&a.splice(0,0,o.showAllCommand),void 0!==o.goBackCommand&&a.splice(0,0,o.goBackCommand),i.token.isCancellationRequested)return;const r=await Ts.keyboard.beginScope({left:o.goBackCommand});i.cancel();const n=await s.window.showQuickPick(a,{matchOnDescription:!0,placeHolder:t,ignoreFocusOut:Rs()});return await r.dispose(),n}}class ro{static showProgress(e){return Es(e,{left:Ri,",":Ri,".":Ri})}static async show(e,t,i,o={}){o=Object.assign({pickerOnly:!1},o);const a=Array.from(ee.map(e.commits.values(),e=>new Ns(e)));let r=0;if(r++,a.splice(0,0,new As(e.repoPath,i,o.currentCommand)),void 0!==o.showInResultsExplorerCommand&&(r++,a.splice(0,0,o.showInResultsExplorerCommand)),e.truncated||e.sha){if(void 0!==o.showAllCommand)r++,a.splice(0,0,o.showAllCommand);else if(!o.pickerOnly){const[i]=await Ts.git.findWorkingFileName(y.relative(e.repoPath,t.fsPath),e.repoPath);i&&(r++,a.splice(0,0,new Bs({label:"$(history) Show File History",description:`${ae.pad(T.Dash,2,3)} of ${y.basename(i)}`},ji.ShowQuickFileHistory,[s.Uri.file(y.resolve(e.repoPath,i)),{goBackCommand:new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to history of ${T.Space}$(file-text) ${y.basename(t.fsPath)}${t.sha?` from ${T.Space}$(git-commit) ${t.shortSha}`:""}`},ji.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range,goBackCommand:o.goBackCommand}])}])))}void 0!==o.nextPageCommand&&(r++,a.splice(0,0,o.nextPageCommand)),void 0!==o.previousPageCommand&&(r++,a.splice(0,0,o.previousPageCommand))}if(!o.pickerOnly){const i=await Ts.git.getBranch(t.repoPath);if(void 0!==i){const s=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to history of ${T.Space}$(file-text) ${y.basename(t.fsPath)}${t.sha?` from ${T.Space}$(git-commit) ${t.shortSha}`:""}`},ji.ShowQuickFileHistory,[t,{log:e,maxCount:e.maxCount,range:e.range}]);void 0===o.goBackCommand&&a.splice(r++,0,new Bs({label:"$(history) Show Branch History",description:`${ae.pad(T.Dash,2,3)} shows  ${T.Space}$(git-branch) ${i.name} history`},ji.ShowQuickCurrentBranchHistory,[void 0,{goBackCommand:s}]));const n=await Ts.git.getRemotes(t.repoPath);if(n.length){const e=void 0!==t.sha?{type:"revision",branch:i.name,fileName:t.getRelativePath(),sha:t.sha}:{type:"file",branch:i.name,fileName:t.getRelativePath()};a.splice(r++,0,new qs(n,e,s))}}o.goBackCommand&&a.splice(0,0,o.goBackCommand)}if(void 0!==o.progressCancellation&&o.progressCancellation.token.isCancellationRequested)return;const n=await Ts.keyboard.beginScope({left:o.goBackCommand,",":o.previousPageCommand,".":o.nextPageCommand});o.progressCancellation&&o.progressCancellation.cancel();const l=await s.window.showQuickPick(a,{matchOnDescription:!0,matchOnDetail:!0,placeHolder:i,ignoreFocusOut:Rs()});return await n.dispose(),l}}class no{static async show(){const e=Object.keys(Ts.config.modes);if(0===e.length)return;const t=Ts.config.mode.active,i=e.map(e=>{const i=Ts.config.modes[e];return{label:`${t===e?"$(check)  ":"     "}${i.name} mode`,description:i.description?` ${T.Dash}  ${i.description}`:"",key:e}});return t&&i.splice(0,0,{label:`Exit ${Ts.config.modes[t].name} mode`,key:void 0}),await s.window.showQuickPick(i,{placeHolder:"select a GitLens mode to enter"})}}class lo{constructor(e){this.repository=e,this.label=e.name,this.description=e.path}get repoPath(){return this.repository.path}}class co{static async show(e,t){const i=[...ee.map(await Ts.git.getRepositories(),e=>new lo(e))];return void 0!==t&&i.splice(0,0,t),await s.window.showQuickPick(i,{placeHolder:e,ignoreFocusOut:Rs()})}}class ho extends Us{constructor(e,t,i){const s=e.getOcticon(),o=e.getFormattedDirectory(!0);super(e.uri,i||{label:`${e.staged?"$(check)":T.Space.repeat(3)}${ae.pad(s,2,2)} ${y.basename(e.fileName)}`,description:o}),this.status=e,void 0!==e.indexStatus?this.commit=new Me(Re.File,e.repoPath,Zt.stagedUncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,"HEAD",e.fileName):this.commit=new Me(Re.File,e.repoPath,Zt.uncommittedSha,"You",void 0,new Date,"",e.fileName,[e],e.status,e.originalFileName,void 0!==t?Zt.stagedUncommittedSha:"HEAD",e.fileName)}onDidPressKey(e){return s.commands.executeCommand(ji.DiffWithPrevious,_e.fromFileStatus(this.status,this.status.repoPath),{commit:this.commit,line:0,showOptions:{preserveFocus:!0,preview:!1}})}}class mo extends Bs{constructor(e,t){const i=e.map(e=>e.uri);super(t||{label:"$(file-symlink-file) Open Changed Files",description:""},ji.OpenChangedFiles,[void 0,{uris:i}])}}class uo{static computeStatus(e){let t=0,i=0,s=0,o=0,a=0,r=0;const n=[],l=[];for(const c of e){switch(c.indexStatus){case"A":case"?":t++,n.push(c);break;case"D":a++;break;case void 0:break;default:s++,n.push(c)}switch(c.workTreeStatus){case"A":case"?":i++,l.push(c);break;case"D":r++;break;case void 0:break;default:o++,l.push(c)}}const c=t+s+a,h=i+o+r;return{staged:c,stagedStatus:c>0?`+${t} ~${s} -${a}`:"",stagedAddsAndChanges:n,unstaged:h,unstagedStatus:h>0?`+${i} ~${o} -${r}`:"",unstagedAddsAndChanges:l}}static async show(e,t){const i=[...ee.flatMap(e.files,e=>void 0!==e.workTreeStatus&&void 0!==e.indexStatus?[new ho(e.with({indexStatus:null}),e.indexStatus),new ho(e.with({workTreeStatus:null}))]:[new ho(e)])];i.sort((e,t)=>(e.status.staged?-1:1)-(t.status.staged?-1:1)||e.status.fileName.localeCompare(t.status.fileName));const o=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to ${T.Space}$(git-branch) ${e.branch} status`},ji.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]),a=this.computeStatus(e.files);if(a.staged>0){let s=0;const o=a.unstaged>0?e.files.findIndex(e=>!e.staged):-1;o>-1&&(i.splice(o,0,new Bs({label:"Unstaged Files",description:a.unstagedStatus},ji.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(o,0,new mo(a.stagedAddsAndChanges,{label:`${T.Space.repeat(4)} $(file-symlink-file) Open Staged Files`,description:""})),i.push(new mo(a.unstagedAddsAndChanges,{label:`${T.Space.repeat(4)} $(file-symlink-file) Open Unstaged Files`,description:""}))),i.splice(s++,0,new Bs({label:"Staged Files",description:a.stagedStatus},ji.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]))}else e.files.some(e=>!e.staged)&&i.splice(0,0,new Bs({label:"Unstaged Files",description:a.unstagedStatus},ji.ShowQuickRepoStatus,[void 0,{goBackCommand:t}]));e.files.length?(i.push(new mo(a.stagedAddsAndChanges.concat(a.unstagedAddsAndChanges))),i.push(new Bs({label:"$(x) Close Unchanged Files",description:""},ji.CloseUnchangedFiles))):i.push(new Bs({label:"No changes in the working tree",description:""},ji.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),i.splice(0,0,new Bs({label:"$(inbox) Show Stashed Changes",description:`${ae.pad(T.Dash,2,3)} shows stashed changes in the repository`},ji.ShowQuickStashList,[_e.fromRepoPath(e.repoPath),{goBackCommand:o}])),e.upstream&&e.state.ahead&&i.splice(0,0,new Bs({label:`$(cloud-upload)${T.Space} ${e.state.ahead} Commit${e.state.ahead>1?"s":""} ahead of ${T.Space}$(git-branch) ${e.upstream}`,description:`${ae.pad(T.Dash,2,3)} shows commits in ${T.Space}$(git-branch) ${e.branch} but not ${T.Space}$(git-branch) ${e.upstream}`},ji.ShowQuickBranchHistory,[_e.fromRepoPath(e.repoPath,`${e.upstream}..${e.ref}`),{branch:e.ref,maxCount:0,goBackCommand:o}])),e.upstream&&e.state.behind&&i.splice(0,0,new Bs({label:`$(cloud-download)${T.Space} ${e.state.behind} Commit${e.state.behind>1?"s":""} behind ${T.Space}$(git-branch) ${e.upstream}`,description:`${ae.pad(T.Dash,2,3)} shows commits in ${T.Space}$(git-branch) ${e.upstream} but not ${T.Space}$(git-branch) ${e.branch}${e.sha?` (since ${T.Space}$(git-commit) ${Zt.shortenSha(e.sha)})`:""}`},ji.ShowQuickBranchHistory,[_e.fromRepoPath(e.repoPath,`${e.ref}..${e.upstream}`),{branch:e.upstream,maxCount:0,goBackCommand:o}])),!e.upstream||e.state.ahead||e.state.behind||i.splice(0,0,new Bs({label:`$(git-branch) ${e.branch} is up-to-date with ${T.Space}$(git-branch) ${e.upstream}`,description:""},ji.ShowQuickRepoStatus,[void 0,{goBackCommand:t}])),t&&i.splice(0,0,t);const r=await Ts.keyboard.beginScope({left:t}),n=await s.window.showQuickPick(i,{matchOnDescription:!0,placeHolder:`status of ${e.branch}${e.upstream?` ${ae.pad(T.ArrowLeftRightLong,1,1)} ${e.upstream}`:""}`,ignoreFocusOut:Rs(),onDidSelectItem:e=>{r.setKeyCommand("right",e)}});return await r.dispose(),n}}class go{static showProgress(e){return Es("apply"===e?`Apply stashed changes to your working tree${T.Ellipsis}`:`stashed changes ${T.Dash} search by message, filename, or commit id`,{left:Ri,",":Ri,".":Ri})}static async show(e,t,i,o,a){const r=e&&Array.from(ee.map(e.commits.values(),e=>new Ns(e)))||[];if("list"===t&&r.splice(0,0,new Bs({label:"$(plus) Stash Changes",description:`${ae.pad(T.Dash,2,3)} stashes all changes`},ji.StashSave,[{goBackCommand:a}])),o&&r.splice(0,0,o),i.token.isCancellationRequested)return;const n=await Ts.keyboard.beginScope({left:o});i.cancel();const l=await s.window.showQuickPick(r,{matchOnDescription:!0,placeHolder:"apply"===t?`Apply stashed changes to your working tree${T.Ellipsis}`:`stashed changes ${T.Dash} search by message, filename, or commit id`,ignoreFocusOut:Rs()});return await n.dispose(),l}}function po(e,t){if(e instanceof s.Uri)return e;if(null==t)return;const i=t.document;return null!=i?i.uri:void 0}async function fo(e,t,i,s){let o=await Ts.git.getRepoPathOrActive(e,t);if(!o){const e=await co.show(i,s);if(e instanceof Bs)return void await e.execute();if(void 0===e)return void(void 0!==s&&await s.execute());o=e.repoPath}return o}function vo(e){return"view"===e.type&&e.node.branch instanceof Ce}function wo(e){return"view"===e.type&&e.node.commit instanceof Be}function bo(e){return"view"===e.type&&e.node.remote instanceof je}function _o(e){return null!=e&&(void 0!==e.id&&(void 0!==e.handle||void 0!==e.label||void 0!==e.resourceStates))}function Co(e){return null!=e&&null!=e.resourceUri}!function(e){e.ClearFileAnnotations="gitlens.clearFileAnnotations",e.CloseUnchangedFiles="gitlens.closeUnchangedFiles",e.ComputingFileAnnotations="gitlens.computingFileAnnotations",e.CopyMessageToClipboard="gitlens.copyMessageToClipboard",e.CopyRemoteFileUrlToClipboard="gitlens.copyRemoteFileUrlToClipboard",e.CopyShaToClipboard="gitlens.copyShaToClipboard",e.DiffDirectory="gitlens.diffDirectory",e.DiffHeadWithBranch="gitlens.diffHeadWithBranch",e.DiffWorkingWithBranch="gitlens.diffWorkingWithBranch",e.ExternalDiffAll="gitlens.externalDiffAll",e.DiffWith="gitlens.diffWith",e.DiffWithBranch="gitlens.diffWithBranch",e.DiffWithNext="gitlens.diffWithNext",e.DiffWithPrevious="gitlens.diffWithPrevious",e.DiffWithPreviousInDiff="gitlens.diffWithPreviousInDiff",e.DiffLineWithPrevious="gitlens.diffLineWithPrevious",e.DiffWithRevision="gitlens.diffWithRevision",e.DiffWithWorking="gitlens.diffWithWorking",e.DiffLineWithWorking="gitlens.diffLineWithWorking",e.ExternalDiff="gitlens.externalDiff",e.ExplorersOpenDirectoryDiff="gitlens.explorers.openDirectoryDiff",e.ExplorersOpenDirectoryDiffWithWorking="gitlens.explorers.openDirectoryDiffWithWorking",e.OpenChangedFiles="gitlens.openChangedFiles",e.OpenBranchesInRemote="gitlens.openBranchesInRemote",e.OpenBranchInRemote="gitlens.openBranchInRemote",e.OpenCommitInRemote="gitlens.openCommitInRemote",e.OpenFileInRemote="gitlens.openFileInRemote",e.OpenFileRevision="gitlens.openFileRevision",e.OpenInRemote="gitlens.openInRemote",e.OpenRepoInRemote="gitlens.openRepoInRemote",e.OpenWorkingFile="gitlens.openWorkingFile",e.ResetSuppressedWarnings="gitlens.resetSuppressedWarnings",e.ShowCommitSearch="gitlens.showCommitSearch",e.ShowGitExplorer="gitlens.showGitExplorer",e.ShowHistoryExplorer="gitlens.showHistoryExplorer",e.ShowLastQuickPick="gitlens.showLastQuickPick",e.ShowQuickCommitDetails="gitlens.showQuickCommitDetails",e.ShowQuickCommitFileDetails="gitlens.showQuickCommitFileDetails",e.ShowQuickFileHistory="gitlens.showQuickFileHistory",e.ShowQuickBranchHistory="gitlens.showQuickBranchHistory",e.ShowQuickCurrentBranchHistory="gitlens.showQuickRepoHistory",e.ShowQuickRepoStatus="gitlens.showQuickRepoStatus",e.ShowQuickStashList="gitlens.showQuickStashList",e.ShowResultsExplorer="gitlens.showResultsExplorer",e.ShowSettingsPage="gitlens.showSettingsPage",e.ShowWelcomePage="gitlens.showWelcomePage",e.StashApply="gitlens.stashApply",e.StashDelete="gitlens.stashDelete",e.StashSave="gitlens.stashSave",e.SwitchMode="gitlens.switchMode",e.ToggleCodeLens="gitlens.toggleCodeLens",e.ToggleFileBlame="gitlens.toggleFileBlame",e.ToggleFileHeatmap="gitlens.toggleFileHeatmap",e.ToggleFileRecentChanges="gitlens.toggleFileRecentChanges",e.ToggleLineBlame="gitlens.toggleLineBlame",e.ToggleReviewMode="gitlens.toggleReviewMode",e.ToggleZenMode="gitlens.toggleZenMode"}(ji||(ji={}));class yo{constructor(e){if(this.contextParsingOptions={editor:!1,uri:!1},"string"==typeof e)return void(this._disposable=s.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));const t=e.map(e=>s.commands.registerCommand(e,(...t)=>this._execute(e,...t),this));this._disposable=s.Disposable.from(...t)}static getMarkdownCommandArgsCore(e,t){return`command:${e}?${encodeURIComponent(JSON.stringify(t))}`}dispose(){this._disposable&&this._disposable.dispose()}async preExecute(e,...t){return this.execute(...t)}_execute(e,...t){const[i,s]=yo.parseContext(e,this.contextParsingOptions,...t);return this.preExecute(i,...s)}static parseContext(e,t,...i){let o=void 0,a=i[0];if(t.editor&&(null==a||function(e){return null!=e&&void 0!==e.id&&(void 0!==e.edit||void 0!==e.document)}(a))&&(o=a,a=(i=i.slice(1))[0]),t.uri&&(null==a||a instanceof s.Uri)){const[t,...s]=i;return[{command:e,type:"uri",editor:o,uri:t},s]}if(a instanceof Gi){const[t,...s]=i;return[{command:e,type:"view",node:t,uri:t.uri},s]}if(Co(a)){const t=[];let s=0;for(const e of i){if(!Co(e))break;s++,t.push(e)}return[{command:e,type:"scm-states",scmResourceStates:t,uri:t[0].resourceUri},i.slice(s)]}if(_o(a)){const t=[];let s=0;for(const e of i){if(!_o(e))break;s++,t.push(e)}return[{command:e,type:"scm-groups",scmResourceGroups:t},i.slice(s)]}return[{command:e,type:"unknown",editor:o},i]}}class xo extends yo{constructor(e){super(e),this.contextParsingOptions={editor:!0,uri:!0}}async preExecute(e,...t){return this.execute(e.editor,e.uri,...t)}_execute(e,...t){return super._execute(e,s.window.activeTextEditor,...t)}}let $o=void 0;class So extends xo{constructor(e){super(e)}_execute(e,...t){return $o={command:e,args:t},super._execute(e,...t)}}class ko{constructor(e){Array.isArray(e)||(e=[e]);const t=[];for(const i of e)t.push(s.commands.registerTextEditorCommand(i,(e,t,...s)=>this.executeCore(i,e,t,...s),this));this._disposable=s.Disposable.from(...t)}dispose(){this._disposable&&this._disposable.dispose()}executeCore(e,t,i,...s){return this.execute(t,i,...s)}}async function Do(e,t={}){const{rethrow:i}=t,o=L.__rest(t,["rethrow"]);try{if(e instanceof _e&&(e=e.fileUri({noSha:!0})),e.scheme===P.GitLensGit){const t=_e.fromRevisionUri(e);if(A.includes(y.extname(t.fsPath))){const e=await Ts.git.getVersionedFile(t.repoPath,t.fsPath,t.sha);if(void 0!==e)return void await s.commands.executeCommand(D.Open,e)}}const t=await s.workspace.openTextDocument(e);return s.window.showTextDocument(t,Object.assign({preserveFocus:!1,preview:!0,viewColumn:s.ViewColumn.Active},o))}catch(t){if(t.toString().includes("File seems to be binary and cannot be opened as text"))return void await s.commands.executeCommand(D.Open,e);if(i)throw t;return void H.error(t,"openEditor")}}class Fo extends ko{constructor(){super([ji.ClearFileAnnotations,ji.ComputingFileAnnotations])}async execute(e,t,i){if(null!=e){if(null!=i&&!n.equals(i,e.document.uri)){const t=s.window.visibleTextEditors.find(e=>n.equals(i,e.document.uri));void 0!==t&&(e=t)}try{return Ts.fileAnnotations.clear(e)}catch(e){return H.error(e,"ClearFileAnnotationsCommand"),s.window.showErrorMessage("Unable to clear file annotations. See output channel for more details")}}}}class Po{constructor(){const e=J.debounce(e=>this._resolver&&this._resolver(e),50);this._disposable=s.window.onDidChangeActiveTextEditor(e)}dispose(){this._disposable&&this._disposable.dispose()}async awaitClose(e=500){return this.close(),this.wait(e)}async awaitNext(e=500){return this.next(),this.wait(e)}async close(){return s.commands.executeCommand(D.CloseActiveEditor)}async next(){return s.commands.executeCommand(D.NextEditor)}async wait(e=500){const t=await new Promise((t,i)=>{let o;this._resolver=(e=>{o&&(clearTimeout(o),o=void 0,t(e))}),o=setTimeout(()=>{t(s.window.activeTextEditor),o=void 0},e)});return this._resolver=void 0,t}}class To extends xo{constructor(){super(ji.CloseUnchangedFiles)}async execute(e,t,i={}){t=po(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const o=await fo(t,e,`Close unchanged files in which repository${T.Ellipsis}`);if(!o)return;const a=await Ts.git.getStatusForRepo(o);if(void 0===a)return s.window.showWarningMessage("Unable to close unchanged files");i.uris=a.files.map(e=>e.uri)}if(0===i.uris.length)return s.commands.executeCommand(D.CloseAllEditors);const o=new Po;let a=0,l=void 0;for(e=s.window.activeTextEditor;;){if(null!=e){if(r.equals(l,e,{useId:!0,usePosition:!0}))break;if(void 0!==e.document&&(e.document.isDirty||i.uris.some(t=>n.equals(t,e.document&&e.document.uri)))){const t=l;if(l=e,e=await o.awaitNext(500),r.equals(t,e,{useId:!0,usePosition:!0}))break;continue}}if(l=e,e=await o.awaitClose(500),void 0===l&&null==e){if(++a>=4)break}else a=0}return void o.dispose()}catch(e){return H.error(e,"CloseUnchangedFilesCommand"),s.window.showErrorMessage("Unable to close unchanged files. See output channel for more details")}}}class Ro extends xo{constructor(){super(ji.CopyMessageToClipboard)}async preExecute(e,t={}){return wo(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,o={}){t=po(t,e);try{const a=await Promise.resolve().then(i.t.bind(null,14,7));if(o=Object.assign({},o),null==t){const t=await Ts.git.getActiveRepoPath(e);if(!t)return;const i=await Ts.git.getLog(t,{maxCount:1});if(!i)return;o.message=ee.first(i.commits.values()).message}else if(void 0===o.message){const i=await _e.fromUri(t);if(void 0===o.sha){const t=e&&e.selection.active.line||0;if(t<0)return;try{const a=e&&e.document&&e.document.isDirty?await Ts.git.getBlameForLineContents(i,t,e.document.getText()):await Ts.git.getBlameForLine(i,t);if(!a)return;if(a.commit.isUncommitted)return;o.sha=a.commit.sha,i.repoPath||(i.repoPath=a.commit.repoPath)}catch(e){return H.error(e,"CopyMessageToClipboardCommand",`getBlameForLine(${t})`),s.window.showErrorMessage("Unable to copy message. See output channel for more details")}}const a=await Ts.git.getLogCommit(i.repoPath,o.sha);if(void 0===a)return;o.message=a.message}return void await a.write(o.message)}catch(e){return e.message.includes("Couldn't find the required `xsel` binary")?void s.window.showErrorMessage("Unable to copy message, xsel is not installed. You can install it via `sudo apt install xsel`"):(H.error(e,"CopyMessageToClipboardCommand"),s.window.showErrorMessage("Unable to copy message. See output channel for more details"))}}}class Eo extends xo{constructor(){super(ji.CopyRemoteFileUrlToClipboard)}async preExecute(e,t={range:!0}){return wo(e)?((t=Object.assign({},t)).range=!1,vo(e)&&(t.branch=void 0!==e.node.branch?e.node.branch.name:void 0),this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={range:!0}){return s.commands.executeCommand(ji.OpenFileInRemote,t,Object.assign({},i,{clipboard:!0}))}}class Bo extends xo{constructor(){super(ji.CopyShaToClipboard)}async preExecute(e,t={}){return wo(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,o={}){t=po(t,e);try{const a=await Promise.resolve().then(i.t.bind(null,14,7));if(o=Object.assign({},o),null==t){const t=await Ts.git.getActiveRepoPath(e);if(!t)return;const i=await Ts.git.getLog(t,{maxCount:1});if(!i)return;o.sha=ee.first(i.commits.values()).sha}else if(void 0===o.sha){const i=e&&e.selection.active.line||0;if(i<0)return;try{const a=await _e.fromUri(t),r=e&&e.document&&e.document.isDirty?await Ts.git.getBlameForLineContents(a,i,e.document.getText()):await Ts.git.getBlameForLine(a,i);if(void 0===r)return;o.sha=r.commit.sha}catch(e){return H.error(e,"CopyShaToClipboardCommand",`getBlameForLine(${i})`),s.window.showErrorMessage("Unable to copy commit id. See output channel for more details")}}return void await a.write(o.sha)}catch(e){return e.message.includes("Couldn't find the required `xsel` binary")?void s.window.showErrorMessage("Unable to copy commit id, xsel is not installed. You can install it via `sudo apt install xsel`"):(H.error(e,"CopyShaToClipboardCommand"),s.window.showErrorMessage("Unable to copy commit id. See output channel for more details"))}}}class No extends xo{constructor(){super([ji.DiffHeadWithBranch,ji.DiffWorkingWithBranch])}async preExecute(e,t={}){switch(e.command){case ji.DiffHeadWithBranch:t.ref2="HEAD";break;case ji.DiffWorkingWithBranch:t.ref2=""}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(void 0===i.ref2)return;let o;t=po(t,e);try{const a=await fo(t,e,`Compare with branch or tag in which repository${T.Ellipsis}`);if(!a)return;if(!i.ref1){let e;switch(i.ref2){case"":e=`Compare Working Tree to${T.Ellipsis}`;break;case"HEAD":e=`Compare HEAD to${T.Ellipsis}`;break;default:e=`Compare ${i.ref2} to${T.Ellipsis}`}o=Gs.showProgress(e);const[t,s]=await Promise.all([Ts.git.getBranches(a),Ts.git.getTags(a)]);if(o.token.isCancellationRequested)return;const r=await Gs.show(t,s,e,{progressCancellation:o});if(void 0===r)return;if(r instanceof Bs)return r.execute();if(i.ref1=r.name,void 0===i.ref1)return}return void Ts.resultsExplorer.showComparisonInResults(a,i.ref1,i.ref2)}catch(e){return H.error(e,"DiffBranchWithBranchCommand"),s.window.showErrorMessage("Unable to open branch compare. See output channel for more details")}finally{o&&o.cancel()}}}class Ao extends xo{constructor(){super([ji.DiffDirectory,ji.ExternalDiffAll,ji.ExplorersOpenDirectoryDiff,ji.ExplorersOpenDirectoryDiffWithWorking])}async preExecute(e,t={}){switch(e.command){case ji.ExternalDiffAll:t.ref1="HEAD",t.ref2=void 0;break;case ji.ExplorersOpenDirectoryDiff:"view"===e.type&&e.node instanceof bs&&(t.ref1=e.node.ref1.ref,t.ref2=e.node.ref2.ref);break;case ji.ExplorersOpenDirectoryDiffWithWorking:(function(e){return"view"===e.type&&e.node instanceof Vi})(e)&&(t.ref1=e.node.ref,t.ref2=void 0)}return this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){let o;t=po(t,e);try{const a=await fo(t,e,`Compare directory in which repository${T.Ellipsis}`);if(!a)return;if(!i.ref1){i=Object.assign({},i);const e=`Compare Working Tree to${T.Ellipsis}`;o=Gs.showProgress(e);const[t,s]=await Promise.all([Ts.git.getBranches(a),Ts.git.getTags(a)]);if(o.token.isCancellationRequested)return;const r=await Gs.show(t,s,e,{progressCancellation:o});if(void 0===r)return;if(r instanceof Bs)return r.execute();if(i.ref1=r.name,void 0===i.ref1)return}return void await Ts.git.openDirectoryDiff(a,i.ref1,i.ref2)}catch(e){if("No diff tool found"===(e&&e.toString())){if(!await s.window.showWarningMessage("Unable to open directory compare because there is no Git diff tool configured","View Git Docs"))return;return s.commands.executeCommand(D.Open,s.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}return H.error(e,"DiffDirectoryCommand"),s.window.showErrorMessage("Unable to open directory compare. See output channel for more details")}finally{o&&o.cancel()}}}var Oo,Lo,Uo;!function(e){e.CommitHasNoPreviousCommitWarning="suppressCommitHasNoPreviousCommitWarning",e.CommitNotFoundWarning="suppressCommitNotFoundWarning",e.FileNotUnderSourceControlWarning="suppressFileNotUnderSourceControlWarning",e.GitDisabledWarning="suppressGitDisabledWarning",e.GitVersionWarning="suppressGitVersionWarning",e.LineUncommittedWarning="suppressLineUncommittedWarning",e.NoRepositoryWarning="suppressNoRepositoryWarning",e.ShowKeyBindingsNotice="suppressShowKeyBindingsNotice"}(Oo||(Oo={}));class Io{static showCommitHasNoPreviousCommitWarningMessage(e){return void 0===e?Io.showMessage("info","Commit has no previous commit.",Oo.CommitHasNoPreviousCommitWarning):Io.showMessage("info",`Commit ${e.shortSha} (${e.author}, ${e.formattedDate}) has no previous commit.`,Oo.CommitHasNoPreviousCommitWarning)}static showCommitNotFoundWarningMessage(e){return Io.showMessage("warn",`${e}. The commit could not be found.`,Oo.CommitNotFoundWarning)}static showFileNotUnderSourceControlWarningMessage(e){return Io.showMessage("warn",`${e}. The file is probably not under source control.`,Oo.FileNotUnderSourceControlWarning)}static showGitDisabledErrorMessage(){return Io.showMessage("error","GitLens requires Git to be enabled. Please re-enable Git — set `git.enabled` to true and reload",Oo.GitDisabledWarning)}static showGitVersionUnsupportedErrorMessage(e){return Io.showMessage("error",`GitLens requires a newer version of Git (>= 2.2.0) than is currently installed (${e}). Please install a more recent version of Git.`,Oo.GitVersionWarning)}static async showKeyBindingsInfoMessage(){if(Ts.config.keymap!==b.Alternate||Ts.config.advanced.messages.suppressShowKeyBindingsNotice)return;const e=[{title:"Keep Shortcuts",isCloseAffordance:!0},{title:"Switch Shortcuts"},{title:"No Shortcuts"}],t=await Io.showMessage("info","GitLens is using keyboard shortcuts which can conflict with menu mnemonics and different keyboard layouts. To avoid such conflicts, it is recommended to switch to the new default keyboard shortcuts.",Oo.ShowKeyBindingsNotice,null,...e);switch(t){case e[1]:await ti.update(ti.name("keymap").value,b.Chorded,s.ConfigurationTarget.Global);break;case e[2]:await ti.update(ti.name("keymap").value,b.None,s.ConfigurationTarget.Global)}return t}static showLineUncommittedWarningMessage(e){return Io.showMessage("warn",`${e}. The line has uncommitted changes.`,Oo.LineUncommittedWarning)}static showNoRepositoryWarningMessage(e){return Io.showMessage("warn",`${e}. No repository could be found.`,Oo.NoRepositoryWarning)}static async showMessage(e,t,i,o={title:"Don't Show Again"},...a){if(H.log(`ShowMessage(${e}, '${t}', ${i}, ${o})`),ti.get(ti.name("advanced")("messages")(i).value))return void H.log(`ShowMessage(${e}, '${t}', ${i}, ${o}) skipped`);null!==o&&a.push(o);let r=void 0;switch(e){case"info":r=await s.window.showInformationMessage(t,...a);break;case"warn":r=await s.window.showWarningMessage(t,...a);break;case"error":r=await s.window.showErrorMessage(t,...a)}return null!==o&&r!==o||(H.log(`ShowMessage(${e}, '${t}', ${i}, ${o}) don't show again requested`),await this.suppressedMessage(i),r!==o)?(H.log(`ShowMessage(${e}, '${t}', ${i}, ${o}) returned ${r?r.title:r}`),r):void 0}static suppressedMessage(e){const t=ti.name("advanced")("messages").value,i=ti.get(t);i[e]=!0;for(const[e,t]of Object.entries(i))!0!==t&&(i[e]=void 0);return ti.update(t,i,s.ConfigurationTarget.Global)}}class Mo extends xo{constructor(){super(ji.DiffLineWithPrevious)}async execute(e,t,i={}){if(null==(t=po(t,e)))return;const o=await _e.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||Zt.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const a=e&&e.document&&e.document.isDirty?await Ts.git.getBlameForLineContents(o,t,e.document.getText()):await Ts.git.getBlameForLine(o,t);if(void 0===a)return Io.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=a.commit,i.commit.isUncommitted){const e=await Ts.git.getStatusForFile(o.repoPath,o.fsPath);void 0!==e&&void 0!==e.indexStatus&&(i.commit=i.commit.with({sha:Zt.stagedUncommittedSha}))}}catch(e){return H.error(e,"DiffLineWithPreviousCommand",`getBlameForLine(${t})`),s.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const a={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:Zt.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return s.commands.executeCommand(ji.DiffWith,a)}}class Wo extends xo{constructor(){super(ji.DiffLineWithWorking)}async execute(e,t,i={}){if(null==(t=po(t,e)))return;const o=await _e.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||Zt.isUncommitted(i.commit.sha)){const t=i.line;if(t<0)return;try{const a=e&&e.document&&e.document.isDirty?await Ts.git.getBlameForLineContents(o,t,e.document.getText()):await Ts.git.getBlameForLine(o,t);if(void 0===a)return Io.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(i.commit=a.commit,i.commit.isUncommitted){const e=await Ts.git.getStatusForFile(o.repoPath,o.fsPath);i.commit=i.commit.with({sha:void 0!==e&&void 0!==e.indexStatus?Zt.stagedUncommittedSha:i.commit.previousSha,fileName:i.commit.previousFileName,originalFileName:null,previousSha:null,previousFileName:null}),i.line=a.line.line+1}}catch(e){return H.error(e,"DiffLineWithWorkingCommand",`getBlameForLine(${t})`),s.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const a={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return s.commands.executeCommand(ji.DiffWith,a)}}class Ho extends xo{static getMarkdownCommandArgs(e,t){let i;if(e instanceof Be){const s=e;i=void 0===t?s.isUncommitted?{repoPath:s.repoPath,lhs:{sha:"HEAD",uri:s.uri},rhs:{sha:"",uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:void 0!==s.previousSha?s.previousSha:Zt.deletedSha,uri:s.previousUri},rhs:{sha:s.sha,uri:s.uri}}:{repoPath:s.repoPath,lhs:{sha:s.sha,uri:s.uri},rhs:{sha:t.sha,uri:t.uri}}}else i=e;return super.getMarkdownCommandArgsCore(ji.DiffWith,i)}constructor(){super(ji.DiffWith)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i,{lhs:Object.assign({},i.lhs),rhs:Object.assign({},i.rhs),showOptions:Object.assign({},i.showOptions)})).repoPath&&void 0!==i.lhs&&void 0!==i.rhs)try{Zt.isResolveRequired(i.lhs.sha)&&(i.lhs.sha=await Ts.git.resolveReference(i.repoPath,i.lhs.sha,i.lhs.uri)),Zt.isResolveRequired(i.rhs.sha)&&(i.rhs.sha=await Ts.git.resolveReference(i.repoPath,i.rhs.sha,i.rhs.uri));const[e,t]=await Promise.all([Ts.git.getVersionedFile(i.repoPath,i.lhs.uri.fsPath,i.lhs.sha),Ts.git.getVersionedFile(i.repoPath,i.rhs.uri.fsPath,i.rhs.sha)]);let o="";void 0===t?o=Zt.isUncommitted(i.rhs.sha)?" (deleted)":"deleted in ":void 0!==e&&i.lhs.sha!==Zt.deletedSha||(o="added in ");let a="";if(void 0===e&&""===i.rhs.sha&&(void 0!==t?(a="not in ",o=""):a="deleted in "),void 0===i.lhs.title&&i.lhs.sha!==Zt.deletedSha&&(void 0!==e||""!==a)){const e=Zt.shortenSha(i.lhs.sha)||"";i.lhs.title=`${y.basename(i.lhs.uri.fsPath)}${""!==e?` (${a}${e})`:""}`}if(void 0===i.rhs.title&&i.rhs.sha!==Zt.deletedSha){const e=Zt.shortenSha(i.rhs.sha,{uncommitted:"working tree"})||"";i.rhs.title=`${y.basename(i.rhs.uri.fsPath)}${""!==e?` (${o}${e})`:o}`}const r=void 0!==i.lhs.title&&void 0!==i.rhs.title?`${i.lhs.title} ${T.ArrowLeftRightLong} ${i.rhs.title}`:i.lhs.title||i.rhs.title;return void 0===i.showOptions&&(i.showOptions={}),void 0===i.showOptions.viewColumn&&(i.showOptions.viewColumn=s.ViewColumn.Active),void 0!==i.line&&0!==i.line&&(i.showOptions.selection=new s.Range(i.line,0,i.line,0)),await s.commands.executeCommand(D.Diff,void 0===e?_e.toRevisionUri(Zt.deletedSha,i.lhs.uri.fsPath,i.repoPath):e,void 0===t?_e.toRevisionUri(Zt.deletedSha,i.rhs.uri.fsPath,i.repoPath):t,r,i.showOptions)}catch(e){return H.error(e,"DiffWithCommand","getVersionedFile"),s.window.showErrorMessage("Unable to open compare. See output channel for more details")}}}class jo extends xo{constructor(){super(ji.DiffWithBranch)}async execute(e,t,i={}){if(null==(t=po(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);const o=await _e.fromUri(t);if(!o.repoPath)return Io.showNoRepositoryWarningMessage("Unable to open file compare");const a=`Compare ${y.basename(o.fsPath)} with${T.Ellipsis}`,r=Gs.showProgress(a);try{const[e,t]=await Promise.all([Ts.git.getBranches(o.repoPath),Ts.git.getTags(o.repoPath)]);if(r.token.isCancellationRequested)return;const n=await Gs.show(e,t,a,{progressCancellation:r,goBackCommand:i.goBackCommand});if(void 0===n)return;if(n instanceof Bs)return n.execute();const l=n.name;if(void 0===l)return;let c,h;const d=await Ts.git.getDiffStatus(o.repoPath,"HEAD",l,{filter:"R"});if(void 0!==d){const e=ae.normalizePath(y.relative(o.repoPath,o.fsPath)),t=d.find(t=>t.fileName===e);void 0!==t&&void 0!==t.originalFileName&&(c=s.Uri.file(y.join(o.repoPath,t.originalFileName)),h=`${y.basename(t.originalFileName)} (${l})`)}const m={repoPath:o.repoPath,lhs:{sha:n.remote?`remotes/${l}`:l,uri:c||o,title:h||`${y.basename(o.fsPath)} (${l})`},rhs:{sha:"",uri:o},line:i.line,showOptions:i.showOptions};return s.commands.executeCommand(ji.DiffWith,m)}finally{r.cancel()}}}class Go extends xo{constructor(){super(ji.DiffWithNext)}async execute(e,t,i={}){if(null==(t=po(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);const o=await _e.fromUri(t);let a;if(void 0===i.commit||!(i.commit instanceof Me)||void 0!==i.range)try{const e=void 0===i.commit?o.sha:i.commit.sha;if(Zt.isStagedUncommitted(e)){const t={repoPath:o.repoPath,lhs:{sha:e,uri:o},rhs:{sha:"",uri:o},line:i.line,showOptions:i.showOptions};return s.commands.executeCommand(ji.DiffWith,t)}let r=await Ts.git.getLogForFile(o.repoPath,o.fsPath,{maxCount:void 0!==e?void 0:2,range:i.range,renames:!0});if(void 0===r){const t=await Ts.git.findNextFileName(o.repoPath,o.fsPath);if(void 0!==t&&(r=await Ts.git.getLogForFile(o.repoPath,t,{maxCount:void 0!==e?void 0:2,range:i.range,renames:!0})),void 0===r)return Io.showFileNotUnderSourceControlWarningMessage("Unable to open compare")}if(i.commit=e&&r.commits.get(e)||ee.first(r.commits.values()),void 0===o.sha&&void 0!==(a=await Ts.git.getStatusForFile(o.repoPath,o.fsPath)))return s.commands.executeCommand(ji.DiffWithWorking,t)}catch(e){return H.error(e,"DiffWithNextCommand",`getLogForFile(${o.repoPath}, ${o.fsPath})`),s.window.showErrorMessage("Unable to open compare. See output channel for more details")}if(void 0===i.commit.nextSha){if(void 0!==(a=a||await Ts.git.getStatusForFile(o.repoPath,o.fsPath))&&"M"===a.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:Zt.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return s.commands.executeCommand(ji.DiffWith,e)}return s.commands.executeCommand(ji.DiffWithWorking,t)}const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:i.commit.nextSha,uri:i.commit.nextUri},line:i.line,showOptions:i.showOptions};return s.commands.executeCommand(ji.DiffWith,r)}}class Vo extends xo{constructor(){super([ji.DiffWithPrevious,ji.DiffWithPreviousInDiff])}async preExecute(e,t={}){return e.command===ji.DiffWithPreviousInDiff&&(t.inDiffEditor=!0),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=po(t,e)))return;if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||!i.commit.isFile){const e=await _e.fromUri(t);try{let o=void 0===i.commit?e.sha:i.commit.sha;if(o===Zt.deletedSha)return Io.showCommitHasNoPreviousCommitWarningMessage();let a=!1;Zt.isStagedUncommitted(o)&&(e.sha=o=void 0,a=!0),i.inDiffEditor&&void 0!==o&&(o+="^"),i.commit=void 0;let r=await Ts.git.getLogForFile(e.repoPath,e.fsPath,{maxCount:2,ref:o,renames:!0});if(void 0!==r)i.commit=o&&r.commits.get(o)||ee.first(r.commits.values());else{if(void 0===o||!o.endsWith("^"))return Io.showFileNotUnderSourceControlWarningMessage("Unable to open compare");if(void 0===(r=await Ts.git.getLogForFile(e.repoPath,e.fsPath,{maxCount:3,ref:o.substring(0,o.length-1),renames:!0})))return Io.showFileNotUnderSourceControlWarningMessage("Unable to open compare");i.commit=ee.next(ee.skip(r.commits.values(),1))||ee.first(r.commits.values())}if(void 0===e.sha){const o=await Ts.git.getStatusForFile(e.repoPath,e.fsPath);if(void 0!==o){if(a){const e={repoPath:i.commit.repoPath,lhs:{sha:i.inDiffEditor?i.commit.previousSha||Zt.deletedSha:i.commit.sha,uri:i.inDiffEditor?i.commit.previousUri:i.commit.uri},rhs:{sha:i.inDiffEditor?i.commit.sha:Zt.stagedUncommittedSha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return s.commands.executeCommand(ji.DiffWith,e)}if(void 0!==o.indexStatus){const e={repoPath:i.commit.repoPath,lhs:{sha:i.inDiffEditor?i.commit.sha:Zt.stagedUncommittedSha,uri:i.commit.uri},rhs:{sha:i.inDiffEditor?Zt.stagedUncommittedSha:"",uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return s.commands.executeCommand(ji.DiffWith,e)}if(!i.inDiffEditor)return s.commands.executeCommand(ji.DiffWithWorking,t,{commit:i.commit,showOptions:i.showOptions})}}}catch(t){return H.error(t,"DiffWithPreviousCommand",`getLogForFile(${e.repoPath}, ${e.fsPath})`),s.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const o={repoPath:i.commit.repoPath,lhs:{sha:void 0!==i.commit.previousSha?i.commit.previousSha:Zt.deletedSha,uri:i.commit.previousUri},rhs:{sha:i.commit.sha,uri:i.commit.uri},line:i.line,showOptions:i.showOptions};return s.commands.executeCommand(ji.DiffWith,o)}}class zo extends xo{constructor(){super(ji.DiffWithRevision)}async execute(e,t,i={}){if(null==(t=po(t,e)))return;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);const o=await _e.fromUri(t),a=`Compare ${o.getFormattedPath(i.branchOrTag?` (${i.branchOrTag.name})${ae.pad(T.Dot,2,2)}`:void 0)}${o.sha?` ${ae.pad(T.Dot,1,1)} ${o.shortSha}`:""} with revision${T.Ellipsis}`,r=ro.showProgress(a);try{const e=await Ts.git.getLogForFile(o.repoPath,o.fsPath,{maxCount:i.maxCount,ref:i.branchOrTag&&i.branchOrTag.ref||o.sha});if(void 0===e)return i.branchOrTag?s.window.showWarningMessage(`The file could not be found in ${i.branchOrTag.name}`):Io.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(r.token.isCancellationRequested)return;let n=void 0;if(e.truncated){const s=new Bs({label:"$(arrow-right) Show Next Commits",description:`${ae.pad(T.Dash,2,3)} shows ${e.maxCount} newer commits`},ji.DiffWithRevision,[t,Object.assign({},i)]),o=ee.last(e.commits.values());null!=o&&(n=new Bs({label:"$(arrow-left) Show Previous Commits",description:`${ae.pad(T.Dash,2,3)} shows ${e.maxCount} older commits`},ji.DiffWithRevision,[new _e(t,o),Object.assign({},i,{nextPageCommand:s})]))}const l=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to history of ${T.Space}$(file-text) ${o.getFormattedPath()}${i.branchOrTag?` from ${T.Space}${i.branchOrTag instanceof ut?"$(tag)":"$(git-branch)"} ${i.branchOrTag.name}`:o.sha?` from ${T.Space}$(git-commit) ${o.shortSha}`:""}`},ji.DiffWithRevision,[t,Object.assign({},i)]),c=await ro.show(e,o,a,{pickerOnly:!0,progressCancellation:r,currentCommand:l,nextPageCommand:i.nextPageCommand,previousPageCommand:n,showAllCommand:void 0!==e&&e.truncated?new Bs({label:"$(sync) Show All Commits",description:`${ae.pad(T.Dash,2,3)} this may take a while`},ji.DiffWithRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===c)return;let h;if(c instanceof As){const e=await c.execute();if(void 0===e)return;return e instanceof Bs?e.execute():s.commands.executeCommand(ji.DiffWithRevision,o,Object.assign({},i,{branchOrTag:e.branchOrTag,goBackCommand:l}))}if(c instanceof Bs)return c.execute();h=c.commit.sha;const d={repoPath:o.repoPath,lhs:{sha:h,uri:o},rhs:{sha:"",uri:o},line:i.line,showOptions:i.showOptions};return await s.commands.executeCommand(ji.DiffWith,d)}catch(e){return H.error(e,"DiffWithRevisionCommand"),s.window.showErrorMessage("Unable to open compare. See output channel for more details")}finally{r.cancel()}}}class Qo extends xo{constructor(){super(ji.DiffWithWorking)}async execute(e,t,i={}){if(null==(t=po(t,e)))return;const o=await _e.fromUri(t);if(void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line),void 0===i.commit||Zt.isUncommitted(i.commit.sha)){if(void 0===o.sha)return s.window.showInformationMessage("File matches the working tree");if(Zt.isStagedUncommitted(o.sha)){o.sha=void 0;const e=await Ts.git.getStatusForFile(o.repoPath,o.fsPath);if(void 0!==e&&void 0!==e.indexStatus){const e={repoPath:o.repoPath,lhs:{sha:Zt.stagedUncommittedSha,uri:o.fileUri()},rhs:{sha:"",uri:o.fileUri()},line:i.line,showOptions:i.showOptions};return s.commands.executeCommand(ji.DiffWith,e)}}try{if(i.commit=await Ts.git.getLogCommitForFile(o.repoPath,o.fsPath,{ref:o.sha,firstIfNotFound:!0}),void 0===i.commit)return Io.showFileNotUnderSourceControlWarningMessage("Unable to open compare")}catch(e){return H.error(e,"DiffWithWorkingCommand",`getLogCommit(${o.repoPath}, ${o.fsPath}, ${o.sha})`),s.window.showErrorMessage("Unable to open compare. See output channel for more details")}}const[a]=await Ts.git.findWorkingFileName(o.fsPath,o.repoPath);if(void 0===a)return;i.commit.workingFileName=a;const r={repoPath:i.commit.repoPath,lhs:{sha:i.commit.sha,uri:i.commit.uri},rhs:{sha:"",uri:i.commit.workingUri},line:i.line,showOptions:i.showOptions};return s.commands.executeCommand(ji.DiffWith,r)}}!function(e){e[e.INDEX_MODIFIED=0]="INDEX_MODIFIED",e[e.INDEX_ADDED=1]="INDEX_ADDED",e[e.INDEX_DELETED=2]="INDEX_DELETED",e[e.INDEX_RENAMED=3]="INDEX_RENAMED",e[e.INDEX_COPIED=4]="INDEX_COPIED",e[e.MODIFIED=5]="MODIFIED",e[e.DELETED=6]="DELETED",e[e.UNTRACKED=7]="UNTRACKED",e[e.IGNORED=8]="IGNORED",e[e.ADDED_BY_US=9]="ADDED_BY_US",e[e.ADDED_BY_THEM=10]="ADDED_BY_THEM",e[e.DELETED_BY_US=11]="DELETED_BY_US",e[e.DELETED_BY_THEM=12]="DELETED_BY_THEM",e[e.BOTH_ADDED=13]="BOTH_ADDED",e[e.BOTH_DELETED=14]="BOTH_DELETED",e[e.BOTH_MODIFIED=15]="BOTH_MODIFIED"}(Lo||(Lo={})),function(e){e[e.Merge=0]="Merge",e[e.Index=1]="Index",e[e.WorkingTree=2]="WorkingTree"}(Uo||(Uo={}));class qo{constructor(e,t){this.uri=e,this.staged=t}}class Ko extends yo{constructor(){super(ji.ExternalDiff)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).files=e.scmResourceStates.map(e=>new qo(e.resourceUri,e.resourceGroupType===Uo.Index)),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).files=G.filterMap(e.scmResourceGroups[0].resourceStates,e=>this.isModified(e)?new qo(e.resourceUri,e.resourceGroupType===Uo.Index):void 0),this.execute(t)):this.execute(t)}isModified(e){const t=e.type;return t===Lo.BOTH_MODIFIED||t===Lo.INDEX_MODIFIED||t===Lo.MODIFIED}async execute(e={}){try{const t=await fo(void 0,void 0,`Open changes from which repository${T.Ellipsis}`);if(!t)return;const i=await Ts.git.getDiffTool(t);if(void 0===i){if(!await s.window.showWarningMessage("Unable to open changes in diff tool because there is no Git diff tool configured","View Git Docs"))return;return s.commands.executeCommand(D.Open,s.Uri.parse("https://git-scm.com/docs/git-config#git-config-difftool"))}if(void 0===e.files){const i=await Ts.git.getStatusForRepo(t);if(void 0===i)return s.window.showWarningMessage("Unable to open changes in diff tool");e.files=[];for(const t of i.files)"M"===t.indexStatus&&e.files.push(new qo(t.uri,!0)),"M"===t.workTreeStatus&&e.files.push(new qo(t.uri,!1))}for(const s of e.files)Ts.git.openDiffTool(t,s.uri,s.staged,i);return}catch(e){return H.error(e,"ExternalDiffCommand"),s.window.showErrorMessage("Unable to open changes in diff tool. See output channel for more details")}}}class Yo extends xo{constructor(){super(ji.OpenBranchesInRemote)}async preExecute(e,t={}){return bo(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const o=(t=po(t,e))&&await _e.fromUri(t),a=await fo(o,e,`Open branches in remote for which repository${T.Ellipsis}`);if(a)try{const e=await Ts.git.getRemotes(a);return s.commands.executeCommand(ji.OpenInRemote,t,{resource:{type:"branches"},remote:i.remote,remotes:e})}catch(e){return H.error(e,"OpenBranchesInRemoteCommand"),s.window.showErrorMessage("Unable to open branches in remote provider. See output channel for more details")}}}class Xo extends xo{constructor(){super(ji.OpenBranchInRemote)}async preExecute(e,t={}){return vo(e)&&((t=Object.assign({},t)).branch=e.node.branch.name,t.remote=e.node.branch.getRemote()),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const o=(t=po(t,e))&&await _e.fromUri(t),a=await fo(o,e,`Open branch in remote for which repository${T.Ellipsis}`);if(a)try{if(void 0===i.branch){i=Object.assign({},i);const e=(await Ts.git.getBranches(a)).filter(e=>void 0!==e.tracking);if(e.length>1){const t=await zs.show(e,`Open which branch in remote${T.Ellipsis}`);if(void 0===t)return;if(t instanceof Bs)return;i.branch=t.branch.name}else 1===e.length&&(i.branch=e[0].name)}const e=await Ts.git.getRemotes(a);return s.commands.executeCommand(ji.OpenInRemote,t,{resource:{type:"branch",branch:i.branch||"HEAD"},remote:i.remote,remotes:e})}catch(e){return H.error(e,"OpenBranchInRemoteCommandArgs"),s.window.showErrorMessage("Unable to open branch in remote provider. See output channel for more details")}}}class Zo extends xo{constructor(){super(ji.OpenChangedFiles)}async execute(e,t,i={}){t=po(t,e);try{if(void 0===i.uris){i=Object.assign({},i);const o=await fo(t,e,`Open changed files in which repository${T.Ellipsis}`);if(!o)return;const a=await Ts.git.getStatusForRepo(o);if(void 0===a)return s.window.showWarningMessage("Unable to open changed files");i.uris=G.filterMap(a.files,e=>"D"!==e.status?e.uri:void 0)}for(const e of i.uris)await Do(e,{preserveFocus:!0,preview:!1});return}catch(e){return H.error(e,"OpenChangedFilesCommand"),s.window.showErrorMessage("Unable to open changed files. See output channel for more details")}}}class Jo extends xo{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(ji.OpenCommitInRemote,t)}constructor(){super(ji.OpenCommitInRemote)}async preExecute(e,t={}){return wo(e)?((t=Object.assign({},t)).sha=e.node.commit.sha,this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=po(t,e)))return;const o=await _e.fromUri(t);if(o.repoPath)try{if(void 0===i.sha){const t=null==e?0:e.selection.active.line;if(t<0)return;const s=e&&e.document&&e.document.isDirty?await Ts.git.getBlameForLineContents(o,t,e.document.getText()):await Ts.git.getBlameForLine(o,t);if(void 0===s)return Io.showFileNotUnderSourceControlWarningMessage("Unable to open commit in remote provider");let a=s.commit;a.isUncommitted&&(a=a.with({sha:a.previousSha,fileName:a.previousFileName,previousSha:null,previousFileName:null})),i.sha=a.sha}const a=await Ts.git.getRemotes(o.repoPath);return s.commands.executeCommand(ji.OpenInRemote,t,{resource:{type:"commit",sha:i.sha},remotes:a})}catch(e){return H.error(e,"OpenCommitInRemoteCommand"),s.window.showErrorMessage("Unable to open commit in remote provider. See output channel for more details")}}}class ea extends xo{constructor(){super(ji.OpenFileInRemote)}async preExecute(e,t={range:!0}){return wo(e)?((t=Object.assign({},t)).range=!1,vo(e)&&(t.branch=void 0!==e.node.branch?e.node.branch.name:void 0),this.execute(e.editor,e.node.commit.uri,t)):this.execute(e.editor,e.uri,t)}async execute(e,t,i={range:!0}){if(null==(t=po(t,e)))return;const o=await _e.fromUri(t);if(o.repoPath){if(void 0===i.branch){const e=await Ts.git.getBranch(o.repoPath);if(void 0===e||void 0===e.tracking){const e=(await Ts.git.getBranches(o.repoPath)).filter(e=>void 0!==e.tracking);if(e.length>1){const t=await zs.show(e,i.clipboard?`Copy url for ${o.getRelativePath()} to clipboard for which branch${T.Ellipsis}`:`Open ${o.getRelativePath()} in remote for which branch${T.Ellipsis}`);if(void 0===t)return;if(t instanceof Bs)return;i.branch=t.branch.name}else 1===e.length&&(i.branch=e[0].name)}else i.branch=e.name}try{const a=await Ts.git.getRemotes(o.repoPath),r=i.range&&null!=e?new s.Range(e.selection.start.with({line:e.selection.start.line+1}),e.selection.end.with({line:e.selection.end.line+1})):void 0;return s.commands.executeCommand(ji.OpenInRemote,t,{resource:{type:void 0===o.sha?"file":"revision",branch:i.branch||"HEAD",fileName:o.getRelativePath(),range:r,sha:o.sha},remotes:a,clipboard:i.clipboard})}catch(e){return H.error(e,"OpenFileInRemoteCommand"),s.window.showErrorMessage("Unable to open file in remote provider. See output channel for more details")}}}}class ta extends xo{static getMarkdownCommandArgs(e,t,i){let o;if(e instanceof s.Uri){o={uri:e,line:i,annotationType:t}}else o=e;return super.getMarkdownCommandArgsCore(ji.OpenFileRevision,o)}constructor(){super(ji.OpenFileRevision)}async execute(e,t,i={}){let o;void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);try{if(null==i.uri){if(null==(t=po(t,e)))return;const a=await _e.fromUri(t),r=`Open revision of ${a.getFormattedPath(i.branchOrTag?` (${i.branchOrTag.name})${ae.pad(T.Dot,2,2)}`:void 0)}${a.sha?` ${ae.pad(T.Dot,1,1)} ${a.shortSha}`:""}${T.Ellipsis}`;o=ro.showProgress(r);const n=await Ts.git.getLogForFile(a.repoPath,a.fsPath,{maxCount:i.maxCount,ref:i.branchOrTag&&i.branchOrTag.ref||a.sha});if(void 0===n)return i.branchOrTag?s.window.showWarningMessage(`The file could not be found in ${i.branchOrTag.name}`):Io.showFileNotUnderSourceControlWarningMessage("Unable to open history compare");if(o.token.isCancellationRequested)return;let l=void 0;if(n.truncated){const e=new Bs({label:"$(arrow-right) Show Next Commits",description:`${ae.pad(T.Dash,2,3)} shows ${n.maxCount} newer commits`},ji.OpenFileRevision,[t,Object.assign({},i)]),s=ee.last(n.commits.values());null!=s&&(l=new Bs({label:"$(arrow-left) Show Previous Commits",description:`${ae.pad(T.Dash,2,3)} shows ${n.maxCount} older commits`},ji.OpenFileRevision,[new _e(t,s),Object.assign({},i,{nextPageCommand:e})]))}const c=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to history of ${T.Space}$(file-text) ${a.getFormattedPath()}${i.branchOrTag?` from ${T.Space}${i.branchOrTag instanceof ut?"$(tag)":"$(git-branch)"} ${i.branchOrTag.name}`:a.sha?` from ${T.Space}$(git-commit) ${a.shortSha}`:""}`},ji.OpenFileRevision,[t,Object.assign({},i)]),h=await ro.show(n,a,r,{pickerOnly:!0,progressCancellation:o,currentCommand:c,nextPageCommand:i.nextPageCommand,previousPageCommand:l,showAllCommand:void 0!==n&&n.truncated?new Bs({label:"$(sync) Show All Commits",description:`${ae.pad(T.Dash,2,3)} this may take a while`},ji.OpenFileRevision,[t,Object.assign({},i,{maxCount:0})]):void 0});if(void 0===h)return;if(h instanceof As){const e=await h.execute();if(void 0===e)return;return e instanceof Bs?e.execute():s.commands.executeCommand(ji.OpenFileRevision,a,Object.assign({},i,{branchOrTag:e.branchOrTag,goBackCommand:c}))}if(h instanceof Bs)return h.execute();i.uri=_e.toRevisionUri(h.commit.sha,h.commit.uri.fsPath,h.commit.repoPath)}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new s.Range(i.line,0,i.line,0));const a=await Do(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?a:Ts.fileAnnotations.show(a,i.annotationType,i.line)}catch(e){return H.error(e,"OpenFileRevisionCommand"),s.window.showErrorMessage("Unable to open file revision. See output channel for more details")}finally{o&&o.cancel()}}}class ia extends xo{constructor(){super(ji.OpenInRemote)}async execute(e,t,i={}){if(void 0!==(i=Object.assign({},i)).remotes&&void 0!==i.resource){if(void 0!==i.remote){const e=i.remotes.filter(e=>e.name===i.remote);e.length>0&&(i.remotes=e)}try{if(1===i.remotes.length){this.ensureRemoteBranchName(i);const e=new Qs(i.remotes[0],i.resource,i.clipboard);return await e.execute()}const e=i.clipboard?"Copy url for":"Open",t=i.clipboard?`to clipboard from${T.Ellipsis}`:`in${T.Ellipsis}`;let o="";switch(i.resource.type){case He.Branch:this.ensureRemoteBranchName(i),o=`${e} ${i.resource.branch} branch ${t}`;break;case He.Commit:o=`${e} commit ${Zt.shortenSha(i.resource.sha)} ${t}`;break;case He.File:o=`${e} ${i.resource.fileName} ${t}`;break;case He.Revision:if(void 0!==i.resource.commit&&i.resource.commit instanceof Me)"D"===i.resource.commit.status?(i.resource.sha=i.resource.commit.previousSha,o=`${e} ${i.resource.fileName} ${ae.pad(T.Dot,1,1)} ${i.resource.commit.previousShortSha} ${t}`):(i.resource.sha=i.resource.commit.sha,o=`${e} ${i.resource.fileName} ${ae.pad(T.Dot,1,1)} ${i.resource.commit.shortSha} ${t}`);else{const s=void 0===i.resource.sha?"":Zt.shortenSha(i.resource.sha),a=s?` ${ae.pad(T.Dot,1,1)} ${s}`:"";o=`${e} ${i.resource.fileName}${a} ${t}`}}const a=await Ks.show(i.remotes,o,i.resource,i.clipboard,i.goBackCommand);if(void 0===a)return;return await a.execute()}catch(e){return H.error(e,"OpenInRemoteCommand"),s.window.showErrorMessage("Unable to open in remote provider. See output channel for more details")}}}ensureRemoteBranchName(e){if(void 0===e.remotes||void 0===e.resource||"branch"!==e.resource.type)return;const t=e.resource.branch.indexOf("/");if(t>=0){const i=e.resource.branch.substring(0,t),s=e.remotes.find(e=>e.name===i);void 0!==s&&(e.resource.branch=e.resource.branch.substring(t+1),e.remotes=[s])}}}class sa extends xo{constructor(){super(ji.OpenRepoInRemote)}async preExecute(e,t={}){return bo(e)&&((t=Object.assign({},t)).remote=e.node.remote.name),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){const o=(t=po(t,e))&&await _e.fromUri(t),a=await fo(o,e,`Open which repository in remote${T.Ellipsis}`);if(a)try{const e=await Ts.git.getRemotes(a);return s.commands.executeCommand(ji.OpenInRemote,t,{resource:{type:"repo"},remote:i.remote,remotes:e})}catch(e){return H.error(e,"OpenRepoInRemoteCommand"),s.window.showErrorMessage("Unable to open repository in remote provider. See output channel for more details")}}}class oa extends xo{constructor(){super(ji.OpenWorkingFile)}async execute(e,t,i={}){void 0===(i=Object.assign({},i)).line&&(i.line=null==e?0:e.selection.active.line);try{if(null==i.uri){if(null==(t=po(t,e)))return;if(i.uri=await _e.fromUri(t),i.uri instanceof _e&&i.uri.sha){const[e,t]=await Ts.git.findWorkingFileName(i.uri.fsPath,i.uri.repoPath);void 0!==e&&void 0!==t&&(i.uri=new _e(s.Uri.file(y.resolve(t,e)),t))}}void 0!==i.line&&0!==i.line&&(void 0===i.showOptions&&(i.showOptions={}),i.showOptions.selection=new s.Range(i.line,0,i.line,0));const o=await Do(i.uri,Object.assign({},i.showOptions,{rethrow:!0}));return void 0===i.annotationType?o:Ts.fileAnnotations.show(o,i.annotationType,i.line)}catch(e){return H.error(e,"OpenWorkingFileCommand"),s.window.showErrorMessage("Unable to open working file. See output channel for more details")}}}class aa extends yo{constructor(){super(ji.ResetSuppressedWarnings)}async execute(){await ti.update(ti.name("advanced")("messages").value,void 0,s.ConfigurationTarget.Global)}}const ra=/^([@~=:#])/,na=new Map([["@",Xt.Author],["~",Xt.ChangedLines],["=",Xt.Changes],[":",Xt.Files],["#",Xt.Sha]]);class la extends So{constructor(){super(ji.ShowCommitSearch)}async execute(e,t,i={}){const o=(t=po(t,e))&&await _e.fromUri(t),a=await fo(o,e,`Search for commits in which repository${T.Ellipsis}`,i.goBackCommand);if(!a)return;i=Object.assign({},i);const r=Object.assign({},i);if(!i.search||null==i.searchBy){try{if(!i.search&&null!=e&&null!=o){const t=await Ts.git.getBlameForLine(o,e.selection.active.line);void 0===t||t.commit.isUncommitted||(i.search=`#${t.commit.shortSha}`)}}catch(e){H.error(e,"ShowCommitSearchCommand","search prefetch failed")}if(i.search=await s.window.showInputBox({value:i.search,prompt:"Please enter a search string",placeHolder:"search by message, author (@<pattern>), files (:<pattern>), commit id (#<sha>), changes (=<pattern>), changed lines (~<pattern>)"}),void 0===i.search)return void 0===i.goBackCommand?void 0:i.goBackCommand.execute();r.search=i.search;const t=ra.exec(i.search);t&&t[1]?(i.searchBy=na.get(t[1]),i.search=i.search.substring(" "===i.search[1]?2:1)):Zt.isSha(i.search)?i.searchBy=Xt.Sha:i.searchBy=Xt.Message}void 0===i.searchBy&&(i.searchBy=Xt.Message);let n=void 0;switch(i.searchBy){case Xt.Author:n=`commits with an author matching '${i.search}'`;break;case Xt.ChangedLines:n=`commits with changed lines matching '${i.search}'`;break;case Xt.Changes:n=`commits with changes matching '${i.search}'`;break;case Xt.Files:n=`commits with files matching '${i.search}'`;break;case Xt.Message:n=i.search?`commits with a message matching '${i.search}'`:"all commits";break;case Xt.Sha:n=`commits with an id matching '${i.search}'`}const l=ao.showProgress(n);try{const e=await Ts.git.getLogForSearch(a,i.search,i.searchBy,{maxCount:i.maxCount});if(l.token.isCancellationRequested)return;let o,c=i.goBackCommand||new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to commit search`},ji.ShowCommitSearch,[t,r]);if(i.searchBy!==Xt.Sha||void 0===e||1!==e.count){const s=await ao.show(e,n,l,{goBackCommand:c,showAllCommand:void 0!==e&&e.truncated?new Bs({label:"$(sync) Show All Commits",description:`${ae.pad(T.Dash,2,3)} this may take a while`},ji.ShowCommitSearch,[t,Object.assign({},i,{maxCount:0,goBackCommand:c})]):void 0,showInResultsExplorerCommand:void 0!==e?new Hs(e,n):void 0});if(void 0===s)return;if(s instanceof Bs)return s.execute();o=s.commit,c=void 0}else o=ee.first(e.commits.values());return s.commands.executeCommand(ji.ShowQuickCommitDetails,o.toGitUri(),{sha:o.sha,commit:o,goBackCommand:c||new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,2)} to search for ${n}`},ji.ShowCommitSearch,[t,i])})}catch(e){return H.error(e,"ShowCommitSearchCommand"),s.window.showErrorMessage("Unable to find commits. See output channel for more details")}finally{l.cancel()}}}class ca extends yo{constructor(){super(ji.ShowGitExplorer)}execute(){return Ts.gitExplorer.show(f.Repository)}}class ha extends yo{constructor(){super(ji.ShowHistoryExplorer)}execute(){return Ts.config.historyExplorer.enabled?Ts.historyExplorer.show():Ts.gitExplorer.show(f.History)}}class da extends yo{constructor(){super(ji.ShowLastQuickPick)}async execute(){const e=$o;if(void 0!==e)try{return s.commands.executeCommand(e.command,...e.args)}catch(e){return H.error(e,"ShowLastQuickPickCommand"),s.window.showErrorMessage("Unable to show last quick pick. See output channel for more details")}}}class ma extends So{constructor(){super(ji.ShowQuickBranchHistory)}async execute(e,t,i={}){const o=(t=po(t,e))&&await _e.fromUri(t);let a=void 0===(i=Object.assign({},i)).branch?void 0:Ys.showProgress(i.branch);try{const r=i.repoPath||await fo(o,e,`Show branch history in which repository${T.Ellipsis}`);if(!r)return;if(void 0===i.branch){const s=await Ts.git.getBranches(r);let o;await Ts.git.getRepoPathOrActive(t,e)||(o=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to which repository`},ji.ShowQuickBranchHistory,[t,i]));const n=await zs.show(s,`Show history for branch${T.Ellipsis}`,{goBackCommand:o});if(void 0===n)return;if(n instanceof Bs)return n.execute();if(i.branch=n.branch.name,void 0===i.branch)return;a=Ys.showProgress(i.branch)}if(void 0===i.log&&(i.log=await Ts.git.getLog(r,{maxCount:i.maxCount,ref:o&&o.sha||i.branch}),void 0===i.log))return s.window.showWarningMessage("Unable to show branch history");if(void 0!==a&&a.token.isCancellationRequested)return;const n=await Ys.show(i.log,o,i.branch,a,i.goBackCommand,i.nextPageCommand);if(void 0===n)return;if(n instanceof Bs)return n.execute();const l=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to ${T.Space}$(git-branch) ${i.branch} history`},ji.ShowQuickBranchHistory,[t,Object.assign({},i)]);return s.commands.executeCommand(ji.ShowQuickCommitDetails,n.commit.toGitUri(),{sha:n.commit.sha,commit:n.commit,repoLog:i.log,goBackCommand:l})}catch(e){return H.error(e,"ShowQuickBranchHistoryCommand"),s.window.showErrorMessage("Unable to show branch history. See output channel for more details")}finally{a&&a.cancel()}}}class ua extends So{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(ji.ShowQuickCommitDetails,t)}constructor(){super(ji.ShowQuickCommitDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,wo(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=po(t,e)))return;const o=await _e.fromUri(t);let a=o.repoPath,r=y.relative(a||"",o.fsPath);if(void 0===(i=Object.assign({},i)).sha){if(null==e)return;const t=e.selection.active.line;if(t<0)return;try{const e=await Ts.git.getBlameForLine(o,t);if(void 0===e)return Io.showFileNotUnderSourceControlWarningMessage("Unable to show commit details");if(e.commit.isUncommitted)return Io.showLineUncommittedWarningMessage("Unable to show commit details");i.sha=e.commit.sha,a=e.commit.repoPath,r=e.commit.fileName,i.commit=e.commit}catch(e){return H.error(e,"ShowQuickCommitDetailsCommand",`getBlameForLine(${t})`),s.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}try{if((void 0===i.commit||i.commit.isFile)&&(void 0!==i.repoLog&&(i.commit=i.repoLog.commits.get(i.sha),void 0===i.commit&&(i.repoLog=void 0)),void 0===i.repoLog)){const e=await Ts.git.getLog(a,{maxCount:2,ref:i.sha});if(void 0===e)return Io.showCommitNotFoundWarningMessage("Unable to show commit details");i.commit=e.commits.get(i.sha)}if(void 0===i.commit)return Io.showCommitNotFoundWarningMessage("Unable to show commit details");if(void 0===i.commit.workingFileName&&(i.commit.workingFileName=r),void 0===i.goBackCommand){const e=await Ts.git.getBranch(i.commit.repoPath);void 0!==e&&(i.goBackCommand=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to ${e.name} history`},ji.ShowQuickCurrentBranchHistory,[i.commit.toGitUri()]))}const e=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to details of ${T.Space}$(git-commit) ${i.commit.shortSha}`},ji.ShowQuickCommitDetails,[i.commit.toGitUri(),i]),o=await oo.show(i.commit,t,i.goBackCommand,e,i.repoLog);if(void 0===o)return;return o instanceof to?s.commands.executeCommand(ji.ShowQuickCommitFileDetails,o.commit.toGitUri(),{commit:o.commit,sha:o.sha,goBackCommand:e}):o.execute()}catch(e){return H.error(e,"ShowQuickCommitDetailsCommand"),s.window.showErrorMessage("Unable to show commit details. See output channel for more details")}}}class ga extends So{static getMarkdownCommandArgs(e){const t="string"==typeof e?{sha:e}:e;return super.getMarkdownCommandArgsCore(ji.ShowQuickCommitFileDetails,t)}constructor(){super(ji.ShowQuickCommitFileDetails)}async preExecute(e,t={}){return"view"===e.type&&((t=Object.assign({},t)).sha=e.node.uri.sha,wo(e)&&(t.commit=e.node.commit)),this.execute(e.editor,e.uri,t)}async execute(e,t,i={}){if(null==(t=po(t,e)))return;let o=i.commit&&i.commit.workingFileName;const a=await _e.fromUri(t);if(void 0===(i=Object.assign({},i)).sha){if(null==e)return;const t=e.selection.active.line;if(t<0)return;try{const e=await Ts.git.getBlameForLine(a,t);if(void 0===e)return Io.showFileNotUnderSourceControlWarningMessage("Unable to show commit file details");if(e.commit.isUncommitted)return Io.showLineUncommittedWarningMessage("Unable to show commit file details");i.sha=e.commit.sha,i.commit=e.commit,o=y.relative(i.commit.repoPath,a.fsPath)}catch(e){return H.error(e,"ShowQuickCommitFileDetailsCommand",`getBlameForLine(${t})`),s.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}try{if((void 0===i.commit||!i.commit.isFile)&&(void 0!==i.commit&&(o=void 0),void 0!==i.fileLog&&(i.commit=i.fileLog.commits.get(i.sha),void 0===i.commit&&(i.fileLog=void 0)),void 0===i.fileLog&&(i.commit=await Ts.git.getLogCommitForFile(void 0===i.commit?a.repoPath:i.commit.repoPath,a.fsPath,{ref:i.sha}),void 0===i.commit)))return Io.showCommitNotFoundWarningMessage("Unable to show commit file details");if(void 0===i.commit)return Io.showCommitNotFoundWarningMessage("Unable to show commit file details");i.commit.workingFileName=o,[i.commit.workingFileName]=await Ts.git.findWorkingFileName(i.commit);const e=Zt.shortenSha(i.sha);void 0===i.goBackCommand&&(i.goBackCommand=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to details of ${T.Space}$(git-commit) ${e}`},ji.ShowQuickCommitDetails,[i.commit.toGitUri(),{commit:i.commit,sha:i.sha}]));const r=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to details of ${T.Space}$(file-text) ${y.basename(i.commit.fileName)} in ${T.Space}$(git-commit) ${e}`},ji.ShowQuickCommitFileDetails,[i.commit.toGitUri(),i]),n=await eo.show(i.commit,t,i.goBackCommand,r,i.fileLog);if(void 0===n)return;return n instanceof Bs?n.execute():void 0}catch(e){return H.error(e,"ShowQuickCommitFileDetailsCommand"),s.window.showErrorMessage("Unable to show commit file details. See output channel for more details")}}}class pa extends So{constructor(){super(ji.ShowQuickCurrentBranchHistory)}async execute(e,t,i={}){t=po(t,e);try{const o=await fo(t,e,`Show current branch history for which repository${T.Ellipsis}`);if(!o)return;const a=await Ts.git.getBranch(o);if(void 0===a)return;return s.commands.executeCommand(ji.ShowQuickBranchHistory,t,{branch:a.name,repoPath:o,goBackCommand:i.goBackCommand})}catch(e){return H.error(e,"ShowQuickCurrentBranchHistoryCommand"),s.window.showErrorMessage("Unable to show branch history. See output channel for more details")}}}class fa extends So{constructor(){super(ji.ShowQuickFileHistory)}async execute(e,t,i={}){if(null==(t=po(t,e)))return s.commands.executeCommand(ji.ShowQuickCurrentBranchHistory);const o=await _e.fromUri(t);i=Object.assign({},i);const a=`${o.getFormattedPath(i.branchOrTag?` (${i.branchOrTag.name})${ae.pad(T.Dot,2,2)}`:void 0)}${o.sha?` ${ae.pad(T.Dot,1,1)} ${o.shortSha}`:""}`,r=ro.showProgress(a);try{if(void 0===i.log&&(i.log=await Ts.git.getLogForFile(o.repoPath,o.fsPath,{maxCount:i.maxCount,range:i.range,ref:i.branchOrTag&&i.branchOrTag.ref||o.sha}),void 0===i.log))return i.branchOrTag?s.window.showWarningMessage(`The file could not be found in ${i.branchOrTag.name}`):Io.showFileNotUnderSourceControlWarningMessage("Unable to show file history");if(r.token.isCancellationRequested)return;let e=void 0;if(i.log.truncated){const s=new Bs({label:"$(arrow-right) Show Next Commits",description:`${ae.pad(T.Dash,2,3)} shows ${i.log.maxCount} newer commits`},ji.ShowQuickFileHistory,[o,Object.assign({},i,{log:void 0})]),a=ee.last(i.log.commits.values());null!=a&&(e=new Bs({label:"$(arrow-left) Show Previous Commits",description:`${ae.pad(T.Dash,2,3)} shows ${i.log.maxCount} older commits`},ji.ShowQuickFileHistory,[new _e(t,a),Object.assign({},i,{log:void 0,nextPageCommand:s})]))}const n=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to history of ${T.Space}$(file-text) ${y.basename(o.fsPath)}${i.branchOrTag?` from ${T.Space}${i.branchOrTag instanceof ut?"$(tag)":"$(git-branch)"} ${i.branchOrTag.name}`:o.sha?` from ${T.Space}$(git-commit) ${o.shortSha}`:""}`},ji.ShowQuickFileHistory,[t,i]),l=await ro.show(i.log,o,a,{progressCancellation:r,currentCommand:n,goBackCommand:i.goBackCommand,nextPageCommand:i.nextPageCommand,previousPageCommand:e,showAllCommand:void 0!==i.log&&i.log.truncated?new Bs({label:"$(sync) Show All Commits",description:`${ae.pad(T.Dash,2,3)} this may take a while`},ji.ShowQuickFileHistory,[t,Object.assign({},i,{log:void 0,maxCount:0})]):void 0,showInResultsExplorerCommand:void 0!==i.log?new Ws(i.log,{label:a,resultsType:{singular:"commit",plural:"commits"}}):void 0});if(void 0===l)return;if(l instanceof As){const e=await l.execute();if(void 0===e)return;return e instanceof Bs?e.execute():s.commands.executeCommand(ji.ShowQuickFileHistory,o,Object.assign({},i,{log:void 0,branchOrTag:e.branchOrTag,goBackCommand:n}))}return l instanceof Bs?l.execute():s.commands.executeCommand(ji.ShowQuickCommitFileDetails,l.commit.toGitUri(),{commit:l.commit,fileLog:i.log,sha:l.commit.sha,goBackCommand:n})}catch(e){return H.error(e,"ShowQuickFileHistoryCommand"),s.window.showErrorMessage("Unable to show file history. See output channel for more details")}finally{r.cancel()}}}class va extends So{constructor(){super(ji.ShowQuickRepoStatus)}async execute(e,t,i={}){t=po(t,e);try{const o=await fo(t,e,`Show status for which repository${T.Ellipsis}`);if(!o)return;const a=await Ts.git.getStatusForRepo(o);if(void 0===a)return s.window.showWarningMessage("Unable to show repository status");const r=await uo.show(a,i.goBackCommand);if(void 0===r)return;return r instanceof Bs?r.execute():void 0}catch(e){return H.error(e,"ShowQuickRepoStatusCommand"),s.window.showErrorMessage("Unable to show repository status. See output channel for more details")}}}class wa extends So{constructor(){super(ji.ShowQuickStashList)}async execute(e,t,i={}){t=po(t,e);const o=go.showProgress("list");try{const a=await fo(t,e,`Show stashed changes for which repository${T.Ellipsis}`);if(!a)return;const r=await Ts.git.getStashList(a);if(void 0===r)return s.window.showWarningMessage("Unable to show stashed changes");if(o.token.isCancellationRequested)return;const n=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to stashed changes`},ji.ShowQuickStashList,[t,{goBackCommand:i.goBackCommand}]),l=await go.show(r,"list",o,i.goBackCommand,n);if(void 0===l)return;return l instanceof Bs?l.execute():s.commands.executeCommand(ji.ShowQuickCommitDetails,l.commit.toGitUri(),{commit:l.commit,sha:l.commit.sha,goBackCommand:n})}catch(e){return H.error(e,"ShowQuickStashListCommand"),s.window.showErrorMessage("Unable to show stashed changes. See output channel for more details")}finally{o.cancel()}}}class ba extends yo{constructor(){super(ji.ShowResultsExplorer)}execute(){return Ts.resultsExplorer.show()}}class _a extends yo{constructor(){super(ji.StashApply)}async preExecute(e,t={confirm:!0,deleteAfter:!1}){return wo(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0,deleteAfter:!1}){if(void 0===(e=Object.assign({},e)).stashItem||void 0===e.stashItem.stashName){let t,i=await Ts.git.getActiveRepoPath();if(!i){const s=await co.show(`Apply stashed changes from which repository${T.Ellipsis}`,e.goBackCommand);if(s instanceof Bs)return s.execute();if(void 0===s)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to pick another repository`},ji.StashApply,[e]),i=s.repoPath}const o=go.showProgress("apply");try{const a=await Ts.git.getStashList(i);if(void 0===a)return s.window.showInformationMessage("There are no stashed changes");if(o.token.isCancellationRequested)return;const r=new Bs({label:`go back ${T.ArrowBack}`,description:`${ae.pad(T.Dash,2,3)} to apply stashed changes`},ji.StashApply,[e]),n=await go.show(a,"apply",o,t||e.goBackCommand,r);if(n instanceof Bs)return n.execute();if(void 0===n)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.goBackCommand=r,e.stashItem=n.commit}finally{o.cancel()}}try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${T.Ellipsis}`:e.stashItem.message,i=await s.window.showWarningMessage(`Apply stashed changes '${t}' to your working tree?`,{title:"Yes, delete after applying"},{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"No"===i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();e.deleteAfter="Yes"!==i.title}return await Ts.git.stashApply(e.stashItem.repoPath,e.stashItem.stashName,e.deleteAfter)}catch(e){return H.error(e,"StashApplyCommand"),e.message.includes("Your local changes to the following files would be overwritten by merge")?s.window.showWarningMessage("Unable to apply stash. Your working tree changes would be overwritten."):e.message.includes("Auto-merging")&&e.message.includes("CONFLICT")?s.window.showInformationMessage("Stash applied with conflicts"):s.window.showErrorMessage("Unable to apply stash. See output channel for more details")}}}class Ca extends yo{constructor(){super(ji.StashDelete)}async preExecute(e,t={confirm:!0}){return wo(e)?((t=Object.assign({},t)).stashItem=e.node.commit,this.execute(t)):this.execute(t)}async execute(e={confirm:!0}){if(void 0!==(e=Object.assign({},e)).stashItem&&void 0!==e.stashItem.stashName&&void 0!==e.stashItem.repoPath){void 0===e.confirm&&(e.confirm=!0);try{if(e.confirm){const t=e.stashItem.message.length>80?`${e.stashItem.message.substring(0,80)}${T.Ellipsis}`:e.stashItem.message,i=await s.window.showWarningMessage(`Delete stashed changes '${t}'?`,{title:"Yes"},{title:"No",isCloseAffordance:!0});if(void 0===i||"Yes"!==i.title)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute()}return await Ts.git.stashDelete(e.stashItem.repoPath,e.stashItem.stashName)}catch(e){return H.error(e,"StashDeleteCommand"),s.window.showErrorMessage("Unable to delete stash. See output channel for more details")}}}}class ya extends yo{constructor(){super(ji.StashSave)}async preExecute(e,t={}){return"scm-states"===e.type?((t=Object.assign({},t)).uris=e.scmResourceStates.map(e=>e.resourceUri),this.execute(t)):"scm-groups"===e.type?((t=Object.assign({},t)).uris=e.scmResourceGroups.reduce((e,t)=>e.concat(t.resourceStates.map(e=>e.resourceUri)),[]),this.execute(t)):this.execute(t)}async execute(e={}){let t=await Ts.git.getHighlanderRepoPath();if(!t){const i=await co.show(`Stash changes for which repository${T.Ellipsis}`,e.goBackCommand);if(i instanceof Bs)return i.execute();if(void 0===i)return void 0===e.goBackCommand?void 0:e.goBackCommand.execute();t=i.repoPath}try{return null==e.message&&((e=Object.assign({},e)).message=await s.window.showInputBox({prompt:"Please provide a stash message",placeHolder:"Stash message"}),void 0===e.message)?void 0===e.goBackCommand?void 0:e.goBackCommand.execute():await Ts.git.stashSave(t,e.message,e.uris)}catch(e){H.error(e,"StashSaveCommand");const t=e&&e.message;return t.includes("newer version of Git")?s.window.showErrorMessage(`Unable to save stash. ${t}`):s.window.showErrorMessage("Unable to save stash. See output channel for more details")}}}class xa extends yo{constructor(){super(ji.SwitchMode)}async execute(){const e=await no.show();void 0!==e&&await ti.update(ti.name("mode")("active").value,e.key,s.ConfigurationTarget.Global)}}class $a extends yo{constructor(){super(ji.ToggleReviewMode)}async execute(){if(!Object.keys(Ts.config.modes).includes("review"))return;const e="review"===Ts.config.mode.active?void 0:"review";await ti.update(ti.name("mode")("active").value,e,s.ConfigurationTarget.Global)}}class Sa extends yo{constructor(){super(ji.ToggleZenMode)}async execute(){if(!Object.keys(Ts.config.modes).includes("zen"))return;const e="zen"===Ts.config.mode.active?void 0:"zen";await ti.update(ti.name("mode")("active").value,e,s.ConfigurationTarget.Global)}}class ka extends yo{constructor(){super(ji.ToggleCodeLens)}execute(){return Ts.codeLens.toggleCodeLens()}}class Da extends xo{constructor(){super(ji.ToggleFileBlame)}async execute(e,t,i={}){if(null!=e&&null!=t&&!n.equals(t,e.document.uri)){const i=s.window.visibleTextEditors.find(e=>n.equals(t,e.document.uri));void 0!==i&&(e=i)}try{return void 0===i.type&&(i=Object.assign({},i,{type:p.Blame})),Ts.fileAnnotations.toggle(e,i.type,void 0!==i.sha?i.sha:e&&e.selection.active.line)}catch(e){return H.error(e,"ToggleFileBlameCommand"),s.window.showErrorMessage(`Unable to toggle file ${i.type} annotations. See output channel for more details`)}}}class Fa extends xo{constructor(){super(ji.ToggleFileHeatmap)}async execute(e,t){s.commands.executeCommand(ji.ToggleFileBlame,t,{type:p.Heatmap})}}class Pa extends xo{constructor(){super(ji.ToggleFileRecentChanges)}async execute(e,t){s.commands.executeCommand(ji.ToggleFileBlame,t,{type:p.RecentChanges})}}class Ta extends xo{constructor(){super(ji.ToggleLineBlame)}async execute(e,t){try{return Ts.lineAnnotations.toggle(e)}catch(e){return H.error(e,"ToggleLineBlameCommand"),s.window.showErrorMessage("Unable to toggle line blame annotations. See output channel for more details")}}}async function Ra(e){const t=process.hrtime();H.configure(e);const i=s.extensions.getExtension(S).packageJSON.version,o=s.workspace.getConfiguration("git",null).get("enabled",!0);if(!o)return H.log(`GitLens(v${i}) was NOT activated -- "git.enabled": false`),E(F.Enabled,o),void Io.showGitDisabledErrorMessage();ei.configure(e);const a=e.globalState.get(R.GitLensVersion);await async function(e,t){if(void 0===t)return;const i=re.fromString(t);try{if(1!==re.compare(i,re.from(7,5,10))&&(await ti.migrate("annotations.file.gutter.gravatars",ti.name("blame")("avatars").value),await ti.migrate("annotations.file.gutter.compact",ti.name("blame")("compact").value),await ti.migrate("annotations.file.gutter.dateFormat",ti.name("blame")("dateFormat").value),await ti.migrate("annotations.file.gutter.format",ti.name("blame")("format").value),await ti.migrate("annotations.file.gutter.heatmap.enabled",ti.name("blame")("heatmap")("enabled").value),await ti.migrate("annotations.file.gutter.heatmap.location",ti.name("blame")("heatmap")("location").value),await ti.migrate("annotations.file.gutter.lineHighlight.enabled",ti.name("blame")("highlight")("enabled").value),await ti.migrate("annotations.file.gutter.lineHighlight.locations",ti.name("blame")("highlight")("locations").value),await ti.migrate("annotations.file.gutter.separateLines",ti.name("blame")("separateLines").value),await ti.migrate("codeLens.locations",ti.name("codeLens")("scopes").value),await ti.migrate("codeLens.perLanguageLocations",ti.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{const t=e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}));return t}}),await ti.migrate("codeLens.customLocationSymbols",ti.name("codeLens")("symbolScopes").value),await ti.migrate("annotations.line.trailing.dateFormat",ti.name("currentLine")("dateFormat").value),await ti.migrate("blame.line.enabled",ti.name("currentLine")("enabled").value),await ti.migrate("annotations.line.trailing.format",ti.name("currentLine")("format").value),await ti.migrate("annotations.file.gutter.hover.changes",ti.name("hovers")("annotations")("changes").value),await ti.migrate("annotations.file.gutter.hover.details",ti.name("hovers")("annotations")("details").value),await ti.migrate("annotations.file.gutter.hover.details",ti.name("hovers")("annotations")("enabled").value),await ti.migrate("annotations.file.gutter.hover.wholeLine",ti.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await ti.migrate("annotations.line.trailing.hover.changes",ti.name("hovers")("currentLine")("changes").value),await ti.migrate("annotations.line.trailing.hover.details",ti.name("hovers")("currentLine")("details").value),await ti.migrate("blame.line.enabled",ti.name("hovers")("currentLine")("enabled").value),await ti.migrate("annotations.line.trailing.hover.wholeLine",ti.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await ti.migrate("gitExplorer.gravatars",ti.name("explorers")("avatars").value),await ti.migrate("gitExplorer.commitFileFormat",ti.name("explorers")("commitFileFormat").value),await ti.migrate("gitExplorer.commitFormat",ti.name("explorers")("commitFormat").value),await ti.migrate("gitExplorer.stashFileFormat",ti.name("explorers")("stashFileFormat").value),await ti.migrate("gitExplorer.stashFormat",ti.name("explorers")("stashFormat").value),await ti.migrate("gitExplorer.statusFileFormat",ti.name("explorers")("statusFileFormat").value),await ti.migrate("recentChanges.file.lineHighlight.locations",ti.name("recentChanges")("highlight")("locations").value)),1!==re.compare(i,re.from(8,0,0,"beta2"))&&(await ti.migrate("debug",ti.name("outputLevel").value,{migrationFn:e=>e?_.Debug:ti.get(ti.name("outputLevel").value)}),await ti.migrate("debug",ti.name("debug").value,{migrationFn:e=>void 0})),1!==re.compare(i,re.from(8,0,0,"rc"))){let e=ti.name("blame")("highlight")("locations").value;await ti.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}}),e=ti.name("recentChanges")("highlight")("locations").value,await ti.migrate(e,e,{migrationFn:e=>{const t=e.indexOf("overviewRuler");return-1!==t&&e.splice(t,1,"overview"),e}})}if(1!==re.compare(i,re.from(8,0,0))&&(await ti.migrateIfMissing("annotations.file.gutter.gravatars",ti.name("blame")("avatars").value),await ti.migrateIfMissing("annotations.file.gutter.compact",ti.name("blame")("compact").value),await ti.migrateIfMissing("annotations.file.gutter.dateFormat",ti.name("blame")("dateFormat").value),await ti.migrateIfMissing("annotations.file.gutter.format",ti.name("blame")("format").value),await ti.migrateIfMissing("annotations.file.gutter.heatmap.enabled",ti.name("blame")("heatmap")("enabled").value),await ti.migrateIfMissing("annotations.file.gutter.heatmap.location",ti.name("blame")("heatmap")("location").value),await ti.migrateIfMissing("annotations.file.gutter.lineHighlight.enabled",ti.name("blame")("highlight")("enabled").value),await ti.migrateIfMissing("annotations.file.gutter.lineHighlight.locations",ti.name("blame")("highlight")("locations").value),await ti.migrateIfMissing("annotations.file.gutter.separateLines",ti.name("blame")("separateLines").value),await ti.migrateIfMissing("codeLens.locations",ti.name("codeLens")("scopes").value),await ti.migrateIfMissing("codeLens.perLanguageLocations",ti.name("codeLens")("scopesByLanguage").value,{migrationFn:e=>{const t=e.map(e=>({language:e.language,scopes:e.locations,symbolScopes:e.customSymbols}));return t}}),await ti.migrateIfMissing("codeLens.customLocationSymbols",ti.name("codeLens")("symbolScopes").value),await ti.migrateIfMissing("annotations.line.trailing.dateFormat",ti.name("currentLine")("dateFormat").value),await ti.migrateIfMissing("blame.line.enabled",ti.name("currentLine")("enabled").value),await ti.migrateIfMissing("annotations.line.trailing.format",ti.name("currentLine")("format").value),await ti.migrateIfMissing("annotations.file.gutter.hover.changes",ti.name("hovers")("annotations")("changes").value),await ti.migrateIfMissing("annotations.file.gutter.hover.details",ti.name("hovers")("annotations")("details").value),await ti.migrateIfMissing("annotations.file.gutter.hover.details",ti.name("hovers")("annotations")("enabled").value),await ti.migrateIfMissing("annotations.file.gutter.hover.wholeLine",ti.name("hovers")("annotations")("over").value,{migrationFn:e=>e?"line":"annotation"}),await ti.migrateIfMissing("annotations.line.trailing.hover.changes",ti.name("hovers")("currentLine")("changes").value),await ti.migrateIfMissing("annotations.line.trailing.hover.details",ti.name("hovers")("currentLine")("details").value),await ti.migrateIfMissing("blame.line.enabled",ti.name("hovers")("currentLine")("enabled").value),await ti.migrateIfMissing("annotations.line.trailing.hover.wholeLine",ti.name("hovers")("currentLine")("over").value,{migrationFn:e=>e?"line":"annotation"}),await ti.migrateIfMissing("gitExplorer.gravatars",ti.name("explorers")("avatars").value),await ti.migrateIfMissing("gitExplorer.commitFileFormat",ti.name("explorers")("commitFileFormat").value),await ti.migrateIfMissing("gitExplorer.commitFormat",ti.name("explorers")("commitFormat").value),await ti.migrateIfMissing("gitExplorer.stashFileFormat",ti.name("explorers")("stashFileFormat").value),await ti.migrateIfMissing("gitExplorer.stashFormat",ti.name("explorers")("stashFormat").value),await ti.migrateIfMissing("gitExplorer.statusFileFormat",ti.name("explorers")("statusFileFormat").value),await ti.migrateIfMissing("recentChanges.file.lineHighlight.locations",ti.name("recentChanges")("highlight")("locations").value)),1!==re.compare(i,re.from(8,0,2))){const e=ti.name("keymap").value;await ti.migrate(e,e,{fallbackValue:b.Alternate,migrationFn:e=>"standard"===e?b.Alternate:e})}1!==re.compare(i,re.from(8,2,4))&&await ti.migrate("advanced.menus",ti.name("menus").value,{migrationFn:e=>({editor:{blame:!!e.editorContext.blame,clipboard:!!e.editorContext.copy,compare:!!e.editorContext.lineDiff,details:!!e.editorContext.details,history:!!e.editorContext.history,remote:!!e.editorContext.remote},editorGroup:{blame:!!e.editorTitle.blame,compare:!!e.editorTitle.fileDiff,history:!!e.editorTitle.history,remote:!!e.editorTitle.remote},editorTab:{compare:!!e.editorTitleContext.fileDiff,history:!!e.editorTitleContext.history,remote:!!e.editorTitleContext.remote},explorer:{compare:!!e.explorerContext.fileDiff,history:!!e.explorerContext.history,remote:!!e.explorerContext.remote}})})}catch(e){H.error(e,"migrateSettings")}}(0,a);const r=ti.get();try{let e=r.advanced.git;if(!e)try{const t=s.extensions.getExtension("vscode.git");void 0!==t&&(e=await(await t.activate()).getGitPath())}catch(e){}await Zt.initialize(e||s.workspace.getConfiguration("git").get("path"))}catch(e){return H.error(e,`GitLens(v${i}).activate`),e.message.includes("Unable to find git")&&await s.window.showErrorMessage(`GitLens was unable to find Git. Please make sure Git is installed. Also ensure that Git is either in the PATH, or that '${x}.${ti.name("advanced")("git").value}' is pointed to its installed location.`),void E(F.Enabled,!1)}Ts.initialize(e,r),E(F.KeyMap,Ts.config.keymap),Ts.context.subscriptions.push(new Fo),Ts.context.subscriptions.push(new To),Ts.context.subscriptions.push(new Ro),Ts.context.subscriptions.push(new Eo),Ts.context.subscriptions.push(new Bo),Ts.context.subscriptions.push(new No),Ts.context.subscriptions.push(new Ao),Ts.context.subscriptions.push(new Mo),Ts.context.subscriptions.push(new Wo),Ts.context.subscriptions.push(new Ho),Ts.context.subscriptions.push(new jo),Ts.context.subscriptions.push(new Go),Ts.context.subscriptions.push(new Vo),Ts.context.subscriptions.push(new zo),Ts.context.subscriptions.push(new Qo),Ts.context.subscriptions.push(new Ko),Ts.context.subscriptions.push(new Yo),Ts.context.subscriptions.push(new Xo),Ts.context.subscriptions.push(new Zo),Ts.context.subscriptions.push(new Jo),Ts.context.subscriptions.push(new ea),Ts.context.subscriptions.push(new ta),Ts.context.subscriptions.push(new ia),Ts.context.subscriptions.push(new sa),Ts.context.subscriptions.push(new oa),Ts.context.subscriptions.push(new aa),Ts.context.subscriptions.push(new la),Ts.context.subscriptions.push(new ca),Ts.context.subscriptions.push(new ha),Ts.context.subscriptions.push(new da),Ts.context.subscriptions.push(new ma),Ts.context.subscriptions.push(new ua),Ts.context.subscriptions.push(new ga),Ts.context.subscriptions.push(new pa),Ts.context.subscriptions.push(new fa),Ts.context.subscriptions.push(new va),Ts.context.subscriptions.push(new wa),Ts.context.subscriptions.push(new ba),Ts.context.subscriptions.push(new _a),Ts.context.subscriptions.push(new Ca),Ts.context.subscriptions.push(new ya),Ts.context.subscriptions.push(new xa),Ts.context.subscriptions.push(new ka),Ts.context.subscriptions.push(new Da),Ts.context.subscriptions.push(new Fa),Ts.context.subscriptions.push(new Pa),Ts.context.subscriptions.push(new Ta),Ts.context.subscriptions.push(new $a),Ts.context.subscriptions.push(new Sa),function(e){if(-1!==Zt.compareGitVersion("2.2.0"))return;Io.showGitVersionUnsupportedErrorMessage(e)}(Zt.getGitVersion()),async function(e,t){if(void 0===t)return H.log("GitLens first-time install"),void(Ts.config.showWhatsNewAfterUpgrades&&await s.commands.executeCommand(ji.ShowWelcomePage));if(t!==e&&(H.log(`GitLens upgraded from v${t} to v${e}`),0===re.compare(re.fromString(t),re.from(8,0,0))))return void await s.commands.executeCommand(ji.ShowWelcomePage);if(!Ts.config.showWhatsNewAfterUpgrades)return;const[i,o]=e.split("."),[a,r]=t.split(".");if(i===a&&o===r)return;if(i<a||i===a&&o<r)return;await s.commands.executeCommand(ji.ShowWelcomePage)}(i,a),Io.showKeyBindingsInfoMessage(),e.globalState.update(R.GitLensVersion,i);const n=process.hrtime(t);H.log(`GitLens(v${i}) activated in ${1e3*n[0]+Math.floor(n[1]/1e6)} ms`)}function Ea(){}i.d(t,"activate",function(){return Ra}),i.d(t,"deactivate",function(){return Ea})},function(e,t){e.exports=require("tmp")},function(e,t){e.exports=require("clipboardy")}]);